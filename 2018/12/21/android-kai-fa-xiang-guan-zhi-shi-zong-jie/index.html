<!DOCTYPE HTML>
<html lang="CN">
<head>
    

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Android开发相关知识总结, 极客文库">
    <meta name="description" content="Android面试题

1. Android四大组件
1.1. Activity
1.2. 服务
1.3. 内容提供程序
1.4. 广播接收器


2. 四大组件的启动方式
3. 画出Activity的生命周期图
4. 介绍下不同场景下Ac">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Android开发相关知识总结 | 极客文库-知识库</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

</head>

<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="container">
            <div class="nav-wrapper">
                <div class="brand-logo">
                    <a href="/" class="waves-effect waves-light">
                        
                        <img src="/medias/logo.png" class="logo-img hide-on-small-only">
                        
                        <span class="logo-span">极客文库-知识库</span>
                    </a>
                </div>
                <a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>主页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友链</span>
        </a>
    </li>
    
    <li>
        <a id="toggleSearch" class="waves-effect waves-light">
            <i id="searchIcon" class="mdi-action-search"></i>
        </a>
    </li>

</ul>

<div class="side-nav" id="mobile-nav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">极客文库-知识库</div>
        <div class="logo-desc">
            
            汇总计算机相关领域知识、文章及教程，认准域名：https://zhishi.jikewenku.com
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                主页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友链
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/geekerstar" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>

    <div class="social-link"><a href="https://github.com/geekerstar" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
    <i class="fa fa-github"></i>
</a>
<a href="https://weibo.com/247507792" class="tooltipped" target="_blank" data-tooltip="微博联系我" data-position="top" data-delay="50">
    <i class="fa fa-weibo"></i>
</a>
<a href="#!" class="tooltipped" data-tooltip="QQ联系我: 247507792" data-position="top" data-delay="50">
    <i class="fa fa-qq"></i>
</a>

<a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
    <i class="fa fa-rss"></i>
</a>
</div>
</div>

            </div>
        </div>

        
        <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/geekerstar" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewbox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
    </svg>
</a>
        
    </nav>
</header>





<div class="bg-cover post-cover" style="background-image: url('/medias/featureimages/20.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Android开发相关知识总结
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1,
    #articleContent h2,
    #articleContent h3,
    #articleContent h4,
    #articleContent h5,
    #articleContent h6 {
        padding-top: 76px;
        margin-top: -76px;
    }

    #articleContent h1 {
        line-height: 3.5rem;
    }

    #articleContent h2 {
        line-height: 3.2rem;
    }

    #articleContent h3 {
        line-height: 2.8rem;
    }

    #articleContent h4 {
        line-height: 2.5rem;
    }

    #articleContent h5 {
        line-height: 2.2rem;
    }

    #articleContent h6 {
        line-height: 1.9rem;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }
</style>
<div class="row">
    <div class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            
            <div class="article-tag">
                
                <a href="/tags/android/" target="_blank">
                    <span class="chip bg-color">android</span>
                </a>
                
            </div>
            
            <div class="post-info">
                
                <span class="post-cate">
                    <i class="fa fa-bookmark fa-fw icon-category"></i>
                    
                    <a href="/categories/android/" class="post-category" target="_blank">
                        android
                    </a>
                    
                </span>
                

                <span class="post-date">
                    <i class="fa fa-clock-o fa-fw"></i>2018-12-21
                </span>
            </div>
        </div>
        <hr>
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Android面试题"><a href="#Android面试题" class="headerlink" title="Android面试题"></a>Android面试题</h1><!-- TOC -->
<ul>
<li><a href="#1-android四大组件">1. Android四大组件</a><ul>
<li><a href="#11-activity">1.1. Activity</a></li>
<li><a href="#12-服务">1.2. 服务</a></li>
<li><a href="#13-内容提供程序">1.3. 内容提供程序</a></li>
<li><a href="#14-广播接收器">1.4. 广播接收器</a></li>
</ul>
</li>
<li><a href="#2-四大组件的启动方式">2. 四大组件的启动方式</a></li>
<li><a href="#3-画出activity的生命周期图">3. 画出Activity的生命周期图</a></li>
<li><a href="#4-介绍下不同场景下activity生命周期的变化过程">4. 介绍下不同场景下Activity生命周期的变化过程</a></li>
<li><a href="#5-当activity-a启动activity-b时生命周期执行过程">5. 当Activity A启动Activity B时，生命周期执行过程？</a></li>
<li><a href="#6-内存不足时系统会杀掉后台的activity若需要进行一些临时状态的保存在哪个方法进行怎么恢复数据">6. 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？</a></li>
<li><a href="#7-什么是任务">7. 什么是任务？</a></li>
<li><a href="#8-activity的启动模式">8. Activity的启动模式？</a></li>
<li><a href="#9-横竖屏切换时候activity的生命周期">9. 横竖屏切换时候activity的生命周期？</a></li>
<li><a href="#10-如何将一个activity设置成窗口的样式">10. 如何将一个Activity设置成窗口的样式？</a></li>
<li><a href="#11-activity之间的数据传递有哪些方式">11. Activity之间的数据传递有哪些方式？</a></li>
<li><a href="#12-fragment的好处">12. Fragment的好处：</a></li>
<li><a href="#13-intent的原理作用可以传递哪些类型的参数">13. Intent的原理，作用，可以传递哪些类型的参数？</a></li>
<li><a href="#14-intent的主要使用方法">14. Intent的主要使用方法</a><ul>
<li><a href="#141-启动-activity">14.1. 启动 Activity</a></li>
<li><a href="#142-启动服务">14.2. 启动服务</a></li>
<li><a href="#143-传递广播">14.3. 传递广播</a></li>
</ul>
</li>
<li><a href="#15-intent包含哪些信息">15. Intent包含哪些信息</a></li>
<li><a href="#16-什么是intent过滤器">16. 什么是Intent过滤器</a></li>
<li><a href="#17-service的启动方式">17. Service的启动方式</a></li>
<li><a href="#18-service的生命周期">18. Service的生命周期</a></li>
<li><a href="#19-activity怎么和service绑定怎么在activity中启动自己对应的service">19. Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？</a></li>
<li><a href="#20-允许绑定的已启动服务的生命周期">20. 允许绑定的已启动服务的生命周期</a></li>
<li><a href="#21-service中可以弹toast吗">21. Service中可以弹Toast吗？</a></li>
<li><a href="#22-进程的优先级">22. 进程的优先级</a><ul>
<li><a href="#221-前台进程">22.1. 前台进程</a></li>
<li><a href="#222-可视进程">22.2. 可视进程</a></li>
<li><a href="#223-服务进程">22.3. 服务进程</a></li>
<li><a href="#224-后台进程">22.4. 后台进程</a></li>
<li><a href="#225-空进程">22.5. 空进程</a></li>
</ul>
</li>
<li><a href="#23-intentservice如何工作">23. IntentService如何工作？</a></li>
<li><a href="#24-intentservice与service的区别">24. IntentService与Service的区别？</a></li>
<li><a href="#25-android-service与activity之间的通信方式">25. Android Service与Activity之间的通信方式？</a></li>
<li><a href="#26-broadcastreceiver简介">26. BroadcastReceiver简介</a><ul>
<li><a href="#261-用途">26.1. 用途</a></li>
<li><a href="#262-使用场景">26.2. 使用场景</a></li>
<li><a href="#263-实现原理">26.3. 实现原理</a></li>
<li><a href="#264-注册方式">26.4. 注册方式</a></li>
</ul>
</li>
<li><a href="#27-为什么要用contentprovider它和sql的实现上有什么差别">27. 为什么要用ContentProvider？它和SQL的实现上有什么差别？</a></li>
<li><a href="#28-contentprovider怎么实现数据共享">28. ContentProvider怎么实现数据共享？</a></li>
<li><a href="#29-android如何访问自定义contentprovider">29. Android如何访问自定义ContentProvider</a></li>
<li><a href="#30-android中activityintentcontent-providerservice各有什么区别">30. Android中Activity，Intent，Content Provider，Service各有什么区别。</a></li>
<li><a href="#31-android数据存储方式">31. Android数据存储方式？</a></li>
<li><a href="#32-android中常用的布局都有哪些">32. Android中常用的布局都有哪些？</a></li>
<li><a href="#33-androidlayout_gravity和androidgravity的区别">33. <code>android:layout_gravity</code>和<code>android:gravity</code>的区别？</a></li>
<li><a href="#34-android平台架构">34. Android平台架构</a><ul>
<li><a href="#341-系统应用">34.1. 系统应用</a></li>
<li><a href="#342-java-api框架">34.2. Java API框架</a></li>
<li><a href="#343-原生cc库">34.3. 原生C/C++库</a></li>
<li><a href="#344-android-runtime">34.4. Android Runtime</a></li>
<li><a href="#345-硬件抽象层hal">34.5. 硬件抽象层（HAL）</a></li>
<li><a href="#346-linux-内核">34.6. Linux 内核</a></li>
</ul>
</li>
<li><a href="#35-fragment生命周期">35. Fragment生命周期</a></li>
<li><a href="#36-activity生命周期对片段生命周期的影响">36. Activity生命周期对片段生命周期的影响</a></li>
<li><a href="#37-android事件分发">37. Android事件分发</a><ul>
<li><a href="#371-public-boolean-dispatchtoucheventmotionevent-ev">37.1. <code>public boolean dispatchTouchEvent(MotionEvent ev)</code></a></li>
<li><a href="#372-public-boolean-onintercepttoucheventmotionevent-ev">37.2. <code>public boolean onInterceptTouchEvent(MotionEvent ev)</code></a></li>
<li><a href="#373-public-boolean-ontoucheventmotionevent-ev">37.3. <code>public boolean onTouchEvent(MotionEvent ev)</code></a></li>
</ul>
</li>
<li><a href="#38-android系统启动过程">38. Android系统启动过程</a><ul>
<li><a href="#381-boot-rom">38.1. Boot ROM</a></li>
<li><a href="#382-boot-loader">38.2. Boot Loader</a></li>
<li><a href="#383-kernel">38.3. Kernel</a></li>
<li><a href="#384-init">38.4. init</a><ul>
<li><a href="#3841-本地服务">38.4.1. 本地服务</a></li>
<li><a href="#3842-android服务">38.4.2. Android服务</a></li>
</ul>
</li>
<li><a href="#385-zygote-and-dalvikart">38.5. Zygote and Dalvik（ART）</a></li>
<li><a href="#386-system-server">38.6. System Server</a></li>
<li><a href="#387-boot-completed">38.7. Boot completed</a></li>
</ul>
</li>
<li><a href="#39-android应用启动过程">39. Android应用启动过程</a></li>
<li><a href="#40-dpdipdpippi区别">40. dp，dip，dpi，ppi区别</a></li>
<li><a href="#41-长度和字体的推荐单位">41. 长度和字体的推荐单位</a></li>
<li><a href="#42-android-view绘制流程">42. Android View绘制流程</a></li>
<li><a href="#43-listview优化">43. ListView优化</a></li>
<li><a href="#44-android-binder机制">44. Android Binder机制</a></li>
<li><a href="#45-binder机制优点">45. Binder机制优点</a></li>
<li><a href="#46-asynctask简介">46. AsyncTask简介</a></li>
<li><a href="#47-为什么handler需要声明为static">47. 为什么Handler需要声明为static？</a></li>
<li><a href="#48-广播注册后不解除注册会有什么问题">48. 广播注册后不解除注册会有什么问题？</a></li>
<li><a href="#49-自定义view">49. 自定义View</a><ul>
<li><a href="#491-实现步骤">49.1. 实现步骤</a></li>
</ul>
</li>
<li><a href="#50-需要被重写的方法">50. 需要被重写的方法</a></li>
<li><a href="#51-parcelable和serializable的区别">51. Parcelable和Serializable的区别</a></li>
<li><a href="#52-android中的内存泄漏">52. Android中的内存泄漏</a></li>
<li><a href="#53-mvc和mvp的区别">53. MVC和MVP的区别</a></li>
<li><a href="#54-内存泄露检测有什么好方法">54. 内存泄露检测有什么好方法？</a></li>
<li><a href="#55-android里面为什么要设计出bundle而不是直接用map结构">55. Android里面为什么要设计出Bundle而不是直接用Map结构</a></li>
<li><a href="#56-在android的mvp架构中使用了什么设计模式">56. 在Android的MVP架构中，使用了什么设计模式</a></li>
<li><a href="#57-android动画类型">57. Android动画类型</a></li>
<li><a href="#58-anr和fc的区别">58. ANR和FC的区别</a></li>
<li><a href="#59-android中的菜单">59. Android中的菜单</a><ul>
<li><a href="#591-选项菜单options-menu">59.1. 选项菜单（Options menu）</a></li>
<li><a href="#592-上下文菜单contextual-menus">59.2. 上下文菜单（Contextual Menus）</a><ul>
<li><a href="#5921-浮动上下文菜单floating-context-menu">59.2.1. 浮动上下文菜单（floating context menu）</a></li>
</ul>
</li>
<li><a href="#593-弹出菜单popup-menu">59.3. 弹出菜单（Popup Menu）</a></li>
</ul>
</li>
<li><a href="#60-baseadapter中需要重载的方法">60. BaseAdapter中需要重载的方法</a></li>
<li><a href="#61-android数字签名要点">61. Android数字签名要点</a></li>
<li><a href="#62-使用相同数字签名的原因">62. 使用相同数字签名的原因</a></li>
<li><a href="#63-theme和sytle">63. Theme和Sytle</a><ul>
<li><a href="#631-style">63.1. Style</a></li>
<li><a href="#632-theme">63.2. Theme</a></li>
</ul>
</li>
<li><a href="#64-toast的时长设置">64. Toast的时长设置</a></li>
<li><a href="#65-触发anr的情况">65. 触发ANR的情况</a></li>
<li><a href="#66-serviceconnection的onserviceconnected触发条件">66. ServiceConnection的<code>onServiceConnected()</code>触发条件</a></li>
<li><a href="#67-android虚拟设备不支持的功能">67. Android虚拟设备不支持的功能</a></li>
<li><a href="#68-remoteview的应用">68. RemoteView的应用</a></li>
<li><a href="#69-android对hashmap做了优化后推出的新的容器类是什么">69. Android对HashMap做了优化后推出的新的容器类是什么？</a><ul>
<li><a href="#691-sparsearray">69.1. SparseArray</a></li>
<li><a href="#692-arraymap">69.2. ArrayMap</a></li>
</ul>
</li>
<li><a href="#70-android安全沙盒">70. Android安全沙盒</a></li>
<li><a href="#71-onstartcommand有哪些返回值">71. <code>onStartCommand()</code>有哪些返回值</a></li>
<li><a href="#72-如何创建绑定服务">72. 如何创建绑定服务</a><ul>
<li><a href="#721-扩展binder类">72.1. 扩展Binder类</a></li>
<li><a href="#722-使用messenger">72.2. 使用Messenger</a></li>
</ul>
</li>
<li><a href="#73-如何绑定到服务">73. 如何绑定到服务</a></li>
<li><a href="#74-android支持的屏幕密度">74. Android支持的屏幕密度</a></li>
<li><a href="#75-如何支持多种屏幕">75. 如何支持多种屏幕</a></li>
<li><a href="#76-什么是资源id">76. 什么是资源ID</a></li>
<li><a href="#77-如何处理运行时变更">77. 如何处理运行时变更</a><ul>
<li><a href="#771-在配置变更期间保留对象">77.1. 在配置变更期间保留对象</a></li>
<li><a href="#772-自行处理配置变更">77.2. 自行处理配置变更</a></li>
</ul>
</li>
<li><a href="#78-androidmanifestxml包括哪些内容">78. AndroidManifest.xml包括哪些内容？</a></li>
<li><a href="#79-用户界面如何构成">79. 用户界面如何构成？</a></li>
<li><a href="#80-为什么要回收bitmap的内存">80. 为什么要回收Bitmap的内存</a></li>
<li><a href="#81-如何优化bitmap">81. 如何优化Bitmap</a></li>
<li><a href="#82-如何在新进程中创建activity／service">82. 如何在新进程中创建Activity／Service</a></li>
<li><a href="#83-onactivityresult什么时候会失效">83. <code>onActivityResult()</code>什么时候会失效？</a></li>
<li><a href="#84-android崩溃捕获">84. Android崩溃捕获</a><ul>
<li><a href="#841-java崩溃捕获">84.1. Java崩溃捕获</a></li>
<li><a href="#842-native崩溃捕获">84.2. Native崩溃捕获</a></li>
</ul>
</li>
<li><a href="#85-android-app构建流程">85. Android APP构建流程</a></li>
<li><a href="#86-class文件与dex文件的区别">86. class文件与.dex文件的区别</a></li>
<li><a href="#87-65535问题">87. 65535问题</a><ul>
<li><a href="#871-原因">87.1. 原因</a></li>
<li><a href="#872-解决方法">87.2. 解决方法</a></li>
</ul>
</li>
<li><a href="#88-dalvik与jvm的区别">88. Dalvik与JVM的区别</a></li>
<li><a href="#89-art相对dalvik的优化">89. ART相对Dalvik的优化</a></li>
<li><a href="#90-android中的classloader">90. Android中的ClassLoader</a></li>
<li><a href="#91-classloader方式实现热修复">91. ClassLoader方式实现热修复</a></li>
<li><a href="#92-asynctask需要在主线程中实例化吗">92. AsyncTask需要在主线程中实例化吗？</a><ul>
<li><a href="#921-api-16之前">92.1. API 16之前</a></li>
<li><a href="#922-api-16及之后api-22之前">92.2. API 16及之后，API 22之前</a></li>
<li><a href="#923-api-22及之后">92.3. API 22及之后</a></li>
</ul>
</li>
<li><a href="#93-android消息处理机制">93. Android消息处理机制</a><ul>
<li><a href="#931-looper">93.1. Looper</a></li>
<li><a href="#932-handler">93.2. Handler</a></li>
</ul>
</li>
<li><a href="#94-startactivity执行流程">94. <code>startActivity()</code>执行流程</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-Android四大组件"><a href="#1-Android四大组件" class="headerlink" title="1. Android四大组件"></a>1. Android四大组件</h2><p>应用组件是Android应用的基本构建基块。每个组件都是一个不同的点，系统可以通过它进入您的应用。并非所有组件都是用户的实际入口点，有些组件相互依赖，但每个组件都以独立实体形式存在，并发挥特定作用—-每个组件都是唯一的构建基块，有助于定义应用的总体行为。</p>
<p>共有四种不同的应用组件类型。每种类型都服务于不同的目的，并且具有定义组件的创建和销毁方式的不同生命周期。</p>
<p>以下便是这四种应用组件类型：</p>
<h3 id="1-1-Activity"><a href="#1-1-Activity" class="headerlink" title="1.1. Activity"></a>1.1. Activity</h3><p>Activity表示具有用户界面的单一屏幕。例如，电子邮件应用可能具有一个显示新电子邮件列表的Activity、一个用于撰写电子邮件的Activity以及一个用于阅读电子邮件的Activity。尽管这些Activity通过协作在电子邮件应用中形成了一种紧密结合的用户体验，但每一个Activity都独立于其他Activity而存在。因此，其他应用可以启动其中任何一个Activity（如果电子邮件应用允许）。例如，相机应用可以启动电子邮件应用内用于撰写新电子邮件的Activity，以便用户共享图片。</p>
<h3 id="1-2-服务"><a href="#1-2-服务" class="headerlink" title="1.2. 服务"></a>1.2. 服务</h3><p>服务是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。服务不提供用户界面。例如，当用户位于其他应用中时，服务可能在后台播放音乐或者通过网络获取数据，但不会阻断用户与Activity的交互。诸如Activity等其他组件可以启动服务，让其运行或与其绑定以便与其进行交互。</p>
<h3 id="1-3-内容提供程序"><a href="#1-3-内容提供程序" class="headerlink" title="1.3. 内容提供程序"></a>1.3. 内容提供程序</h3><p>内容提供程序管理一组共享的应用数据。您可以将数据存储在文件系统、SQLite数据库、网络上或您的应用可以访问的任何其他永久性存储位置。其他应用可以通过内容提供程序查询数据，甚至修改数据（如果内容提供程序允许）。例如，Android系统可提供管理用户联系人信息的内容提供程序。因此，任何具有适当权限的应用都可以查询内容提供程序的某一部分（如<code>ContactsContract.Data</code>），以读取和写入有关特定人员的信息。</p>
<p>内容提供程序也适用于读取和写入您的应用不共享的私有数据。例如，记事本示例应用使用内容提供程序来保存笔记。</p>
<h3 id="1-4-广播接收器"><a href="#1-4-广播接收器" class="headerlink" title="1.4. 广播接收器"></a>1.4. 广播接收器</h3><p>广播接收器是一种用于响应系统范围广播通知的组件。许多广播都是由系统发起的—-例如，通知屏幕已关闭、电池电量不足或已拍摄照片的广播。应用也可以发起广播—-例如，通知其他应用某些数据已下载至设备，并且可供其使用。尽管广播接收器不会显示用户界面，但它们可以创建状态栏通知，在发生广播事件时提醒用户。但广播接收器更常见的用途只是作为通向其他组件的”通道”，设计用于执行极少量的工作。例如，它可能会基于事件发起一项服务来执行某项工作。</p>
<h2 id="2-四大组件的启动方式"><a href="#2-四大组件的启动方式" class="headerlink" title="2. 四大组件的启动方式"></a>2. 四大组件的启动方式</h2><ul>
<li>您可以通过将Intent传递到<code>startActivity()</code>或<code>startActivityForResult()</code>（当您想让Activity返回结果时）来启动Activity（或为其安排新任务）。</li>
<li>您可以通过将Intent传递到<code>startService()</code>来启动服务（或对执行中的服务下达新指令）。或者，您也可以通过将Intent传递到<code>bindService()</code>来绑定到该服务。</li>
<li>您可以通过将Intent传递到<code>sendBroadcast()</code>、<code>sendOrderedBroadcast()</code>或<code>sendStickyBroadcast()</code>等方法来发起广播。</li>
<li>您可以通过在ContentResolver上调用<code>query()</code>来对内容提供程序执行查询。</li>
</ul>
<h2 id="3-画出Activity的生命周期图"><a href="#3-画出Activity的生命周期图" class="headerlink" title="3. 画出Activity的生命周期图"></a>3. 画出Activity的生命周期图</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/activity_lifecycle.png" alt="activity lifecycle"></p>
<h2 id="4-介绍下不同场景下Activity生命周期的变化过程"><a href="#4-介绍下不同场景下Activity生命周期的变化过程" class="headerlink" title="4. 介绍下不同场景下Activity生命周期的变化过程"></a>4. 介绍下不同场景下Activity生命周期的变化过程</h2><ul>
<li>启动Activity：<code>onCreate()</code> –&gt; <code>onStart()</code> –&gt; <code>onResume()</code>，Activity进入运行状态。</li>
<li>Activity退居后台：当前Activity转到新的Activity界面或按Home键回到主屏：<code>onPause()</code> –&gt; <code>onStop()</code>，进入停滞状态；这里有一种特殊情况，如果新Activity采用了透明主题，那么当前Activity不会回调<code>onStop()</code>。</li>
<li>Activity返回前台：<code>onRestart()</code> –&gt; <code>onStart()</code> –&gt; <code>onResume()</code>，再次回到运行状态。</li>
<li>Activity退居后台，且系统内存不足，系统会杀死这个后台状态的Activity，若再次回到这个Activity，则会走<code>onCreate()</code> –&gt; <code>onStart()</code> –&gt; <code>onResume()</code>。</li>
<li>锁定屏与解锁屏幕只会调用<code>onPause()</code>，而不会调用<code>onStop()</code>方法，开屏后则调用<code>onResume()</code>。</li>
</ul>
<h2 id="5-当Activity-A启动Activity-B时，生命周期执行过程？"><a href="#5-当Activity-A启动Activity-B时，生命周期执行过程？" class="headerlink" title="5. 当Activity A启动Activity B时，生命周期执行过程？"></a>5. 当Activity A启动Activity B时，生命周期执行过程？</h2><p><code>A.onPause()</code> –&gt; <code>B.onCreate()</code>，<code>B.onStart()</code>，<code>B.onResume()</code> –&gt; <code>A.onStop()</code>，如果B是个透明的，或者是对话框的样式，就不会调用<code>A.onStop()</code>。</p>
<h2 id="6-内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？"><a href="#6-内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？" class="headerlink" title="6. 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？"></a>6. 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？</h2><ul>
<li>Activity的<code>onSaveInstanceState()</code>和<code>onRestoreInstanceState()</code>并不是生命周期方法，它们不同于<code>onCreate()</code>、<code>onPause()</code>等生命周期方法，它们并不一定会被触发。</li>
<li>当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity，<code>onSaveInstanceState()</code>会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，<code>onSaveInstanceState()</code>就不会被调用。除非该activity是被用户主动销毁的，通常<code>onSaveInstanceState()</code>只适合用于保存一些临时性的状态，而<code>onPause()</code>适合用于数据的持久化保存。</li>
<li>重写<code>onSaveInstanceState()</code>方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写<code>onRestoreInstanceState()</code>方法可以从中提取保存好的数据。</li>
</ul>
<h2 id="7-什么是任务？"><a href="#7-什么是任务？" class="headerlink" title="7. 什么是任务？"></a>7. 什么是任务？</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/activity_task.png" alt="Activity Task"></p>
<p>任务是一个有机整体，当用户开始新任务或通过“主页”按钮转到主屏幕时，可以移动到“后台”。尽管在后台时，该任务中的所有Activity全部停止，但是任务的返回栈仍旧不变，也就是说，当另一个任务发生时，该任务仅仅失去焦点而已，如图所示。然后，任务可以返回到“前台”，用户就能够回到离开时的状态。</p>
<h2 id="8-Activity的启动模式？"><a href="#8-Activity的启动模式？" class="headerlink" title="8. Activity的启动模式？"></a>8. Activity的启动模式？</h2><ul>
<li>standard（默认模式）：系统在启动Activity的任务中创建Activity的新实例并向其传送Intent。Activity可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。</li>
<li>singleTop：如果当前任务的顶部已存在Activity的一个实例，则系统会通过调用该实例的onNewIntent()方法向其传送Intent，而不是创建Activity的新实例。Activity可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例（但前提是位于返回栈顶部的Activity并不是Activity的现有实例）。例如，假设任务的返回栈包含根Activity A以及Activity B、C和位于顶部的D（堆栈是A-B-C-D；D位于顶部）。收到针对D类Activity的Intent。如果D具有默认的”standard”启动模式，则会启动该类的新实例，且堆栈会变成A-B-C-D-D。但是，如果D的启动模式是”singleTop”，则D的现有实例会通过onNewIntent()接收Intent，因为它位于堆栈的顶部；而堆栈仍为A-B-C-D。但是，如果收到针对B类Activity的Intent，则会向堆栈添加B的新实例，即便其启动模式为”singleTop”也是如此。</li>
<li>singleTask：系统创建新任务并实例化位于新任务底部的Activity。但是，如果该Activity的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的onNewIntent()方法向其传送Intent，而不是创建新实例。一次只能存在Activity的一个实例。</li>
<li>singleInstace：与”singleTask”相同，只是系统不会将任何其他Activity启动到包含实例的任务中。该Activity始终是其任务唯一仅有的成员；由此Activity启动的任何Activity均在单独的任务中打开。</li>
</ul>
<h2 id="9-横竖屏切换时候activity的生命周期？"><a href="#9-横竖屏切换时候activity的生命周期？" class="headerlink" title="9. 横竖屏切换时候activity的生命周期？"></a>9. 横竖屏切换时候activity的生命周期？</h2><ul>
<li>不设置Activity的<code>android：configChanges</code>时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。</li>
<li>设置Activity的<code>android：configChanges=&quot;orientation&quot;</code>时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。</li>
<li>设置Activity的<code>android：configChanges=&quot;orientation|keyboardHidden&quot;</code>时，切屏不会重新调用各个生命周期，只会执行<code>onConfigurationChanged()</code>方法。</li>
</ul>
<h2 id="10-如何将一个Activity设置成窗口的样式？"><a href="#10-如何将一个Activity设置成窗口的样式？" class="headerlink" title="10. 如何将一个Activity设置成窗口的样式？"></a>10. 如何将一个Activity设置成窗口的样式？</h2><p>只需要给我们的Activity配置如下属性即可<code>android:theme=&quot;@android:style/Theme.Dialog&quot;</code>。</p>
<h2 id="11-Activity之间的数据传递有哪些方式？"><a href="#11-Activity之间的数据传递有哪些方式？" class="headerlink" title="11. Activity之间的数据传递有哪些方式？"></a>11. Activity之间的数据传递有哪些方式？</h2><ul>
<li><code>intent.putExtra()</code>方法；</li>
<li>使用全局变量Application；</li>
<li>使用静态变量；</li>
<li>剪切板ClipboardManager传递数据；</li>
<li>借助Application共享Handler利用消息处理机制；</li>
<li>使用Broadcast广播；</li>
<li>使用EventBus。</li>
</ul>
<h2 id="12-Fragment的好处："><a href="#12-Fragment的好处：" class="headerlink" title="12. Fragment的好处："></a>12. Fragment的好处：</h2><ul>
<li>Fragment可以使你能够将activity分离成多个可重用的组件，每个都有它自己的生命周期和UI。</li>
<li>Fragment可以轻松得创建动态灵活的UI设计，可以适应于不同的屏幕尺寸。从手机到平板电脑。</li>
<li>Fragment是一个独立的模块，紧紧地与activity绑定在一起。可以运行中动态地移除、加入、交换等。</li>
<li>Fragment提供一个新的方式让你在不同的安卓设备上统一你的UI。</li>
<li>Fragment解决Activity间的切换不流畅，轻量切换。</li>
<li>Fragment替代TabActivity做导航，性能更好。</li>
<li>Fragment在Android 4.2中新增嵌套fragment使用方法，能够生成更好的界面效果。</li>
</ul>
<h2 id="13-Intent的原理，作用，可以传递哪些类型的参数？"><a href="#13-Intent的原理，作用，可以传递哪些类型的参数？" class="headerlink" title="13. Intent的原理，作用，可以传递哪些类型的参数？"></a>13. Intent的原理，作用，可以传递哪些类型的参数？</h2><ul>
<li>Intent是连接Activity、Service、BroadcastReceiver和ContentProvider四大组件的信使，可以传递八种基本数据类型以及<code>String</code>、<code>Bundle</code>类型，以及实现了<code>Serializable</code>或者<code>Parcelable</code>的类型。</li>
<li><p>Intent可以划分成显式意图和隐式意图。</p>
<ul>
<li>显式意图：调用<code>Intent.setComponent()</code>或<code>Intent.setClass()</code>方法明确指定了组件名的Intent为显式意图，显式意图明确指定了Intent应该传递给哪个组件。</li>
<li>隐式意图：没有明确指定组件名的Intent为隐式意图。Android系统会根据隐式意图中设置的动作（<code>action</code>）、类别（<code>category</code>）、数据（URI和数据类型）找到最合适的组件来处理这个意图。</li>
</ul>
</li>
</ul>
<h2 id="14-Intent的主要使用方法"><a href="#14-Intent的主要使用方法" class="headerlink" title="14. Intent的主要使用方法"></a>14. Intent的主要使用方法</h2><h3 id="14-1-启动-Activity"><a href="#14-1-启动-Activity" class="headerlink" title="14.1. 启动 Activity"></a>14.1. 启动 Activity</h3><p>Activity表示应用中的一个屏幕。通过将Intent传递给<code>startActivity()</code>，您可以启动新的 Activity实例。Intent描述了要启动的Activity，并携带了任何必要的数据。</p>
<p>如果您希望在Activity完成后收到结果，请调用<code>startActivityForResult()</code>。在 Activity的<code>onActivityResult()</code>回调中，您的Activity将结果作为单独的Intent对象接收。</p>
<h3 id="14-2-启动服务"><a href="#14-2-启动服务" class="headerlink" title="14.2. 启动服务"></a>14.2. 启动服务</h3><p>Service是一个不使用用户界面而在后台执行操作的组件。通过将Intent传递给<code>startService()</code>，您可以启动服务执行一次性操作（例如，下载文件）。Intent描述了要启动的服务，并携带了任何必要的数据。</p>
<p>如果服务旨在使用客户端——服务器接口，则通过将Intent传递给<code>bindService(</code>)，您可以从其他组件绑定到此服务。</p>
<h3 id="14-3-传递广播"><a href="#14-3-传递广播" class="headerlink" title="14.3. 传递广播"></a>14.3. 传递广播</h3><p>广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将Intent传递给<code>sendBroadcast()</code>、<code>sendOrderedBroadcast()</code>或<code>sendStickyBroadcast()</code>，您可以将广播传递给其他应用。</p>
<h2 id="15-Intent包含哪些信息"><a href="#15-Intent包含哪些信息" class="headerlink" title="15. Intent包含哪些信息"></a>15. Intent包含哪些信息</h2><ul>
<li>组件名称：要启动的组件名称。</li>
<li>操作：指定要执行的通用操作（例如，“查看”或“选取”）的字符串。</li>
<li>数据：引用待操作数据和／或该数据MIME类型的URI（Uri对象）。提供的数据类型通常由Intent的操作决定。例如，如果操作是<code>ACTION_EDIT</code>，则数据应包含待编辑文档的URI。</li>
<li>类别：一个包含应处理Intent组件类型的附加信息的字符串。</li>
<li>Extra：携带完成请求操作所需的附加信息的键值对。</li>
<li>标志：在Intent类中定义的、充当Intent元数据的标志。</li>
</ul>
<h2 id="16-什么是Intent过滤器"><a href="#16-什么是Intent过滤器" class="headerlink" title="16. 什么是Intent过滤器"></a>16. 什么是Intent过滤器</h2><p>要公布应用可以接收哪些隐式Intent，请在清单文件中使用<code>&lt;intent-filter&gt;</code>元素为每个应用组件声明一个或多个Intent过滤器。每个Intent过滤器均由应用清单文件中的<code>&lt;intent-filter&gt;</code>元素定义，并嵌套在相应的应用组件（例如，<code>&lt;activity&gt;</code>元素）中。在<code>&lt;intent-filter&gt;</code>内部，您可以使用以下三个元素中的一个或多个指定要接受的Intent类型：</p>
<ul>
<li><code>&lt;action&gt;</code>：在<code>name</code>属性中，声明接受的Intent操作。该值必须是操作的文本字符串值，而不是类常量。</li>
<li><code>&lt;data&gt;</code>：使用一个或多个指定数据URI各个方面（scheme、host、port、path等）和MIME类型的属性，声明接受的数据类型。</li>
<li><code>&lt;category&gt;</code>：在<code>name</code>属性中，声明接受的Intent类别。该值必须是操作的文本字符串值，而不是类常量。</li>
</ul>
<h2 id="17-Service的启动方式"><a href="#17-Service的启动方式" class="headerlink" title="17. Service的启动方式"></a>17. Service的启动方式</h2><ul>
<li><code>startService()</code>：只是启动Service，Activity和Service并没有绑定，只有当Service调用<code>stopService()</code>服务才会终止。</li>
<li><code>bindService()</code>：这种启动方式Activity和Service进行了绑定，启动Service的组件可以通过回调获取Service的代理对象和Service交互；当启动方销毁时，Service也会自动进行<code>unBind()</code>操作，当发现所有绑定都进行了<code>unBind()</code>时才会销毁Service。</li>
</ul>
<h2 id="18-Service的生命周期"><a href="#18-Service的生命周期" class="headerlink" title="18. Service的生命周期"></a>18. Service的生命周期</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/service_lifecycle.png" alt="service lifecycle"></p>
<h2 id="19-Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？"><a href="#19-Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？" class="headerlink" title="19. Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？"></a>19. Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？</h2><ul>
<li>Activity通过<code>bindService(Intent service，ServiceConnection conn，int flags)</code>跟Service进行绑定，当绑定成功的时候Service会将代理对象通过回调的形式传给<code>conn</code>，这样我们就拿到了Service提供的服务代理对象。</li>
<li>在Activity中可以通过<code>startService()</code>和<code>bindService()</code>方法启动Service。一般情况下如果想获取Service的服务对象那么肯定需要通过<code>bindService()</code>方法，比如音乐播放器，第三方支付等。如果仅仅只是为了开启一个后台任务那么可以使用<code>startService()</code>方法。</li>
</ul>
<h2 id="20-允许绑定的已启动服务的生命周期"><a href="#20-允许绑定的已启动服务的生命周期" class="headerlink" title="20. 允许绑定的已启动服务的生命周期"></a>20. 允许绑定的已启动服务的生命周期</h2><p>当服务与所有客户端之间的绑定全部取消时，Android系统便会销毁服务。不过，如果您选择实现<code>onStartCommand()</code>回调方法，则您必须显式停止服务，因为系统现在已将服务视为已启动。在此情况下，服务将一直运行到其通过<code>stopSelf()</code>自行停止，或其他组件调用<code>stopService()</code>为止，无论其是否绑定到任何客户端。</p>
<p>此外，如果您的服务已启动并接受绑定，则当系统调用您的<code>onUnbind()</code>方法时，如果您想在客户端下一次绑定到服务时接收<code>onRebind()</code>调用，则可选择返回true。<code>onRebind()</code>返回空值，但客户端仍在其<code>onServiceConnected()</code>回调中接收IBinder。</p>
<p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/service_binding_tree_lifecycle.png" alt="service binding tree lifecycle"></p>
<h2 id="21-Service中可以弹Toast吗？"><a href="#21-Service中可以弹Toast吗？" class="headerlink" title="21. Service中可以弹Toast吗？"></a>21. Service中可以弹Toast吗？</h2><ul>
<li>这个问题其实就是问一下Service是执行在UI线程中吗？类似的问题还有”Service的<code>onCreate()</code>回调函数可以做耗时的操作吗？”，”Service是否在main thread中执行”，”Service和Activity在同一个线程吗？”等；</li>
<li>我们要牢记一句真理”默认情况下四大组件都是在UI线程中执行的”，Service本身就是Context的子类，我们可以获取到Context对象，所以Service中当然可以弹Toast，同理，Service的<code>onCreate()</code>回调函数不可以做耗时的操作。</li>
</ul>
<h2 id="22-进程的优先级"><a href="#22-进程的优先级" class="headerlink" title="22. 进程的优先级"></a>22. 进程的优先级</h2><h3 id="22-1-前台进程"><a href="#22-1-前台进程" class="headerlink" title="22.1. 前台进程"></a>22.1. 前台进程</h3><p>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</p>
<ul>
<li>托管用户正在交互的Activity（已调用Activity的<code>onResume()</code>方法）；</li>
<li>托管某个Service，后者绑定到用户正在交互的Activity；</li>
<li>托管正在”前台”运行的Service（服务已调用<code>startForeground()</code>）；</li>
<li>托管正执行一个生命周期回调的Service（<code>onCreate()</code>、<code>onStart()</code>或<code>onDestroy()</code>）；</li>
<li>托管正执行其<code>onReceive()</code>方法的BroadcastReceiver。</li>
</ul>
<p>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</p>
<h3 id="22-2-可视进程"><a href="#22-2-可视进程" class="headerlink" title="22.2. 可视进程"></a>22.2. 可视进程</h3><p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。如果一个进程满足以下任一条件，即视为可见进程：</p>
<ul>
<li>托管不在前台、但仍对用户可见的Activity（已调用其<code>onPause()</code>方法）。例如，如果前台Activity启动了一个对话框，允许在其后显示上一Activity，则有可能会发生这种情况。</li>
<li>托管绑定到可见（或前台）Activity的Service。</li>
</ul>
<p>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p>
<h3 id="22-3-服务进程"><a href="#22-3-服务进程" class="headerlink" title="22.3. 服务进程"></a>22.3. 服务进程</h3><p>正在运行已使用<code>startService()</code>方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p>
<h3 id="22-4-后台进程"><a href="#22-4-后台进程" class="headerlink" title="22.4. 后台进程"></a>22.4. 后台进程</h3><p>包含目前对用户不可见的Activity的进程（已调用Activity的<code>onStop()</code>方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。通常会有很多后台进程在运行，因此它们会保存在LRU（最近最少使用）列表中，以确保包含用户最近查看的Activity的进程最后一个被终止。如果某个Activity正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该Activity时，Activity会恢复其所有可见状态。</p>
<h3 id="22-5-空进程"><a href="#22-5-空进程" class="headerlink" title="22.5. 空进程"></a>22.5. 空进程</h3><p>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p>
<h2 id="23-IntentService如何工作？"><a href="#23-IntentService如何工作？" class="headerlink" title="23. IntentService如何工作？"></a>23. IntentService如何工作？</h2><ul>
<li>创建默认的工作线程，用于在应用的主线程外执行传递给<code>onStartCommand()</code>的所有Intent。</li>
<li>创建工作队列，用于将Intent逐一传递给<code>onHandleIntent()</code>实现，这样您就永远不必担心多线程问题。</li>
<li>在处理完所有启动请求后停止服务，因此您永远不必调用<code>stopSelf()</code>。</li>
<li>提供<code>onBind()</code>的默认实现（返回<code>null</code>）。</li>
<li>提供<code>onStartCommand()</code>的默认实现，可将Intent依次发送到工作队列和<code>onHandleIntent()</code>实现。</li>
</ul>
<h2 id="24-IntentService与Service的区别？"><a href="#24-IntentService与Service的区别？" class="headerlink" title="24. IntentService与Service的区别？"></a>24. IntentService与Service的区别？</h2><ul>
<li>Service也不是专门一条新线程，因此不应该在Service中直接处理耗时的任务；</li>
<li>Service不会专门启动一条单独的进程，Service与它所在应用位于同一个进程中；</li>
<li>IntentService是Service的子类，是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题；</li>
<li>IntentService会创建独立的worker线程来处理所有的Intent请求；</li>
<li>IntentService不会阻塞UI线程，而普通Serveice会导致ANR异常；</li>
<li>Intentservice若未执行完成上一次的任务，将不会新开一个线程，是等待之前的任务完成后，再执行新的任务，等任务完成后再次调用<code>stopSelf()</code>；</li>
<li>正在运行的IntentService的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。</li>
</ul>
<h2 id="25-Android-Service与Activity之间的通信方式？"><a href="#25-Android-Service与Activity之间的通信方式？" class="headerlink" title="25. Android Service与Activity之间的通信方式？"></a>25. Android Service与Activity之间的通信方式？</h2><ul>
<li><p>通过Binder对象：当Activity通过调用<code>bindService(Intent service，ServiceConnection conn，int flags)</code>，得到一个Service的一个对象，通过这个对象我们可以直接访问Service中的方法。</p>
<ul>
<li>添加一个继承Binder的内部类，并添加相应的逻辑方法。</li>
<li>重写Service的<code>onBind()</code>方法，返回我们刚刚定义的那个内部类实。</li>
<li>Activity中创建一个ServiceConnection的匿名内部类，并且重写里面的<code>onServiceConnected()</code>方法和<code>onServiceDisconnected()</code>方法，这两个方法分别会在活动与服务成功绑定以及解除绑定的时候调用，在<code>onServiceConnected()</code>方法中，我们可以得到一个刚才那个service的binder对象，通过对这个binder对象进行向下转型，得到我们那个自定义的Binder实例，有了这个实例，做可以调用这个实例里面的具体方法进行需要的操作了。</li>
</ul>
</li>
<li><p>通过Broadcast Receiver：当我们的进度发生变化的时候我们发送一条广播，然后在Activity的注册广播接收器，接收到广播之后更新视图</p>
</li>
<li><p>EventBus</p>
</li>
</ul>
<h2 id="26-BroadcastReceiver简介"><a href="#26-BroadcastReceiver简介" class="headerlink" title="26. BroadcastReceiver简介"></a>26. BroadcastReceiver简介</h2><p>在Android中，Broadcast是一种广泛运用的在应用程序之间传输信息的机制。</p>
<h3 id="26-1-用途"><a href="#26-1-用途" class="headerlink" title="26.1. 用途"></a>26.1. 用途</h3><ul>
<li>实现了不同的程序之间的数据传输与共享，因为只要是和发送广播的<code>action</code>相同的接受者都能接受这个广播。典型的应用就是Android自带的短信，电话等等广播，只要我们实现了他们的<code>action</code>的广播，那么我们就能接收他们的数据了，以便做出一些处理。比如说拦截系统短信，拦截骚扰电话等。</li>
<li>起到了一个通知的作用，比如在Service中要通知主程序，更新主程序的UI等。因为Service是没有界面的，所以不能直接获得主程序中的控件，这样我们就只能在主程序中实现一个广播接受者专门用来接受Service发过来的数据和通知了。</li>
</ul>
<h3 id="26-2-使用场景"><a href="#26-2-使用场景" class="headerlink" title="26.2. 使用场景"></a>26.2. 使用场景</h3><ul>
<li>同一app内部的同一组件内的消息通信（单个或多个线程之间）；</li>
<li>同一app内部的不同组件之间的消息通信（单个进程）；</li>
<li>同一app具有多个进程的不同组件之间的消息通信；</li>
<li>不同app之间的组件之间消息通信；</li>
<li>Android系统在特定情况下与App之间的消息通信。</li>
</ul>
<h3 id="26-3-实现原理"><a href="#26-3-实现原理" class="headerlink" title="26.3. 实现原理"></a>26.3. 实现原理</h3><p>从实现原理看上，Android中的广播使用了观察者模式，基于消息的发布/订阅事件模型。因此，从实现的角度来看，Android中的广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。具体实现流程要点粗略概括如下：</p>
<ol>
<li>广播接收者BroadcastReceiver通过Binder机制向AMS（Activity Manager Service)进行注册；</li>
<li>广播发送者通过binder机制向AMS发送广播；</li>
<li>AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；</li>
<li>消息循环执行拿到此广播，回调BroadcastReceiver中的<code>onReceive()</code>方法。</li>
</ol>
<h3 id="26-4-注册方式"><a href="#26-4-注册方式" class="headerlink" title="26.4. 注册方式"></a>26.4. 注册方式</h3><ul>
<li>静态注册；</li>
<li>动态注册。</li>
</ul>
<h2 id="27-为什么要用ContentProvider？它和SQL的实现上有什么差别？"><a href="#27-为什么要用ContentProvider？它和SQL的实现上有什么差别？" class="headerlink" title="27. 为什么要用ContentProvider？它和SQL的实现上有什么差别？"></a>27. 为什么要用ContentProvider？它和SQL的实现上有什么差别？</h2><ul>
<li>ContentProvider屏蔽了数据存储的细节，内部实现对用户完全透明，用户只需要关心操作数据的uri就可以了，ContentProvider可以实现不同app之间共享。SQL只能在该工程的内部共享数据，ContentProvider能在工程之间实现数据共享。</li>
<li>SQL也有增删改查的方法，但是SQL只能查询本应用下的数据库。而ContentProvider还可以去增删改查本地文件.xml文件的读取等。</li>
</ul>
<h2 id="28-ContentProvider怎么实现数据共享？"><a href="#28-ContentProvider怎么实现数据共享？" class="headerlink" title="28. ContentProvider怎么实现数据共享？"></a>28. ContentProvider怎么实现数据共享？</h2><p>一个程序可以通过实现一个ContentProvider的抽象接口将自己的数据完全暴露出去，而且ContentProvider是以类似数据库中表的方式将数据暴露。ContentProvider存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的ContentProvider中，前提是有相同数据类型并且有写入ContentProvider的权限。</p>
<h2 id="29-Android如何访问自定义ContentProvider"><a href="#29-Android如何访问自定义ContentProvider" class="headerlink" title="29. Android如何访问自定义ContentProvider"></a>29. Android如何访问自定义ContentProvider</h2><ol>
<li>得到ContentResolver类对象：<code>ContentResolver cr = getContentResolver()</code>；</li>
<li>定义要查询的字段<code>String</code>数组；</li>
<li>使用<code>cr.query()</code>返回一个<code>Cursor</code>对象；</li>
<li>使用<code>while</code>循环得到<code>Cursor</code>里面的内容。</li>
</ol>
<h2 id="30-Android中Activity，Intent，Content-Provider，Service各有什么区别。"><a href="#30-Android中Activity，Intent，Content-Provider，Service各有什么区别。" class="headerlink" title="30. Android中Activity，Intent，Content Provider，Service各有什么区别。"></a>30. Android中Activity，Intent，Content Provider，Service各有什么区别。</h2><ul>
<li>Activity：活动，是最基本的Android应用程序组件。一个活动就是一个单独的屏幕，每一个活动都被实现为一个独立的类，并且从活动基类继承而来。</li>
<li>Intent：意图，描述应用想干什么。最重要的部分是动作和动作对应的数据。</li>
<li>Content Provider：内容提供器，Android应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当你想将你的应用数据和其他应用共享时，内容提供器就可以发挥作用了。</li>
<li>Service：服务，具有一段较长生命周期且没有用户界面的程序。</li>
</ul>
<h2 id="31-Android数据存储方式？"><a href="#31-Android数据存储方式？" class="headerlink" title="31. Android数据存储方式？"></a>31. Android数据存储方式？</h2><ul>
<li>SharedPreferences：以键值对的形式保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。</li>
<li>文件存储数据：Context提供了两个方法来打开数据文件里的文件IO流<code>FileInputStream openFileInput(String name)</code>，<code>FileOutputStream(String name，int mode)</code>，这两个方法第一个参数用于指定文件名，第二个参数指定打开文件的模式；文件默认存储位置：<code>/data/data/包名/files/文件名</code>。</li>
<li>SQLite存储数据。</li>
<li>使用ContentProvider存储数据。</li>
<li>网络存储数据。</li>
</ul>
<h2 id="32-Android中常用的布局都有哪些？"><a href="#32-Android中常用的布局都有哪些？" class="headerlink" title="32. Android中常用的布局都有哪些？"></a>32. Android中常用的布局都有哪些？</h2><ul>
<li>FrameLayout；</li>
<li>RelativeLayout；</li>
<li>LinearLayout；</li>
<li>AbsoluteLayout；</li>
<li>TableLayout；</li>
<li>GridLayout。</li>
</ul>
<h2 id="33-android-layout-gravity和android-gravity的区别？"><a href="#33-android-layout-gravity和android-gravity的区别？" class="headerlink" title="33. android:layout_gravity和android:gravity的区别？"></a>33. <code>android:layout_gravity</code>和<code>android:gravity</code>的区别？</h2><ul>
<li><code>android:layout_gravity</code>是让该布局在其父控件中的布局方式。</li>
<li><code>android:gravity</code>是该布局布置其子对象的布局方式。</li>
</ul>
<h2 id="34-Android平台架构"><a href="#34-Android平台架构" class="headerlink" title="34. Android平台架构"></a>34. Android平台架构</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/android_platform.png" alt="android platform"></p>
<h3 id="34-1-系统应用"><a href="#34-1-系统应用" class="headerlink" title="34.1. 系统应用"></a>34.1. 系统应用</h3><p>Android随附一套用于电子邮件、短信、日历、互联网浏览和联系人等的核心应用。平台随附的应用与用户可以选择安装的应用一样，没有特殊状态。因此第三方应用可成为用户的默认网络浏览器、短信Messenger甚至默认键盘（有一些例外，例如系统的”设置”应用）。</p>
<p>系统应用可用作用户的应用，以及提供开发者可从其自己的应用访问的主要功能。例如，如果您的应用要发短信，您无需自己构建该功能，可以改为调用已安装的短信应用向您指定的接收者发送消息。</p>
<h3 id="34-2-Java-API框架"><a href="#34-2-Java-API框架" class="headerlink" title="34.2. Java API框架"></a>34.2. Java API框架</h3><p>您可通过以Java语言编写的API使用Android OS的整个功能集。这些API形成创建Android应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务：</p>
<ul>
<li>丰富、可扩展的视图系统，可用以构建应用的UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器；</li>
<li>资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件；</li>
<li>通知管理器，可让所有应用在状态栏中显示自定义提醒；</li>
<li>Activity管理器，用于管理应用的生命周期，提供常见的导航返回栈；</li>
<li>内容提供程序，可让应用访问其他应用（例如”联系人”应用）中的数据或者共享其自己的数据。</li>
</ul>
<p>开发者可以完全访问Android系统应用使用的框架API。</p>
<h3 id="34-3-原生C-C-库"><a href="#34-3-原生C-C-库" class="headerlink" title="34.3. 原生C/C++库"></a>34.3. 原生C/C++库</h3><p>许多核心Android系统组件和服务（例如ART和HAL）构建自原生代码，需要以C和C++编写的原生库。Android平台提供Java框架API以向应用显示其中部分原生库的功能。例如，您可以通过Android框架的Java OpenGL API访问OpenGL ES，以支持在应用中绘制和操作2D和3D图形。</p>
<p>如果开发的是需要C或C++代码的应用，可以使用Android NDK直接从原生代码访问某些原生平台库。</p>
<h3 id="34-4-Android-Runtime"><a href="#34-4-Android-Runtime" class="headerlink" title="34.4. Android Runtime"></a>34.4. Android Runtime</h3><p>对于运行Android 5.0（API级别21）或更高版本的设备，每个应用都在其自己的进程中运行，并且有其自己的Android Runtime(ART)实例。ART编写为通过执行DEX文件在低内存设备上运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如Jack）将Java源代码编译为DEX字节码，使其可在Android平台上运行。</p>
<p>ART的部分主要功能包括：</p>
<ul>
<li>预先（AOT）和即时（JIT）编译；</li>
<li>优化的垃圾回收（GC）；</li>
<li>更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置监视点以监控特定字段；</li>
</ul>
<p>在Android版本5.0（API级别21）之前，Dalvik是Android Runtime。如果您的应用在ART上运行效果很好，那么它应该也可在Dalvik上运行，但反过来不一定。</p>
<p>Android还包含一套核心运行时库，可提供Java API框架使用的Java编程语言大部分功能，包括一些Java 8语言功能。</p>
<h3 id="34-5-硬件抽象层（HAL）"><a href="#34-5-硬件抽象层（HAL）" class="headerlink" title="34.5. 硬件抽象层（HAL）"></a>34.5. 硬件抽象层（HAL）</h3><p>硬件抽象层（HAL）提供标准界面，向更高级别的Java API框架显示设备硬件功能。HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当框架API要求访问设备硬件时，Android系统将为该硬件组件加载库模块。</p>
<h3 id="34-6-Linux-内核"><a href="#34-6-Linux-内核" class="headerlink" title="34.6. Linux 内核"></a>34.6. Linux 内核</h3><p>Android平台的基础是Linux内核。例如，Android Runtime（ART）依靠Linux内核来执行底层功能，例如线程和低层内存管理。</p>
<p>使用Linux内核可让Android利用主要安全功能，并且允许设备制造商为著名的内核开发硬件驱动程序。</p>
<h2 id="35-Fragment生命周期"><a href="#35-Fragment生命周期" class="headerlink" title="35. Fragment生命周期"></a>35. Fragment生命周期</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/fragment_lifecycle.png" alt="fragment lifecycle"></p>
<ul>
<li><code>onCreate()</code>：系统会在创建片段时调用此方法。您应该在实现内初始化您想在片段暂停或停止后恢复时保留的必需片段组件。</li>
<li><code>onCreateView()</code>：系统会在片段首次绘制其用户界面时调用此方法。要想为您的片段绘制UI，您从此方法中返回的View必须是片段布局的根视图。如果片段未提供UI，您可以返回<code>null</code>。</li>
<li><code>onPause()</code>：系统将此方法作为用户离开片段的第一个信号（但并不总是意味着此片段会被销毁）进行调用。您通常应该在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。</li>
</ul>
<h2 id="36-Activity生命周期对片段生命周期的影响"><a href="#36-Activity生命周期对片段生命周期的影响" class="headerlink" title="36. Activity生命周期对片段生命周期的影响"></a>36. Activity生命周期对片段生命周期的影响</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/activity_fragment_lifecycle.png" alt="activity fragment lifecycle"></p>
<p>片段所在的Activity的生命周期会直接影响片段的生命周期，其表现为，Activity的每次生命周期回调都会引发每个片段的类似回调。例如，当Activity收到<code>onPause()</code>时，Activity中的每个片段也会收到<code>onPause()</code>。</p>
<p>不过，片段还有几个额外的生命周期回调，用于处理与Activity的唯一交互，以执行构建和销毁片段UI等操作。这些额外的回调方法是：</p>
<ul>
<li><code>onAttach()</code>：在片段已与Activity关联时调用（Activity传递到此方法内）；</li>
<li><code>onCreateView()</code>：调用它可创建与片段关联的视图层次结构；</li>
<li><code>onActivityCreated()</code>：在Activity的<code>onCreate()</code>方法已返回时调用；</li>
<li><code>onDestroyView()</code>：在移除与片段关联的视图层次结构时调用；</li>
<li><code>onDetach()</code>：在取消片段与Activity的关联时调用。</li>
</ul>
<h2 id="37-Android事件分发"><a href="#37-Android事件分发" class="headerlink" title="37. Android事件分发"></a>37. Android事件分发</h2><table>
<thead>
<tr>
<th style="text-align:center">事件相关方法</th>
<th style="text-align:center">方法功能</th>
<th style="text-align:center">Activity</th>
<th style="text-align:center">ViewGroup</th>
<th style="text-align:center">View</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>dispatchTouchEvent</code></td>
<td style="text-align:center">事件分发</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
<tr>
<td style="text-align:center"><code>onInterceptTouchEvent</code></td>
<td style="text-align:center">事件拦截</td>
<td style="text-align:center">No</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center"><code>onTouchEvent</code></td>
<td style="text-align:center">事件消费</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
</tr>
</tbody>
</table>
<h3 id="37-1-public-boolean-dispatchTouchEvent-MotionEvent-ev"><a href="#37-1-public-boolean-dispatchTouchEvent-MotionEvent-ev" class="headerlink" title="37.1. public boolean dispatchTouchEvent(MotionEvent ev)"></a>37.1. <code>public boolean dispatchTouchEvent(MotionEvent ev)</code></h3><p>当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的<code>dispatchTouchEvent(MotionEvent ev)</code>方法，该方法对事件进行分发。</p>
<ul>
<li><code>return true</code>：表示该View内部消化掉了所有事件。</li>
<li><code>return false</code>：事件在本层不再继续进行分发，并交由上层控件的<code>onTouchEvent()</code>方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。</li>
<li>如果事件分发返回系统默认的<code>super.dispatchTouchEvent(ev)</code>，事件将分发给本层的事件拦截<code>onInterceptTouchEvent()</code>方法进行处理。</li>
</ul>
<h3 id="37-2-public-boolean-onInterceptTouchEvent-MotionEvent-ev"><a href="#37-2-public-boolean-onInterceptTouchEvent-MotionEvent-ev" class="headerlink" title="37.2. public boolean onInterceptTouchEvent(MotionEvent ev)"></a>37.2. <code>public boolean onInterceptTouchEvent(MotionEvent ev)</code></h3><ul>
<li><code>return true</code>：表示将事件进行拦截，并将拦截到的事件交由本层控件的<code>onTouchEvent()</code>进行处理。</li>
<li><code>return false</code>：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的<code>dispatchTouchEvent()</code>进行处理。</li>
<li>如果返回<code>super.onInterceptTouchEvent(ev)</code>，默认表示拦截该事件，并将事件传递给当前View的<code>onTouchEvent()</code>方法，和<code>return true</code>一样。</li>
</ul>
<h3 id="37-3-public-boolean-onTouchEvent-MotionEvent-ev"><a href="#37-3-public-boolean-onTouchEvent-MotionEvent-ev" class="headerlink" title="37.3. public boolean onTouchEvent(MotionEvent ev)"></a>37.3. <code>public boolean onTouchEvent(MotionEvent ev)</code></h3><p>在<code>dispatchTouchEvent()</code>（事件分发）返回<code>super.dispatchTouchEvent(ev)</code>并且<code>onInterceptTouchEvent()</code>（事件拦截返回<code>true</code>或<code>super.onInterceptTouchEvent(ev)</code>的情况下，那么事件会传递到<code>onTouchEvent()</code>方法，该方法对事件进行响应。</p>
<ul>
<li>如果<code>return true</code>，表示<code>onTouchEvent()</code>处理完事件后消费了此次事件。此时事件终结。</li>
<li>如果<code>return fasle</code>，则表示不响应事件，那么该事件将会不断向上层View的<code>onTouchEvent()</code>方法传递，直到某个View的<code>onTouchEvent()</code>方法返回<code>true</code>，如果到了最顶层View还是返回<code>false</code>，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的<code>onTouchEvent()</code>进行处理。</li>
<li>如果<code>return super.dispatchTouchEvent(ev)</code>，则表示不响应事件，结果与<code>return false</code>一样。</li>
</ul>
<p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/touch_eventbus.gif" alt="touch eventbus"></p>
<ul>
<li>如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的<code>onTouchEvent()</code>不会被触发。</li>
<li>可以通过复写<code>onInterceptTouchEvent(ev)</code>方法，拦截子View的事件（即<code>return true</code>），把事件交给自己处理，则会执行自己对应的<code>onTouchEvent()</code>方法。</li>
<li>子View可以通过调用<code>getParent().requestDisallowInterceptTouchEvent(true)</code>阻止ViewGroup对其<code>MOVE</code>或者<code>UP</code>事件进行拦截。</li>
<li>一个点击事件产生后，它的传递过程如下：Activity-&gt;Window-&gt;View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的<code>onTouchEvent()</code>方法返回<code>false</code>，那么将会交给父容器的<code>onTouchEvent()</code>方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的<code>onTouchEvent()</code>进行处理。</li>
<li>如果某一个View开始处理事件，如果他不消耗<code>ACTION_DOWN</code>事件（也就是<code>onTouchEvent()</code>返回<code>false</code>），则同一事件序列比如接下来进行<code>ACTION_MOVE</code>，则不会再交给该View处理。</li>
<li>ViewGroup默认不拦截任何事件。</li>
<li>诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用<code>onTouchEvent()</code>方法，它们本身没有<code>onInterceptTouchEvent()</code>方法。正常情况下，它们都会消耗事件（返回<code>true</code>），除非它们是不可点击的（<code>clickable</code>和<code>longClickable</code>都为<code>false</code>），那么就会交由父容器的<code>onTouchEvent()</code>处理。</li>
<li>点击事件分发过程如下<code>dispatchTouchEvent()</code> —&gt; <code>OnTouchListener</code>的<code>onTouch()</code>方法 —&gt; <code>onTouchEvent()</code> –&gt; <code>OnClickListener</code>的<code>onClick()</code>方法。也就是说，我们平时调用的<code>setOnClickListener()</code>，优先级是最低的，所以，<code>onTouchEvent()</code>或<code>OnTouchListener()</code>的<code>onTouch()</code>方法如果返回<code>true</code>，则不响应<code>onClick()</code>方法。</li>
</ul>
<p>参考：<a href="https://github.com/Mr-YangCheng/ForAndroidInterview/blob/master/android/Android%20View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">ForAndroidInterview/Android View事件分发机制源码分析.md at master · Mr-YangCheng/ForAndroidInterview</a></p>
<p>参考：<a href="https://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html" target="_blank" rel="noopener">Android 编程下 Touch 事件的分发和消费机制 - sunzn - 博客园</a></p>
<h2 id="38-Android系统启动过程"><a href="#38-Android系统启动过程" class="headerlink" title="38. Android系统启动过程"></a>38. Android系统启动过程</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/android_boot_process.png" alt="android boot process"></p>
<h3 id="38-1-Boot-ROM"><a href="#38-1-Boot-ROM" class="headerlink" title="38.1. Boot ROM"></a>38.1. Boot ROM</h3><p>Android设备上电后，首先会从处理器片上ROM的启动引导代码开始执行，片上ROM会寻找Bootloader代码，并加载到内存。</p>
<h3 id="38-2-Boot-Loader"><a href="#38-2-Boot-Loader" class="headerlink" title="38.2. Boot Loader"></a>38.2. Boot Loader</h3><p>BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。</p>
<h3 id="38-3-Kernel"><a href="#38-3-Kernel" class="headerlink" title="38.3. Kernel"></a>38.3. Kernel</h3><p>Android内核启动时，会设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。</p>
<h3 id="38-4-init"><a href="#38-4-init" class="headerlink" title="38.4. init"></a>38.4. init</h3><p>init进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。init始终是第一个进程。</p>
<p>init程序最核心的工作主要有3点：</p>
<ul>
<li>创建和挂载一些系统目录/设备节点，设置权限，如：<code>/dev</code>，<code>/proc</code>，和<code>/sys</code>；</li>
<li>解析init.rc，并启动属性服务，以及一系列的服务和进程；</li>
<li>显示boot logo，默认是”Android”字样。</li>
</ul>
<p>第二步的这些服务包含2部分，一部分是本地服务，另一部分是Android服务，所有的这些服务都会向ServiceManager进程注册，由它统一管理，这些服务的启动过程介绍如下：</p>
<h4 id="38-4-1-本地服务"><a href="#38-4-1-本地服务" class="headerlink" title="38.4.1. 本地服务"></a>38.4.1. 本地服务</h4><p>本地服务是指运行在C++层的系统守护进程，一部分本地服务是init进程直接启动的，它们定义在init.rc脚本中，如ueventd、servicemanager、debuggerd、rild、mediaserver等。还有一部分本地服务，是由这些本地服务进一步创建的，如mediaserver服务会启动AudioFlinger，MediaPlayerService，以及CameraService等本地服务。</p>
<p>注意，每一个由init直接启动的本地服务都是一个独立的Linux进程，在系统启动以后，我们通过<code>adb shell</code>命令进入手机后，输入<code>top</code>命令就可以查看到这些本地进程的存在。</p>
<h4 id="38-4-2-Android服务"><a href="#38-4-2-Android服务" class="headerlink" title="38.4.2. Android服务"></a>38.4.2. Android服务</h4><p>init进程会执行app_process程序，创建Zygote进程，它是Android系统最重要的进程，所有后续的Android应用程序都是由它<code>fork</code>出来的。</p>
<p>Zygote进程会首先<code>fork</code>出SystemServer进程，SystemServer进程的全部任务就是将所有的Android核心服务启动起来。</p>
<h3 id="38-5-Zygote-and-Dalvik（ART）"><a href="#38-5-Zygote-and-Dalvik（ART）" class="headerlink" title="38.5. Zygote and Dalvik（ART）"></a>38.5. Zygote and Dalvik（ART）</h3><p>Zygote被init进程启动，开始运行和初始化dalvik虚拟机。</p>
<h3 id="38-6-System-Server"><a href="#38-6-System-Server" class="headerlink" title="38.6. System Server"></a>38.6. System Server</h3><p>系统服务是在系统中运行的第一个java组件，它会启动所有的Android服务，比如：电话服务，蓝牙服务，每个服务的启动被直接写在<code>SystemServer.java</code>这个类的<code>run()</code>方法里面。</p>
<h3 id="38-7-Boot-completed"><a href="#38-7-Boot-completed" class="headerlink" title="38.7. Boot completed"></a>38.7. Boot completed</h3><p>一旦系统服务启动并运行，Android系统启动就完成了，同时发出<code>ACTION_BOOT_COMPLETED</code>广播。</p>
<h2 id="39-Android应用启动过程"><a href="#39-Android应用启动过程" class="headerlink" title="39. Android应用启动过程"></a>39. Android应用启动过程</h2><ol>
<li>Launcher接收到点击事件，获取应用的信息，向SystemServer（ActivityManagerService简称AMS运行在里面）发起启动应用的请求；</li>
<li>SystemServer（AMS）请求Launcher Pause（Launcher需要保存状态进入后台）；</li>
<li>LauncherPause，向SystemServer（AMS）发送Pause完毕；</li>
<li>SystemServer（AMS）向Zygote请求启动一个新进程（calculator）；</li>
<li>Zygote fork出新进程（calculator），在新进程中执行ActivityThread类的<code>main()</code>方法；</li>
<li>calculator向SystemServer（AMS）请求attach到AMS；</li>
<li>SystemServer（AMS）请求calculator launch；</li>
<li>calculator调用<code>onCreate()</code>，<code>onResume()</code>回调；</li>
<li>calculator界面显示自屏幕上（还需细分）。</li>
</ol>
<p>参考：<a href="http://androidzhibinw.github.io/android/app/startup/activity/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/%E5%90%AF%E5%8A%A8/%E5%88%86%E6%9E%90/2015/09/21/android-app-startup-process/" target="_blank" rel="noopener">Android 应用程序启动过程分析</a></p>
<h2 id="40-dp，dip，dpi，ppi区别"><a href="#40-dp，dip，dpi，ppi区别" class="headerlink" title="40. dp，dip，dpi，ppi区别"></a>40. dp，dip，dpi，ppi区别</h2><p>px（Pixels，像素）：屏幕上的点。 in（Inch，英寸）：长度单位。 mm（Millimeter，毫米）：长度单位。 pt（Point，磅）：1/72in。 dpi（Dots Per Inch，每英寸所打印的点数）：1in长度的点数。 ppi（Pixels Per Inch，像素密度）：1in长度的像素点数。 dp/dip（Density-independent Pixels，与密度无关的像素）：一种基于屏幕密度的抽象单位。在160dpi的显示器上，1dp = 1px。 sp（Scale-independent Pixels，与刻度无关的像素）：与dp类似，但是可以根据用户的字体大小首选项进行缩放。</p>
<p>在屏幕密度为160dpi，1dp = 1px，1pt = 160/72sp，1pt = 1/72in。当屏幕密度为240dpi时，1dp = 1.5px。</p>
<p>参考：<a href="http://stackoverflow.com/questions/8478882/how-do-dp-dip-dpi-ppi-pixels-and-inches-relate" target="_blank" rel="noopener">mobile - How do dp, dip, dpi, ppi, pixels and inches relate? - Stack Overflow</a></p>
<h2 id="41-长度和字体的推荐单位"><a href="#41-长度和字体的推荐单位" class="headerlink" title="41. 长度和字体的推荐单位"></a>41. 长度和字体的推荐单位</h2><p>长度推荐dp（Density-independent Pixels），字号大小推荐sp（Scale-independent Pixels）。</p>
<h2 id="42-Android-View绘制流程"><a href="#42-Android-View绘制流程" class="headerlink" title="42. Android View绘制流程"></a>42. Android View绘制流程</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/android_draw_view_flow.png" alt="android_draw_view_flow"></p>
<p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/android_draw_view_chain.png" alt="android_draw_view_chain"></p>
<p>参考：<a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tech/viewdrawflow" target="_blank" rel="noopener">android-open-project-analysis/tech/viewdrawflow at master · android-cn/android-open-project-analysis</a></p>
<p>参考：<a href="http://vincgao.com/2016/02/android-layout/" target="_blank" rel="noopener">Android Layout绘制</a></p>
<h2 id="43-ListView优化"><a href="#43-ListView优化" class="headerlink" title="43. ListView优化"></a>43. ListView优化</h2><ul>
<li>复用convertView：用以避免重复创建View，重复创建View代价较大，而且如果重用view不改变宽高，重用View可以减少重新分配缓存造成的内存频繁分配/回收。</li>
<li>使用View Holder模式：findViewById的实现是遍历，如果你定义的View越复杂代价越大。 Google推荐的做法是用ViewHolder，然后保存在view的tag中。现在RecyclerView也是强制使用ViewHolder了。</li>
<li>分批加载与分页加载相结合：不需要一次等待好几分钟把数据都加载完再在ListView上显示。</li>
<li>使用异步线程加载图片</li>
<li>在快速滑动时不要加载图片</li>
<li>使用RecyclerView</li>
</ul>
<h2 id="44-Android-Binder机制"><a href="#44-Android-Binder机制" class="headerlink" title="44. Android Binder机制"></a>44. Android Binder机制</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/binder_architecture.jpg" alt="binder architecture"></p>
<p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/binder_architecture_2.jpg" alt="binder architecture 2"></p>
<ol>
<li>Server进程启动之后，会进入中断等待状态，等待Client的请求。</li>
<li>当Client需要和Server通信时，会将请求发送给Binder驱动。</li>
<li>Binder驱动收到请求之后，会唤醒Server进程。</li>
<li>接着，Binder驱动还会反馈信息给Client，告诉Client：它发送给Binder驱动的请求，Binder驱动已经收到。</li>
<li>Client将请求发送成功之后，就进入等待状态。等待Server的回复。</li>
<li>Binder驱动唤醒Server之后，就将请求转发给Server进程。</li>
<li>Server进程解析出请求内容，并将回复内容发送给Binder驱动。</li>
<li>Binder驱动收到回复之后，唤醒Client进程。</li>
<li>接着，Binder驱动还会反馈信息给Server，告诉Server：它发送给Binder驱动的回复，Binder驱动已经收到。</li>
<li>Server将回复发送成功之后，再次进入等待状态，等待Client的请求。</li>
<li>最后，Binder驱动将回复转发给Client。</li>
</ol>
<h2 id="45-Binder机制优点"><a href="#45-Binder机制优点" class="headerlink" title="45. Binder机制优点"></a>45. Binder机制优点</h2><ul>
<li>性能：Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。</li>
<li>稳定性：Binder是基于C/S架构的，Server端与Client端相对独立，稳定性较好。</li>
<li>安全性：传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份。Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行。</li>
</ul>
<h2 id="46-AsyncTask简介"><a href="#46-AsyncTask简介" class="headerlink" title="46. AsyncTask简介"></a>46. AsyncTask简介</h2><p>包含4个方法：</p>
<ul>
<li><code>onPreExecute()</code>：UI线程；</li>
<li><code>doInBackground(Params...)</code>：非UI线程；</li>
<li><code>onProgressUpdate(Progress...)</code>：UI线程；</li>
<li><code>onPostExecute(Result)</code>：UI线程。</li>
</ul>
<p>原理：</p>
<ul>
<li>线程池；</li>
<li>单例模式；</li>
<li><code>mainLooper()</code>；</li>
<li>串行。</li>
</ul>
<h2 id="47-为什么Handler需要声明为static？"><a href="#47-为什么Handler需要声明为static？" class="headerlink" title="47. 为什么Handler需要声明为static？"></a>47. 为什么Handler需要声明为static？</h2><p>所有发送到消息队列的消息Message都会拥有一个对Handler的引用，在java里，非静态内部类和匿名类都会潜在的引用它们所属的外部类。但是，静态内部类却不会。当Activity结束（finish）时，里面的延时消息在得到处理前，会一直保存在主线程的消息队列里持续10分钟。这条消息持有对handler的引用，而handler又持有对其外部类（在这里，即SampleActivity）的潜在引用。这条引用关系会一直保持直到消息得到处理，从而，这阻止了SampleActivity被垃圾回收器回收，同时造成应用程序的泄漏。</p>
<h2 id="48-广播注册后不解除注册会有什么问题？"><a href="#48-广播注册后不解除注册会有什么问题？" class="headerlink" title="48. 广播注册后不解除注册会有什么问题？"></a>48. 广播注册后不解除注册会有什么问题？</h2><p>内存泄漏。系统会保留Receiver的引用。</p>
<h2 id="49-自定义View"><a href="#49-自定义View" class="headerlink" title="49. 自定义View"></a>49. 自定义View</h2><h3 id="49-1-实现步骤"><a href="#49-1-实现步骤" class="headerlink" title="49.1. 实现步骤"></a>49.1. 实现步骤</h3><ol>
<li>继承View类或其子类；</li>
<li>复写view中的一些函数；</li>
<li>为自定义View类增加属性（两种方式）；</li>
<li>绘制控件（导入布局）；</li>
<li>响应用户事件；</li>
<li>定义回调函数（根据自己需求来选择）。</li>
</ol>
<h2 id="50-需要被重写的方法"><a href="#50-需要被重写的方法" class="headerlink" title="50. 需要被重写的方法"></a>50. 需要被重写的方法</h2><ul>
<li><code>onDraw()</code>：view中<code>onDraw()</code>是个空函数，也就是说具体的视图都要覆写该函数来实现自己的绘制。对于ViewGroup则不需要实现该函数，因为作为容器是”没有内容”的（但必须实现<code>dispatchDraw()</code>函数，告诉子view绘制自己）。</li>
<li><code>onLayout()</code>：主要是为viewGroup类型布局子视图用的，在View中这个函数为空函数。</li>
<li><code>onMeasure()</code>：用于计算视图大小（即长和宽）的方式，并通过<code>setMeasuredDimension(width, height)</code>保存计算结果。</li>
<li><code>onTouchEvent()</code>：定义触屏事件来响应用户操作。</li>
</ul>
<h2 id="51-Parcelable和Serializable的区别"><a href="#51-Parcelable和Serializable的区别" class="headerlink" title="51. Parcelable和Serializable的区别"></a>51. Parcelable和Serializable的区别</h2><p>Serializable仅需实现Serializable接口。缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。</p>
<p>Parcelable需要实现Parcelable接口，但序列化的过程已经提前确定，所以运行速度快。</p>
<h2 id="52-Android中的内存泄漏"><a href="#52-Android中的内存泄漏" class="headerlink" title="52. Android中的内存泄漏"></a>52. Android中的内存泄漏</h2><ol>
<li>查询数据库没有关闭游标。</li>
<li>构造Adapter时，没有使用缓存的convertView。</li>
<li>Bitmap对象不再使用时调用<code>recycle()</code>释放内存。</li>
<li>无用时没有释放对象的引用。</li>
<li>在Activity中使用非静态的内部类，并开启一个长时间运行的线程，因为内部类持有Activity的引用，会导致Activity本来可以被GC时却长期得不到回收。</li>
<li>使用Handler处理消息前，Activity通过例如<code>finish()</code>退出，导致内存泄漏。</li>
<li>动态注册广播在Activity销毁前没有<code>unregisterReceiver()</code>。</li>
</ol>
<h2 id="53-MVC和MVP的区别"><a href="#53-MVC和MVP的区别" class="headerlink" title="53. MVC和MVP的区别"></a>53. MVC和MVP的区别</h2><p>我们都知道MVP是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter（MVC中的Controller）来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过Controller。</p>
<h2 id="54-内存泄露检测有什么好方法？"><a href="#54-内存泄露检测有什么好方法？" class="headerlink" title="54. 内存泄露检测有什么好方法？"></a>54. 内存泄露检测有什么好方法？</h2><ol>
<li>DDMS Heap发现内存泄露dataObject totalSize的大小，是否稳定在一个范围内，如果操作程序，不断增加，说明内存泄露。</li>
<li>使用Heap Tool进行内存快照前后对比BlankActivity手动触发GC进行前后对比，对象是否被及时回收。</li>
</ol>
<h2 id="55-Android里面为什么要设计出Bundle而不是直接用Map结构"><a href="#55-Android里面为什么要设计出Bundle而不是直接用Map结构" class="headerlink" title="55. Android里面为什么要设计出Bundle而不是直接用Map结构"></a>55. Android里面为什么要设计出Bundle而不是直接用Map结构</h2><p>Map里实现了Serializable接口，而在Bundle实现了Parcelable的接口。</p>
<h2 id="56-在Android的MVP架构中，使用了什么设计模式"><a href="#56-在Android的MVP架构中，使用了什么设计模式" class="headerlink" title="56. 在Android的MVP架构中，使用了什么设计模式"></a>56. 在Android的MVP架构中，使用了什么设计模式</h2><ul>
<li>Observer模式：通过EventBus实现订阅者，发布者的功能，实现Model与Presenter的交互。</li>
<li>Proxy模式：View保持对Presenter的引用，通过Presenter代理，进行交互操作。</li>
</ul>
<h2 id="57-Android动画类型"><a href="#57-Android动画类型" class="headerlink" title="57. Android动画类型"></a>57. Android动画类型</h2><ul>
<li>属性动画（Property Animation）：是Android 3.0之后推出的，其机制不再是针对 View 来设计的，也不限于只能实现移动、缩放、旋转和淡入这几种简单的动画操作，同时也不再只是一种视觉上的动画效果。属性动画实际上是一种在一定时间段内不断修改某个对象的某个属性值的机制。</li>
<li><p>视图动画（View Animation）：</p>
<ul>
<li><p>补间动画（Tween animation）：是操作某一个控件让其展现出旋转、渐变、移动、缩放的一种转换过程。是一种视觉上的变化，不是真正位置上的变化。只能运用在 View 对象上，并且功能相对来说较为局限。例如：旋转动画只能够在x、y轴进行，而不能在z轴放心进行旋转。因此，补间动画通常用于执行一些比较简单的动画。</p>
<ul>
<li>渐变动画（AlphaAnimation）；</li>
<li>缩放动画（ScaleAnimation）；</li>
<li>位移动画（TranslateAnimation）；</li>
<li>旋转动画（RotateAnimation）。</li>
</ul>
</li>
<li><p>帧动画（Frame animation）：帧动画是一系列图片按照一定的顺序展示的过程，和放电影的机制相似，它的原理是在一定的时间段内切换多张有细微差异的图片从而达到动画的效果。由于是一帧一帧加载，所以需要较多的图片。从而增大 APK 的大小，不过 Frame 动画可以实现一些比较难的效果，例如：等待的环形进度。</p>
</li>
</ul>
</li>
</ul>
<h2 id="58-ANR和FC的区别"><a href="#58-ANR和FC的区别" class="headerlink" title="58. ANR和FC的区别"></a>58. ANR和FC的区别</h2><ul>
<li>ANR（Application Not Responding）：主线程阻塞。</li>
<li>FC（Forced Close）：内存耗尽，堆栈溢出，运行时错误等。</li>
</ul>
<h2 id="59-Android中的菜单"><a href="#59-Android中的菜单" class="headerlink" title="59. Android中的菜单"></a>59. Android中的菜单</h2><h3 id="59-1-选项菜单（Options-menu）"><a href="#59-1-选项菜单（Options-menu）" class="headerlink" title="59.1. 选项菜单（Options menu）"></a>59.1. 选项菜单（Options menu）</h3><p>在选项菜单中，您应当包括与当前Activity上下文相关的操作和其他选项，如”搜索”、”撰写电子邮件”和”设置”。</p>
<ul>
<li>要为Activity指定选项菜单，请重写<code>onCreateOptionsMenu()</code>。</li>
<li>此外，您还可以使用<code>add()</code>添加菜单项，并使用<code>findItem()</code>检索项目，以便使用MenuItem API修改其属性。</li>
<li>系统将在启动Activity时调用<code>onCreateOptionsMenu()</code>，以便向应用栏显示项目。</li>
<li>用户从选项菜单中选择项目时，系统将调用Activity的<code>onOptionsItemSelected()</code>方法。此方法将传递所选的MenuItem。您可以通过调用<code>getItemId()</code>方法来识别项目，该方法将返回菜单项的唯一ID。</li>
<li>系统调用<code>onCreateOptionsMenu()</code>后，将保留您填充的Menu实例。除非菜单由于某些原因而失效，否则不会再次调用<code>onCreateOptionsMenu()</code>。</li>
<li>如需根据在Activity生命周期中发生的事件修改选项菜单，则可通过<code>onPrepareOptionsMenu()</code>方法执行此操作。此方法向您传递Menu对象（因为该对象目前存在），以便您能够对其进行修改，如添加、移除或禁用项目。</li>
<li>当菜单项显示在应用栏中时，选项菜单被视为始终处于打开状态。 发生事件时，如果您要执行菜单更新，则必须调用<code>invalidateOptionsMenu()</code>来请求系统调用<code>onPrepareOptionsMenu()</code>。</li>
</ul>
<h3 id="59-2-上下文菜单（Contextual-Menus）"><a href="#59-2-上下文菜单（Contextual-Menus）" class="headerlink" title="59.2. 上下文菜单（Contextual Menus）"></a>59.2. 上下文菜单（Contextual Menus）</h3><h4 id="59-2-1-浮动上下文菜单（floating-context-menu）"><a href="#59-2-1-浮动上下文菜单（floating-context-menu）" class="headerlink" title="59.2.1. 浮动上下文菜单（floating context menu）"></a>59.2.1. 浮动上下文菜单（floating context menu）</h4><p>用户长按（按住）一个声明支持上下文菜单的视图时，菜单显示为菜单项的浮动列表（类似于对话框）。</p>
<ul>
<li>通过调用<code>registerForContextMenu()</code>，注册应与上下文菜单关联的View并将其传递给View。</li>
<li>在Activity或Fragment中实现<code>onCreateContextMenu()</code>方法。</li>
<li><p>实现<code>onContextItemSelected()</code>。</p>
<h4 id="上下文操作模式（contextual-action-mode）"><a href="#上下文操作模式（contextual-action-mode）" class="headerlink" title="上下文操作模式（contextual action mode）"></a>上下文操作模式（contextual action mode）</h4><p>上下文操作模式是 ActionMode 的一种系统实现，它将用户交互的重点转到执行上下文操作上。用户通过选择项目启用此模式时，屏幕顶部将出现一个”上下文操作栏”，显示用户可对当前所选项执行的操作。 启用此模式后，用户可以选择多个项目（若您允许）、取消选择项目以及继续在 Activity 内导航（在您允许的最大范围内）。</p>
</li>
<li><p>实现ActionMode.Callback接口。在其回调方法中，您既可以为上下文操作栏指定操作，又可以响应操作项目的点击事件，还可以处理操作模式的其他生命周期事件。</p>
</li>
<li><p>当需要显示操作栏时（例如，用户长按视图），请调用<code>startActionMode()</code>。</p>
</li>
</ul>
<h3 id="59-3-弹出菜单（Popup-Menu）"><a href="#59-3-弹出菜单（Popup-Menu）" class="headerlink" title="59.3. 弹出菜单（Popup Menu）"></a>59.3. 弹出菜单（Popup Menu）</h3><p>PopupMenu 是锚定到 View 的模态菜单。如果空间足够，它将显示在定位视图下方，否则显示在其上方。</p>
<ul>
<li>实例化PopupMenu及其构造函数，该函数将提取当前应用的Context以及菜单应锚定到的View。</li>
<li>使用MenuInflater将菜单资源扩充到<code>PopupMenu.getMenu()</code>返回的Menu对象中。</li>
<li>调用<code>PopupMenu.show()</code>。</li>
</ul>
<h2 id="60-BaseAdapter中需要重载的方法"><a href="#60-BaseAdapter中需要重载的方法" class="headerlink" title="60. BaseAdapter中需要重载的方法"></a>60. BaseAdapter中需要重载的方法</h2><p>最基本的：</p>
<ul>
<li><code>int getCount ()</code>：How many items are in the data set represented by this Adapter.</li>
<li><code>Object getItem (int position)</code>：Get the data item associated with the specified position in the data set.</li>
<li><code>long getItemId (int position)</code>：Get the row id associated with the specified position in the list.</li>
<li><code>View getView (int position, View convertView, ViewGroup parent)</code>：Get a View that displays the data at the specified position in the data set.</li>
</ul>
<p>如果有多种View：</p>
<ul>
<li><code>int getItemViewType (int position)</code>：Get the type of View that will be created by getView(int, View, ViewGroup) for the specified item.</li>
<li><code>int getViewTypeCount ()</code>：Returns the number of types of Views that will be created by getView(int, View, ViewGroup).</li>
</ul>
<h2 id="61-Android数字签名要点"><a href="#61-Android数字签名要点" class="headerlink" title="61. Android数字签名要点"></a>61. Android数字签名要点</h2><ul>
<li>所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序。</li>
<li>Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证。</li>
<li>如果要正式发布一个Android应用，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使调试证书来发布。</li>
<li>数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。</li>
</ul>
<h2 id="62-使用相同数字签名的原因"><a href="#62-使用相同数字签名的原因" class="headerlink" title="62. 使用相同数字签名的原因"></a>62. 使用相同数字签名的原因</h2><ul>
<li>应用升级：当系统安装应用的更新时，它会比较新版本和现有版本中的证书。如果证书匹配，则系统允许更新。如果您使用不同的证书签署新版本，则必须为应用分配另一个软件包名称—-在此情况下，用户将新版本作为全新应用安装。</li>
<li>应用模块化：Android允许通过相同证书签署的多个APK在同一个进程中运行（如果应用请求这样），以便系统将它们视为单个应用。通过此方式，您可以在模块中部署您的应用，且用户可以独立更新每个模块。</li>
<li>通过权限共享代码/数据：Android提供基于签名的权限执行，以便应用可以将功能展示给使用指定证书签署的另一应用。通过使用同一个证书签署多个APK并使用基于签名的权限检查功能，您的应用可采用安全的方式共享代码和数据。</li>
</ul>
<h2 id="63-Theme和Sytle"><a href="#63-Theme和Sytle" class="headerlink" title="63. Theme和Sytle"></a>63. Theme和Sytle</h2><h3 id="63-1-Style"><a href="#63-1-Style" class="headerlink" title="63.1. Style"></a>63.1. Style</h3><p>样式是指为View或窗口指定外观和格式的属性集合。样式可以指定高度、填充、字体颜色、字号、背景色等许多属性。 样式是在与指定布局的XML不同的XML资源中进行定义。</p>
<ul>
<li>要创建一组样式，请在您的项目的<code>res/values/</code>目录中保存一个XML文件。</li>
<li>该XML文件的根节点必须是<code>&lt;resources&gt;</code>。</li>
<li>对于您想创建的每个样式，向该文件添加一个<code>&lt;style&gt;</code>元素，该元素带有对样式进行唯一标识的<code>name</code>属性（该属性为必需属性）。</li>
<li>然后为该样式的每个属性添加一个<code>&lt;item&gt;</code>元素，该元素带有声明样式属性以及属性值的<code>name</code>（该属性为必需属性）。</li>
<li>根据样式属性，<code>&lt;item&gt;</code>的值可以是关键字字符串、十六进制颜色值、对另一资源类型的引用或其他值。</li>
<li>您可以通过<code>&lt;style&gt;</code>元素中的<code>parent</code>属性指定应作为您的样式所继承属性来源的样式。</li>
<li>当您对布局中的单个View应用样式时，该样式定义的属性只应用于该View。如果对ViewGroup应用样式，子View元素将不会继承样式属性—-只有被您直接应用样式的元素才会应用其属性。</li>
</ul>
<pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CodeFont<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:style/TextAppearance.Medium<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">
        &lt;item name=<span class="token string">"android:layout_width"</span>>fill_parent&lt;/item>
        &lt;item name=<span class="token string">"android:layout_height"</span>>wrap_content&lt;/item>
        &lt;item name=<span class="token string">"android:textColor"</span>><span class="token hexcode">#00FF00</span>&lt;/item>
        &lt;item name=<span class="token string">"android:typeface"</span>>monospace&lt;/item>
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span>
</code></pre>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span><span class="token style-attr language-css"><span class="token attr-name">
    <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value">@style/CodeFont</span><span class="token punctuation">"</span></span>
    <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/hello<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>
</code></pre>
<h3 id="63-2-Theme"><a href="#63-2-Theme" class="headerlink" title="63.2. Theme"></a>63.2. Theme</h3><p>主题是指对整个Activity或应用而不是对单个View（如上例所示）应用的样式。以主题形式应用样式时，Activity或应用中的每个视图都将应用其支持的每个样式属性。例如，您可以Activity主题形式应用同一CodeFont样式，之后该Activity内的所有文本都将具有绿色固定宽度字体。</p>
<ul>
<li>在XML中定义您想用作Activity或应用主题的样式与定义视图样式的方法完全相同。</li>
<li>Activity或应用内的每个View都将应用其支持的每个属性。例如，如果您对某个Activity应用前面示例中的CodeFont样式，则所有支持这些文本样式属性的View元素也会应用这些属性。任何不支持这些属性的View都会忽略这些属性。如果某个View仅支持部分属性，将只应用这些属性。</li>
</ul>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span> <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@style/CustomTheme<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span> <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:style/Theme.Dialog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
</code></pre>
<h2 id="64-Toast的时长设置"><a href="#64-Toast的时长设置" class="headerlink" title="64. Toast的时长设置"></a>64. Toast的时长设置</h2><p>Toast的显示时长仅有两种：<code>LENGTH_SHORT</code>和<code>LENGTH_LONG</code>。</p>
<p><code>Toast makeText (Context context, CharSequence text, int duration)</code>：duration <code>int</code>: How long to display the message. Either <code>LENGTH_SHORT</code> or <code>LENGTH_LONG</code>。</p>
<h2 id="65-触发ANR的情况"><a href="#65-触发ANR的情况" class="headerlink" title="65. 触发ANR的情况"></a>65. 触发ANR的情况</h2><ul>
<li>KeyDispatchTimeout(5 seconds)：按键或触摸事件在特定时间内无响应；</li>
<li>BroadcastTimeout(10 seconds)：BroadcastReceiver在特定时间内无法处理完成；</li>
<li>ServiceTimeout(20 seconds)：Service在特定的时间内无法处理完成</li>
</ul>
<h2 id="66-ServiceConnection的onServiceConnected-触发条件"><a href="#66-ServiceConnection的onServiceConnected-触发条件" class="headerlink" title="66. ServiceConnection的onServiceConnected()触发条件"></a>66. ServiceConnection的<code>onServiceConnected()</code>触发条件</h2><ul>
<li><code>bindService()</code>方法执行成功；</li>
<li><code>onBind()</code>方法返回非空IBinder对象。</li>
</ul>
<h2 id="67-Android虚拟设备不支持的功能"><a href="#67-Android虚拟设备不支持的功能" class="headerlink" title="67. Android虚拟设备不支持的功能"></a>67. Android虚拟设备不支持的功能</h2><ul>
<li>WLAN</li>
<li>蓝牙</li>
<li>NFC</li>
<li>SD 卡插入/弹出</li>
<li>连接到设备的耳机</li>
<li>USB</li>
</ul>
<h2 id="68-RemoteView的应用"><a href="#68-RemoteView的应用" class="headerlink" title="68. RemoteView的应用"></a>68. RemoteView的应用</h2><ul>
<li>AppWidget</li>
<li>Notification</li>
</ul>
<h2 id="69-Android对HashMap做了优化后推出的新的容器类是什么？"><a href="#69-Android对HashMap做了优化后推出的新的容器类是什么？" class="headerlink" title="69. Android对HashMap做了优化后推出的新的容器类是什么？"></a>69. Android对HashMap做了优化后推出的新的容器类是什么？</h2><h3 id="69-1-SparseArray"><a href="#69-1-SparseArray" class="headerlink" title="69.1. SparseArray"></a>69.1. SparseArray</h3><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间。</p>
<h3 id="69-2-ArrayMap"><a href="#69-2-ArrayMap" class="headerlink" title="69.2. ArrayMap"></a>69.2. ArrayMap</h3><p>ArrayMap是一个&lt;key,value&gt;映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作。</p>
<h2 id="70-Android安全沙盒"><a href="#70-Android安全沙盒" class="headerlink" title="70. Android安全沙盒"></a>70. Android安全沙盒</h2><ul>
<li>Android操作系统是一种多用户Linux系统，其中的每个应用都是一个不同的用户；</li>
<li>默认情况下，系统会为每个应用分配一个唯一的Linux用户ID（该ID仅由系统使用，应用并不知晓）。系统为应用中的所有文件设置权限，使得只有分配给该应用的用户ID才能访问这些文件；</li>
<li>每个进程都具有自己的虚拟机 (VM)，因此应用代码是在与其他应用隔离的环境中运行；</li>
<li>默认情况下，每个应用都在其自己的Linux进程内运行。Android会在需要执行任何应用组件时启动该进程，然后在不再需要该进程或系统必须为其他应用恢复内存时关闭该进程。</li>
</ul>
<h2 id="71-onStartCommand-有哪些返回值"><a href="#71-onStartCommand-有哪些返回值" class="headerlink" title="71. onStartCommand()有哪些返回值"></a>71. <code>onStartCommand()</code>有哪些返回值</h2><p><code>onStartCommand()</code>的返回值用于描述系统应该如何在服务终止的情况下继续运行服务。其值可以为</p>
<ul>
<li><code>START_NOT_STICKY</code>：如果系统在<code>onStartCommand()</code>返回后终止服务，则除非有挂起Intent要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</li>
<li><code>START_STICKY</code>：如果系统在<code>onStartCommand()</code>返回后终止服务，则会重建服务并调用<code>onStartCommand()</code>，但不会重新传递最后一个Intent。相反，除非有挂起Intent要启动服务（在这种情况下，将传递这些Intent），否则系统会通过空Intent调用<code>onStartCommand()</code>。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</li>
<li><code>START_REDELIVER_INTENT</code>：如果系统在<code>onStartCommand()</code>返回后终止服务，则会重建服务，并通过传递给服务的最后一个Intent调用<code>onStartCommand()</code>。任何挂起Intent均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</li>
</ul>
<h2 id="72-如何创建绑定服务"><a href="#72-如何创建绑定服务" class="headerlink" title="72. 如何创建绑定服务"></a>72. 如何创建绑定服务</h2><p>建提供绑定的服务时，您必须提供IBinder，用以提供客户端用来与服务进行交互的编程接口。</p>
<h3 id="72-1-扩展Binder类"><a href="#72-1-扩展Binder类" class="headerlink" title="72.1. 扩展Binder类"></a>72.1. 扩展Binder类</h3><p>如果服务是供您的自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展Binder类并从<code>onBind()</code>返回它的一个实例来创建接口。客户端收到Binder后，可利用它直接访问Binder实现中乃至Service中可用的公共方法。</p>
<ol>
<li>在您的服务中，创建一个可满足下列任一要求的Binder实例：</li>
</ol>
<ul>
<li>包含客户端可调用的公共方法</li>
<li>返回当前Service实例，其中包含客户端可调用的公共方法</li>
<li>或返回由服务承载的其他类的实例，其中包含客户端可调用的公共方法</li>
</ul>
<ol start="2">
<li>从<code>onBind()</code>回调方法返回此Binder实例。</li>
<li>在客户端中，从<code>onServiceConnected()</code>回调方法接收Binder，并使用提供的方法调用绑定服务。</li>
</ol>
<h3 id="72-2-使用Messenger"><a href="#72-2-使用Messenger" class="headerlink" title="72.2. 使用Messenger"></a>72.2. 使用Messenger</h3><ol>
<li>服务实现一个Handler，由其接收来自客户端的每个调用的回调</li>
<li>Handler用于创建Messenger对象（对Handler的引用）</li>
<li>Messenger创建一个IBinder，服务通过<code>onBind()</code>使其返回客户端</li>
<li>客户端使用IBinder将Messenger（引用服务的Handler）实例化，然后使用后者将Message对象发送给服务</li>
<li>服务在其Handler中（具体地讲，是在<code>handleMessage()</code>方法中）接收每个 Message。</li>
</ol>
<p>这样，客户端并没有调用服务的“方法”。而客户端传递的“消息”（Message对象）是服务在其Handler中接收的。</p>
<h2 id="73-如何绑定到服务"><a href="#73-如何绑定到服务" class="headerlink" title="73. 如何绑定到服务"></a>73. 如何绑定到服务</h2><p>应用组件（客户端）可通过调用<code>bindService()</code>绑定到服务。Android系统随后调用服务的onBind()方法，该方法返回用于与服务交互的IBinder。</p>
<p>绑定是异步的。<code>bindService()</code>会立即返回，“不会”使IBinder返回客户端。要接收IBinder，客户端必须创建一个ServiceConnection实例，并将其传递给<code>bindService()</code>。ServiceConnection包括一个回调方法，系统通过调用它来传递IBinder。</p>
<ol>
<li><p>实现ServiceConnection。您的实现必须重写两个回调方法：<code>onServiceConnected()</code>：系统会调用该方法以传递服务的onBind()方法返回的IBinder。<code>onServiceDisconnected()</code>：Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统“不会”调用该方法。</p>
</li>
<li><p>调用<code>bindService()</code>，传递ServiceConnection实现。</p>
</li>
<li><p>当系统调用您的<code>onServiceConnected()</code>回调方法时，您可以使用接口定义的方法开始调用服务。</p>
</li>
<li><p>要断开与服务的连接，请调用<code>unbindService()</code>。如果应用在客户端仍绑定到服务时销毁客户端，则销毁会导致客户端取消绑定。更好的做法是在客户端与服务交互完成后立即取消绑定客户端。</p>
</li>
</ol>
<h2 id="74-Android支持的屏幕密度"><a href="#74-Android支持的屏幕密度" class="headerlink" title="74. Android支持的屏幕密度"></a>74. Android支持的屏幕密度</h2><ul>
<li>ldpi（低）：120dpi</li>
<li>mdpi（中）：160dpi</li>
<li>hdpi（高）：240dpi</li>
<li>xhdpi（超高）：320dpi</li>
<li>xxhdpi（超超高）：480dpi</li>
<li>xxxhdpi（超超超高）：640dpi</li>
</ul>
<h2 id="75-如何支持多种屏幕"><a href="#75-如何支持多种屏幕" class="headerlink" title="75. 如何支持多种屏幕"></a>75. 如何支持多种屏幕</h2><ul>
<li>在清单中显式声明您的应用支持哪些屏幕尺寸；</li>
<li>为不同屏幕尺寸提供不同的布局；</li>
<li>为不同屏幕密度提供不同的位图可绘制对象。</li>
</ul>
<h2 id="76-什么是资源ID"><a href="#76-什么是资源ID" class="headerlink" title="76. 什么是资源ID"></a>76. 什么是资源ID</h2><p>所有资源ID都在您项目的R类中定义，后者由aapt工具自动生成。</p>
<p>编译应用时，aapt会生成R类，其中包含您的res/目录中所有资源的资源ID。每个资源类型都有对应的R子类（例如，R.drawable对应于所有可绘制对象资源），而该类型的每个资源都有对应的静态整型数（例如，R.drawable.icon）。这个整型数就是可用来检索资源的资源ID。</p>
<p>资源ID始终由以下部分组成：</p>
<ul>
<li>资源类型：每个资源都被分到一个“类型”组中，例如string、drawable和layout。</li>
<li>资源名称：它是不包括扩展名的文件名；或是XML android:name属性中的值，如果资源是简单值的话（例如字符串）。</li>
</ul>
<h2 id="77-如何处理运行时变更"><a href="#77-如何处理运行时变更" class="headerlink" title="77. 如何处理运行时变更"></a>77. 如何处理运行时变更</h2><p>有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。发生这种变化时，Android会重启正在运行的Activity（先后调用<code>onDestroy()</code>和<code>onCreate()</code>）。</p>
<h3 id="77-1-在配置变更期间保留对象"><a href="#77-1-在配置变更期间保留对象" class="headerlink" title="77.1. 在配置变更期间保留对象"></a>77.1. 在配置变更期间保留对象</h3><p>如果Activity因配置变更而重启，则可通过保留Fragment来减轻重新初始化Activity的负担。此片段可能包含对您要保留的有状态对象的引用。</p>
<ol>
<li>扩展Fragment类并声明对有状态对象的引用。</li>
<li>在创建片段后调用<code>setRetainInstance(boolean)</code>。</li>
<li>将片段添加到Activity。</li>
<li>重启Activity后，使用FragmentManager检索片段。</li>
</ol>
<h3 id="77-2-自行处理配置变更"><a href="#77-2-自行处理配置变更" class="headerlink" title="77.2. 自行处理配置变更"></a>77.2. 自行处理配置变更</h3><p>要声明由Activity处理配置变更，请在清单文件中编辑相应的<code>&lt;activity&gt;</code>元素，以包含<code>android:configChanges</code>属性以及代表要处理的配置的值。<code>android:configChanges</code>属性的文档中列出了该属性的可能值（最常用的值包括”orientation”和”keyboardHidden”，分别用于避免因屏幕方向和可用键盘改变而导致重启）。</p>
<h2 id="78-AndroidManifest-xml包括哪些内容？"><a href="#78-AndroidManifest-xml包括哪些内容？" class="headerlink" title="78. AndroidManifest.xml包括哪些内容？"></a>78. AndroidManifest.xml包括哪些内容？</h2><ul>
<li>为应用的Java软件包命名。软件包名称充当应用的唯一标识符。</li>
<li>描述应用的各个组件，包括构成应用的Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理的Intent消息。这些声明向Android系统告知有关组件以及可以启动这些组件的条件的信息。</li>
<li>确定托管应用组件的进程。</li>
<li>声明应用必须具备哪些权限才能访问API中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限。</li>
<li>声明应用所需的最低Android API级别。</li>
<li>列出应用必须链接到的库。</li>
</ul>
<h2 id="79-用户界面如何构成？"><a href="#79-用户界面如何构成？" class="headerlink" title="79. 用户界面如何构成？"></a>79. 用户界面如何构成？</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/viewgroup.png" alt="View Group"></p>
<p>Android应用中的所有用户界面元素都是使用View和ViewGroup对象构建而成。View对象用于在屏幕上绘制可供用户交互的内容。ViewGroup对象用于储存其他View（和ViewGroup）对象，以便定义界面的布局。</p>
<p>每个应用组件的用户界面都是使用View和ViewGroup对象的层次结构定义的。每个视图组都是一个用于组织子视图的不可见容器，而子视图可以是输入控件或其他可绘制某一UI部分的小部件。 </p>
<h2 id="80-为什么要回收Bitmap的内存"><a href="#80-为什么要回收Bitmap的内存" class="headerlink" title="80. 为什么要回收Bitmap的内存"></a>80. 为什么要回收Bitmap的内存</h2><p>Bitmap的实例化只能通过BitmapFactory，而Bitmap对象的生成则是通过JNI调用，所以Bitmap包含Java和C两部分内存。Java部分内存可以通过虚拟机自动回收，但C部分则需要手动释放，所以需要显式调用<code>recycle()</code>方法来释放。</p>
<h2 id="81-如何优化Bitmap"><a href="#81-如何优化Bitmap" class="headerlink" title="81. 如何优化Bitmap"></a>81. 如何优化Bitmap</h2><ul>
<li>加载合适尺寸的图片；</li>
<li>及时回收Bitmap；</li>
<li>捕获OOM异常；</li>
<li>压缩图片；</li>
<li>使用合适的颜色模式。</li>
</ul>
<h2 id="82-如何在新进程中创建Activity／Service"><a href="#82-如何在新进程中创建Activity／Service" class="headerlink" title="82. 如何在新进程中创建Activity／Service"></a>82. 如何在新进程中创建Activity／Service</h2><p>在AndroidManifest中，组件元素条目（activity、service、receiver或provider）中设置<code>android:process</code>属性，此属性可以指定该组件应在哪个进程运行。</p>
<p>每新建一个进程，Application的<code>onCreate()</code>都将被调用一次。</p>
<h2 id="83-onActivityResult-什么时候会失效？"><a href="#83-onActivityResult-什么时候会失效？" class="headerlink" title="83. onActivityResult()什么时候会失效？"></a>83. <code>onActivityResult()</code>什么时候会失效？</h2><p>在<code>startActivity()</code>为SingleTask时会失效。</p>
<blockquote>
<p>For example, if the activity you are launching uses the singleTask launch mode, it will not run in your task and thus you will immediately receive a cancel result.</p>
</blockquote>
<p>如果你正加载的activity使用了singleTask的加载模式，它不会在你的栈中运行，而且这样你会马上收到一个取消的结果。即在<code>onActivityResult()</code>里马上得到一个RESULT_CANCEL。</p>
<h2 id="84-Android崩溃捕获"><a href="#84-Android崩溃捕获" class="headerlink" title="84. Android崩溃捕获"></a>84. Android崩溃捕获</h2><h3 id="84-1-Java崩溃捕获"><a href="#84-1-Java崩溃捕获" class="headerlink" title="84.1. Java崩溃捕获"></a>84.1. Java崩溃捕获</h3><p>Java提供有UncaughtExceptionHandler接口，该接口含有一个方法：<code>void uncaughtException(Thread t, Throwable e)</code>。</p>
<p>Uncaught异常发生时会终止线程，此时，系统便会通知UncaughtExceptionHandler，调用<code>uncaughtException()</code>函数。如果该handler没有被显式设置，则会调用对应线程组的默认handler。</p>
<p>如果要捕获该异常，必须实现UncaughtExceptionHandler，并通过<code>public static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)</code>进行设置。</p>
<h3 id="84-2-Native崩溃捕获"><a href="#84-2-Native崩溃捕获" class="headerlink" title="84.2. Native崩溃捕获"></a>84.2. Native崩溃捕获</h3><p>对Native代码的崩溃，可以通过调用<code>int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact))</code>注册信号处理函数来完成。</p>
<h2 id="85-Android-APP构建流程"><a href="#85-Android-APP构建流程" class="headerlink" title="85. Android APP构建流程"></a>85. Android APP构建流程</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/build_process.png" alt="Build Process"></p>
<p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/build_process_2.png" alt="Build Process"></p>
<p>典型的Android APP构建流程：</p>
<ol>
<li>Java编译器对工程本身的java代码进行编译，这些java代码有三个来源：app的源代码，由资源文件生成的R文件（aapt工具），以及有aidl文件生成的java接口文件（aidl工具）。产出为.class文件。</li>
<li>class文件和依赖的三方库文件通过dex工具生成Delvik虚拟机可执行的.dex文件，可能有一个或多个，包含了所有的class信息，包括项目自身的class和依赖的class。产出为.dex文件。</li>
<li>apkbuilder工具将.dex文件和编译后的资源文件生成未经签名对齐的apk文件。这里编译后的资源文件包括两部分，一是由aapt编译产生的编译后的资源文件，二是依赖的三方库里的资源文件。产出为未经签名的.apk文件。</li>
<li>分别由Jarsigner和zipalign对apk文件进行签名和对齐，生成最终的apk文件。</li>
</ol>
<h2 id="86-class文件与-dex文件的区别"><a href="#86-class文件与-dex文件的区别" class="headerlink" title="86. class文件与.dex文件的区别"></a>86. class文件与.dex文件的区别</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/class_vs_dex.png" alt="class vs dex"></p>
<h2 id="87-65535问题"><a href="#87-65535问题" class="headerlink" title="87. 65535问题"></a>87. 65535问题</h2><h3 id="87-1-原因"><a href="#87-1-原因" class="headerlink" title="87.1. 原因"></a>87.1. 原因</h3><p>单个dex文件中，method个数采用使用原生类型short来索引，即2个字节最多65536个method，field、class的个数也均有此限制。</p>
<h3 id="87-2-解决方法"><a href="#87-2-解决方法" class="headerlink" title="87.2. 解决方法"></a>87.2. 解决方法</h3><p>build.gradle中配置<code>multiDexEnabled true</code>，将dex分包。</p>
<h2 id="88-Dalvik与JVM的区别"><a href="#88-Dalvik与JVM的区别" class="headerlink" title="88. Dalvik与JVM的区别"></a>88. Dalvik与JVM的区别</h2><ul>
<li>JVM可以执行的文件是.class结尾的字节码文件，而Dalvik执行的是dex文件（不符合JVM规范）。</li>
<li>Dalvik基于寄存器，而JVM基于栈。</li>
<li>Dalvik负责进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。</li>
</ul>
<p>除此之外：</p>
<ul>
<li>有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，它会完成虚拟机的初始化、库的加载、预制类库和初始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的速度提供给系统。</li>
</ul>
<h2 id="89-ART相对Dalvik的优化"><a href="#89-ART相对Dalvik的优化" class="headerlink" title="89. ART相对Dalvik的优化"></a>89. ART相对Dalvik的优化</h2><ul>
<li>AOT替换JIT：使用AOT直接在安装时用dex2oat将其完全翻译成native代码。</li>
<li>GC性能提升：并行GC。</li>
<li>提升内存效率：专门开辟内存存放large object，因为large object移动成本太大；引入moving collector技术，将不连续的物理内存块对齐，解决内存碎片化问题。</li>
</ul>
<p>参考：<a href="https://source.android.com/devices/tech/dalvik/" target="_blank" rel="noopener">ART and Dalvik | Android Open Source Project</a></p>
<h2 id="90-Android中的ClassLoader"><a href="#90-Android中的ClassLoader" class="headerlink" title="90. Android中的ClassLoader"></a>90. Android中的ClassLoader</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/classloader.png" alt="ClassLoader"></p>
<ul>
<li>在Android中，App安装到手机后，apk里面的class.dex中的class均是通过PathClassLoader来加载的。</li>
<li>DexClassLoader可以用来加载SD卡上加载包含class.dex的.jar和.apk文件。</li>
<li>DexClassLoader和PathClassLoader的基类BaseDexClassLoader查找class是通过其内部的<code>DexPathList pathList</code>来查找的。</li>
<li>DexPathList内部有一个<code>Element[] dexElements</code>数组，其<code>findClass()</code>方法的实现就是遍历该数组，查找class，一旦找到需要的类，就直接返回，停止遍历。</li>
</ul>
<h2 id="91-ClassLoader方式实现热修复"><a href="#91-ClassLoader方式实现热修复" class="headerlink" title="91. ClassLoader方式实现热修复"></a>91. ClassLoader方式实现热修复</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/classloader_hotpatch.jpg" alt="ClassLoader Hot Patch"></p>
<p>主要步骤：</p>
<ol>
<li>假设MainActivity中有一个方法<code>showMsg()</code>需要修复。</li>
<li>修复<code>showMsg()</code>方法，制作补丁包patch.jar，该patch.jar文件中就包含已经修复了的dex文件。</li>
<li>在Application的<code>onCreate()</code>方法中检测是否已经下载好补丁包，如果存在补丁包，就通过DexClassLoader加载patch.jar，然后通过反射拿到DexClassLoader中的 DexPathList对象，进而拿到<code>Element[] dexElements</code>数组，这里标记该Element数组为<code>newDexElements</code>。</li>
<li>还是通过反射，拿到App默认的ClassLoader即PathClassLoader的DexPathList对象，进而拿到Element数组，这里标记下该数组为<code>baseDexElements</code>。</li>
<li>将<code>newDexElements</code>和<code>baseDexElements</code>合成一个新的数组<code>allDexElements</code>，且保证<code>newDexElements</code>中的值在<code>allDexElements</code>数组的最前面。</li>
<li>然后还是通过通过反射，将合成的Element数组设置给PathClassLoader的DexPathList对象。</li>
<li>在Application完成初始化之后，会开始加载MainActivity，加载过程就是通过DexPathList对象的<code>findClass()</code>方法来完成的，会从头开始遍历其Element数组，会优先查找到之前插入的补丁包中的dexFile，而原apk中的则不会查找到，因此就实现了热修复的目的。</li>
</ol>
<p>参考：<a href="http://jaeger.itscoder.com/android/2016/09/20/nuva-source-code-analysis.html" target="_blank" rel="noopener">热修复实现：ClassLoader 方式的实现</a></p>
<h2 id="92-AsyncTask需要在主线程中实例化吗？"><a href="#92-AsyncTask需要在主线程中实例化吗？" class="headerlink" title="92. AsyncTask需要在主线程中实例化吗？"></a>92. AsyncTask需要在主线程中实例化吗？</h2><h3 id="92-1-API-16之前"><a href="#92-1-API-16之前" class="headerlink" title="92.1. API 16之前"></a>92.1. API 16之前</h3><p>AsyncTask的静态Handler创建和初始化时默认采用的是当前现场的Looper。若子线程无Looper，则会出错；若有Looper则会导致处理消息时无法在主线程执行，出错。所以AsyncTask必须在主线程实例化。</p>
<h3 id="92-2-API-16及之后，API-22之前"><a href="#92-2-API-16及之后，API-22之前" class="headerlink" title="92.2. API 16及之后，API 22之前"></a>92.2. API 16及之后，API 22之前</h3><p>在ActivityThread的<code>main()</code>中直接调用了<code>AsyncTask.init()</code>，保证Handler在主线程实例化。所以AsyncTask不需要在主线程实例化。</p>
<h3 id="92-3-API-22及之后"><a href="#92-3-API-22及之后" class="headerlink" title="92.3. API 22及之后"></a>92.3. API 22及之后</h3><p>不再在ActivityThread的<code>main()</code>中调用。AsyncTask通过<code>getMainLooper()</code>获得主线程Looper。所以AsyncTask不需要在主线程实例化。</p>
<h2 id="93-Android消息处理机制"><a href="#93-Android消息处理机制" class="headerlink" title="93. Android消息处理机制"></a>93. Android消息处理机制</h2><p>Android消息处理机制主要涉及4个类：Looper、Handler、MessageQueue和Message。</p>
<h3 id="93-1-Looper"><a href="#93-1-Looper" class="headerlink" title="93.1. Looper"></a>93.1. Looper</h3><p>Looper的使用：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LooperThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> Handler mHandler<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Looper<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// process incoming messages here</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>

        Looper<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Looper概览：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Looper</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>Looper<span class="token operator">></span> sThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> MessageQueue mQueue<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueue</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Only one Looper may be created per thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> Looper <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Message msg <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// might block</span>
            msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">dispatchMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            msg<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><code>prepare()</code>会检查此线程是否已经存在Looper，随后便会实例化一个Looper（创建一个MessageQueue），并将此Looper设置为此线程的ThreadLocal变量，这样完成Looper和线程的绑定。</p>
<p><code>loop()</code>即进从MessageQueue取消息并处理的死循环。</p>
<h3 id="93-2-Handler"><a href="#93-2-Handler" class="headerlink" title="93.2. Handler"></a>93.2. Handler</h3><p>Handler概览：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> Looper mLooper<span class="token punctuation">;</span>
    <span class="token keyword">final</span> MessageQueue mQueue<span class="token punctuation">;</span>
    <span class="token keyword">final</span> Handler<span class="token punctuation">.</span>Callback mCallback<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mLooper <span class="token operator">=</span> Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>mLooper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>
                    <span class="token string">"Can't create handler inside thread that has not called Looper.prepare()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        mQueue <span class="token operator">=</span> mLooper<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispatchMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>callback <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">handleCallback</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> what<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> Message <span class="token function">getPostMessage</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Message m <span class="token operator">=</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        m<span class="token punctuation">.</span>callback <span class="token operator">=</span> r<span class="token punctuation">;</span>
        <span class="token keyword">return</span> m<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">post</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        MessageQueue queue <span class="token operator">=</span> mQueue<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>MessageQueue queue<span class="token punctuation">,</span> Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        msg<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">enqueueMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handleCallback</span><span class="token punctuation">(</span>Message message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        message<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>一般的用法是对<code>mHandler</code>调用<code>obtainMessage()</code>获得Message并设置参数后通过<code>sendMessage()</code>发送出去。在<code>obtainMessage()</code>和<code>sendMessage()</code>都会设置Message的Handler为本Handler（Message的<code>target</code>变量），若需向Message传递Runnable对象，则会在Message的<code>callback</code>变量中记录。</p>
<p><code>sendMessage()</code>最终会调用MessageQueue的<code>enqueueMessage()</code>方法，将此Message绑定到对应Looper对应的MessageQueue上。而Looper中收到Message后，会调用Message的<code>target</code>变量（即Handler）的<code>dispatchMessage()</code>方法。对于普通Message，<code>dispatchMessage()</code>又会去调用<code>handleMessage()</code>方法，而这个方法会被用户重载，所以会执行<code>mHandler</code>中指定的代码。</p>
<p>参考：<a href="http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html" target="_blank" rel="noopener">android的消息处理机制（图+源码分析）——Looper,Handler,Message - CodingMyWorld - 博客园</a></p>
<h2 id="94-startActivity-执行流程"><a href="#94-startActivity-执行流程" class="headerlink" title="94. startActivity()执行流程"></a>94. <code>startActivity()</code>执行流程</h2><p><img src="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/start_activity_process.jpg" alt="Start Activity Process"></p>
<ul>
<li>当Activity的目标进程不存在时，会首先创建进程。</li>
<li>Activity Manager Service（AMS）向目标进程的主线程发送<code>LAUNCH_ACTIVITY</code>，目标进程通过反射创建目标Activity，然后进入<code>onCreate()</code>生命周期。</li>
</ul>
<p>参考：<a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析 - Gityuan博客 | 袁辉辉博客</a></p>

            </div>
            <hr>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff;
        background-color: #22AB38;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff;
        background-color: #019FE8;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a class="reward-link btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs">
                        <li class="tab wechat-tab waves-effect waves-light"><a class="active" href="#wechat">微信</a></li>
                        <li class="tab alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                    </ul>
                    <div id="wechat">
                        <img src="/medias/reward/" class="reward-img" alt="微信打赏二维码">
                    </div>
                    <div id="alipay">
                        <img src="/medias/reward/" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('#reward .reward-link').on('click', function () {
            $('#rewardModal').openModal();
        });

        $('#rewardModal .close').on('click', function () {
            $('#rewardModal').closeModal();
        });
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone, qq, weibo, douban"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">转载请注明: </span>
                    <a href="https://geekerstar.github.io" class="b-link-green">极客文库-知识库</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2018/12/21/android-kai-fa-xiang-guan-zhi-shi-zong-jie/" class="b-link-green">Android开发相关知识总结</a>
                </p>
            </div>
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'e5af4edd318be4fd1767',
        clientSecret: '5710d909cf183f3dbc6864ad973cdbc2dd3361e6',
        repo: 'geekerstar.github.io',
        owner: 'geekerstar',
        admin: "geekerstar",
        id: '2018-12-21T22-32-57',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">上一篇</div>
            <div class="card">
                <a href="/2018/12/22/diveines6/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="《深入理解ES6》笔记">
                        
                        <span class="card-title">《深入理解ES6》笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">1、《深入理解ES6》笔记——块级作用域绑定本章涉及3个知识点，var、let、const，现在让我们了解3个关键字的特性和使用方法。
varJavaScript中，我们通常说的作用域是函数作用域，使用var声明的变量，无论是在代码的哪个地</div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2018-12-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/javascript/" class="post-category" target="_blank">
                                    javascript
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/javascript/" target="_blank">
                        <span class="chip bg-color">javascript</span>
                    </a>
                    
                    <a href="/tags/ES6/" target="_blank">
                        <span class="chip bg-color">ES6</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">下一篇</div>
            <div class="card">
                <a href="/2018/12/19/ioc/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="IOC容器实现篇">
                        
                        <span class="card-title">IOC容器实现篇</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">IOC的概念什么是IOC？IoC(Inversion of Control)，意为控制反转，不是什么技术，而是一种设计思想。Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。
如何理解好Ioc呢？理解好Ioc的关</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2018-12-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/spring/" class="post-category" target="_blank">
                                    spring
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/spring/" target="_blank">
                        <span class="chip bg-color">spring</span>
                    </a>
                    
                    <a href="/tags/ioc/" target="_blank">
                        <span class="chip bg-color">ioc</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>
    </div>
    <div class="col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title">目录</div>
            <div id="toc-content">

            </div>
        </div>
    </div>
</div>

<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="http://www.geekerstar.com" target="_blank">Geekerstar</a>维护，作为
            <a href="https://www.jikewenku.com" target="_blank">极客文库</a>辅助站
        </div>
        <div class="col s12 m4 l4 social-link"><a href="https://github.com/geekerstar" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
    <i class="fa fa-github"></i>
</a>
<a href="https://weibo.com/247507792" class="tooltipped" target="_blank" data-tooltip="微博联系我" data-position="top" data-delay="50">
    <i class="fa fa-weibo"></i>
</a>
<a href="#!" class="tooltipped" data-tooltip="QQ联系我: 247507792" data-position="top" data-delay="50">
    <i class="fa fa-qq"></i>
</a>

<a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
    <i class="fa fa-rss"></i>
</a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title">搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input" autofocus>
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/js/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->


</body>
</html>