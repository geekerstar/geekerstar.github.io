<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>java基础知识总结</title>
      <link href="/2018/12/31/java1/"/>
      <url>/2018/12/31/java1/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><ul><li><a href="#1-一个java源文件中是否可以包括多个类">1. 一个”.java”源文件中是否可以包括多个类?</a></li><li><a href="#2-源文件javac出多个class文件出来是怎么回事">2. 源文件javac出多个class文件出来是怎么回事?</a></li><li><a href="#3-什么是匿名类">3. 什么是匿名类？</a></li><li><a href="#4-switch-case中switch后的变量类型可以是什么">4. <code>switch case</code>中<code>switch</code>后的变量类型可以是什么？</a></li><li><a href="#5-char型变量与汉字">5. <code>char</code>型变量与汉字。</a></li><li><a href="#6-使用final关键字修饰一个变量时是引用不能变还是引用的对象不能变">6. 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</a></li><li><a href="#7-overload和override的区别">7. Overload和Override的区别。</a></li><li><a href="#8-构造器constructor是否可被override">8. 构造器Constructor是否可被override?</a></li><li><a href="#9-java抽象类abstract-class和类class的区别">9. Java抽象类（abstract class）和类（class）的区别？</a></li><li><a href="#10-java接口与抽象类如何合作">10. Java接口与抽象类如何合作?</a></li><li><a href="#11-java中实现多态的机制是什么">11. Java中实现多态的机制是什么？</a></li><li><a href="#12-java实现了闭包吗">12. Java实现了闭包吗？</a></li><li><a href="#13-string-s--new-stringxyz创建了几个string-object">13. <code>String s = new String(&quot;xyz&quot;)</code>创建了几个String Object?</a></li><li><a href="#14-try-catch-finally-return的执行顺序">14. try-catch-finally-return的执行顺序</a></li><li><a href="#15-当一个线程进入一个对象的一个synchronized方法后其它线程是否可进入此对象的其它方法">15. 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</a></li><li><a href="#16-arraylist和vector的区别">16. ArrayList和Vector的区别</a></li><li><a href="#17-hashmap和hashtable的区别">17. HashMap和Hashtable的区别</a></li><li><a href="#18-listsetmap是否继承自collection接口">18. List，Set，Map是否继承自Collection接口?</a></li><li><a href="#19-collection和-collections的区别">19. Collection和 Collections的区别。</a></li><li><a href="#20-java中有几种类型的流jdk为每种类型的流提供了一些抽象类以供继承请说出他们分别是哪些类">20. Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？</a></li><li><a href="#21-描述一下jvm加载class文件的原理机制">21. 描述一下JVM加载class文件的原理机制?</a></li><li><a href="#22-能不能自己写个类也叫javalangstring">22. 能不能自己写个类，也叫java.lang.String？</a></li><li><a href="#23-java中反射的作用是什么">23. Java中反射的作用是什么?</a></li><li><a href="#24-成员变量局部变量静态变量的区别">24. 成员变量、局部变量、静态变量的区别</a></li><li><a href="#25-谈谈你对strongreferenceweakreference和softreference的认识">25. 谈谈你对StrongReference、WeakReference和SoftReference的认识</a></li><li><a href="#26-与equals的区别">26. <code>==</code>与<code>equals()</code>的区别？</a></li><li><a href="#27-equals与hashcode的区别">27. <code>equals()</code>与<code>hashCode()</code>的区别？</a></li><li><a href="#28-java集合框架示意图">28. Java集合框架示意图</a><ul><li><a href="#281-集合框架概览">28.1. 集合框架概览</a></li><li><a href="#282-list">28.2. List</a></li><li><a href="#283-set">28.3. Set</a></li><li><a href="#284-map">28.4. Map</a></li><li><a href="#285-queue">28.5. Queue</a></li></ul></li><li><a href="#29-error和exception的区别">29. Error和Exception的区别</a></li><li><a href="#30-用户线程user-thread与守护线程daemon-thread">30. 用户线程（User Thread）与守护线程（Daemon Thread）</a></li><li><a href="#31-java内存模型">31. Java内存模型</a><ul><li><a href="#311-主内存与工作内存">31.1. 主内存与工作内存</a></li><li><a href="#312-内存间交互操作">31.2. 内存间交互操作</a></li><li><a href="#313-对volatile型变量的特殊规则">31.3. 对volatile型变量的特殊规则</a></li><li><a href="#314-原子性可见性与有序性">31.4. 原子性、可见性与有序性</a><ul><li><a href="#3141-原子性atomicity">31.4.1. 原子性（Atomicity）</a></li><li><a href="#3142-可见性visibility">31.4.2. 可见性（Visibility）</a></li><li><a href="#3143-有序性ordering">31.4.3. 有序性（Ordering）</a></li></ul></li><li><a href="#315-先行发生原则">31.5. 先行发生原则</a></li></ul></li><li><a href="#32-java中的bionioaio分别是什么">32. Java中的BIO，NIO，AIO分别是什么?</a><ul><li><a href="#321-biosynchronous-blocking-io同步阻塞io">32.1. BIO（synchronous Blocking IO，同步阻塞IO）</a></li><li><a href="#322-niosynchronous-non-blocking-io同步非阻塞io">32.2. NIO（synchronous Non blocking IO，同步非阻塞IO）</a></li><li><a href="#323-aioasynchronous-non-blocking-io异步非阻塞io">32.3. AIO（Asynchronous non blocking IO，异步非阻塞IO）</a></li></ul></li><li><a href="#33-serializable接口和序列化与反序列化">33. Serializable接口和序列化与反序列化</a></li><li><a href="#34-arraylist的sublist方法注意事项">34. ArrayList的<code>subList()</code>方法注意事项</a></li><li><a href="#35-arrays的aslist方法注意事项">35. Arrays的<code>asList()</code>方法注意事项</a></li><li><a href="#36-comparator注意事项">36. Comparator注意事项</a></li><li><a href="#37-hashmap多线程下死循环问题">37. HashMap多线程下死循环问题</a></li><li><a href="#38-什么是concurrenthashmap">38. 什么是ConcurrentHashMap</a></li><li><a href="#39-map类集合k／v能否存储null值的情况">39. Map类集合k／V能否存储null值的情况</a></li><li><a href="#40-simpledataformat线程安全吗">40. SimpleDataFormat线程安全吗？</a></li><li><a href="#41-timer可以用来并行处理定时任务吗">41. Timer可以用来并行处理定时任务吗？</a></li><li><a href="#42-可以在多线程下使用random吗">42. 可以在多线程下使用Random吗？</a></li><li><a href="#43-threadjoin是如何实现的">43. <code>Thread.join()</code>是如何实现的？</a></li><li><a href="#44-gc中可回收对象的判定方法">44. GC中可回收对象的判定方法</a><ul><li><a href="#441-引用计数法">44.1. 引用计数法</a></li><li><a href="#442-可达性分析算法">44.2. 可达性分析算法</a></li></ul></li><li><a href="#45-垃圾收集算法">45. 垃圾收集算法</a><ul><li><a href="#451-标记清除算法">45.1. 标记——清除算法</a></li><li><a href="#452-复制算法">45.2. 复制算法</a></li><li><a href="#453-标记整理算法">45.3. 标记——整理算法</a></li><li><a href="#454-分代收集算法">45.4. 分代收集算法</a><ul><li><a href="#4541-年轻代">45.4.1. 年轻代</a></li><li><a href="#4542-年老代">45.4.2. 年老代</a></li><li><a href="#4543-永久代">45.4.3. 永久代</a></li></ul></li></ul></li><li><a href="#46-java是值传递还是引用传递">46. Java是值传递还是引用传递？</a></li><li><a href="#47-线程同步的方法">47. 线程同步的方法</a></li><li><a href="#48-java创建线程的方式">48. Java创建线程的方式</a><ul><li><a href="#481-继承thread类创建线程类">48.1. 继承Thread类创建线程类</a></li><li><a href="#482-通过runnable接口创建线程类">48.2. 通过Runnable接口创建线程类</a></li><li><a href="#483-通过callable和future创建线程">48.3. 通过Callable和Future创建线程</a></li></ul></li><li><a href="#49-线程池原理">49. 线程池原理</a></li><li><a href="#50-类与类加载器的关系">50. 类与类加载器的关系</a></li><li><a href="#51-双亲委派模型">51. 双亲委派模型</a></li><li><a href="#52-如何自定义类加载器">52. 如何自定义类加载器</a></li><li><a href="#53-类的生命周期">53. 类的生命周期</a></li><li><a href="#54-类初始化的时机">54. 类初始化的时机</a></li><li><a href="#55-类的加载过程">55. 类的加载过程</a><ul><li><a href="#551-加载">55.1. 加载</a></li><li><a href="#552-连接">55.2. 连接</a><ul><li><a href="#5521-验证">55.2.1. 验证</a></li><li><a href="#5522-准备">55.2.2. 准备</a></li><li><a href="#5523-解析">55.2.3. 解析</a></li></ul></li><li><a href="#553-初始化">55.3. 初始化</a></li></ul></li><li><a href="#56-符号引用和直接引用的区别">56. 符号引用和直接引用的区别</a></li><li><a href="#57-如何理解平台无关性">57. 如何理解平台无关性</a></li><li><a href="#58-运行时数据区域">58. 运行时数据区域</a><ul><li><a href="#581-程序计数器program-counter-register">58.1. 程序计数器（Program Counter Register）</a></li><li><a href="#582-java虚拟机栈java-virtual-machine-stacks">58.2. Java虚拟机栈（Java Virtual Machine Stacks）</a></li><li><a href="#583-本地方法栈native-method-stack">58.3. 本地方法栈（Native Method Stack）</a></li><li><a href="#584-java堆java-heap">58.4. Java堆（Java Heap）</a></li><li><a href="#585-方法区method-area">58.5. 方法区（Method Area）</a></li><li><a href="#586-运行时常量池runtime-constant-pool">58.6. 运行时常量池（Runtime Constant Pool）</a></li></ul></li><li><a href="#59-class文件结构">59. Class文件结构</a><ul><li><a href="#591-魔数与class文件的版本">59.1. 魔数与Class文件的版本</a></li><li><a href="#592-常量池">59.2. 常量池</a></li><li><a href="#593-访问标识">59.3. 访问标识</a></li><li><a href="#594-类索引父类索引与接口索引集合">59.4. 类索引、父类索引与接口索引集合</a></li><li><a href="#595-字段表集合">59.5. 字段表集合</a></li><li><a href="#596-方法表集合">59.6. 方法表集合</a></li><li><a href="#597-属性表集合">59.7. 属性表集合</a></li></ul></li><li><a href="#60-运行时栈帧结构">60. 运行时栈帧结构</a><ul><li><a href="#601-局部变量表local-variable-table">60.1. 局部变量表（Local Variable Table）</a></li><li><a href="#602-操作数栈operand-stack">60.2. 操作数栈（Operand Stack）</a></li><li><a href="#603-动态连接dynamic-linking">60.3. 动态连接（Dynamic Linking）</a></li><li><a href="#604-方法返回地址">60.4. 方法返回地址</a></li><li><a href="#605-附加信息">60.5. 附加信息</a></li></ul></li><li><a href="#61-基于栈的指令集和基于寄存器的指令集">61. 基于栈的指令集和基于寄存器的指令集</a><ul><li><a href="#611-例子">61.1. 例子</a></li><li><a href="#612-区别">61.2. 区别</a></li></ul></li><li><a href="#62-javac编译过程">62. Javac编译过程</a><ul><li><a href="#621-解析与填充符号表过程">62.1. 解析与填充符号表过程</a><ul><li><a href="#6211-解析词法语法分析">62.1.1. 解析（词法、语法分析）</a></li><li><a href="#6212-填充符号表">62.1.2. 填充符号表</a></li></ul></li><li><a href="#622-注解处理器">62.2. 注解处理器</a></li><li><a href="#623-语义分析与字节码生成">62.3. 语义分析与字节码生成</a></li></ul></li><li><a href="#63-什么是jit">63. 什么是JIT</a></li><li><a href="#64-什么是热点代码">64. 什么是热点代码</a></li><li><a href="#65-如何判断热点代码">65. 如何判断热点代码</a></li><li><a href="#66-java与c／c的编译器对比">66. Java与C／C++的编译器对比</a></li><li><a href="#67-java线程的实现">67. Java线程的实现</a></li><li><a href="#68-线程的状态和转换关系">68. 线程的状态和转换关系</a></li><li><a href="#69-对象的访问定位">69. 对象的访问定位</a></li><li><a href="#70-java有哪些语法糖">70. Java有哪些语法糖</a></li><li><a href="#71-java线程安全的实现">71. Java线程安全的实现</a><ul><li><a href="#711-互斥同步mutual-exclusion--synchronization">71.1. 互斥同步（Mutual Exclusion &amp; Synchronization）</a></li><li><a href="#712-非阻塞同步non-blocking-synchronization">71.2. 非阻塞同步（Non-Blocking Synchronization）</a></li><li><a href="#713-无同步方案">71.3. 无同步方案</a></li></ul></li><li><a href="#72-锁优化">72. 锁优化</a><ul><li><a href="#721-自旋锁与自适应自旋">72.1. 自旋锁与自适应自旋</a></li><li><a href="#722-锁消除">72.2. 锁消除</a></li><li><a href="#723-锁粗化">72.3. 锁粗化</a></li><li><a href="#724-轻量级锁">72.4. 轻量级锁</a></li><li><a href="#725-偏向锁">72.5. 偏向锁</a></li></ul></li><li><a href="#73-如何理解java是一门静态多分派且动态单分派的语言">73. 如何理解Java是一门静态多分派且动态单分派的语言？</a></li><li><a href="#74-为什么synchronized修饰的变量推荐定义为final">74. 为什么synchronized修饰的变量推荐定义为final？</a></li><li><a href="#75-object类有哪些方法">75. Object类有哪些方法</a></li><li><a href="#76-sleep和wait的区别">76. <code>sleep()</code>和<code>wait()</code>的区别</a></li><li><a href="#77-java版本历史与特性">77. Java版本历史与特性</a><ul><li><a href="#771-java-8">77.1. Java 8</a></li><li><a href="#772-java-7">77.2. Java 7</a></li><li><a href="#773-java-6">77.3. Java 6</a></li><li><a href="#774-java-5">77.4. Java 5</a></li></ul></li><li><a href="#78-threadlocal原理">78. ThreadLocal原理</a></li><li><a href="#79-hashmapjava-7">79. HashMap（Java 7）</a><ul><li><a href="#791-构造函数">79.1. 构造函数</a></li><li><a href="#792-确定索引位置">79.2. 确定索引位置</a></li><li><a href="#793-put">79.3. <code>put()</code></a><ul><li><a href="#7931-inflatetable">79.3.1. <code>inflateTable()</code></a></li><li><a href="#7932-putfornullkey">79.3.2. <code>putForNullKey()</code></a></li><li><a href="#7933-addentry">79.3.3. <code>addEntry()</code></a></li></ul></li><li><a href="#794-扩容机制">79.4. 扩容机制</a></li><li><a href="#795-get">79.5. <code>get()</code></a></li></ul></li><li><a href="#80-java-8对hashmap的改进">80. Java 8对HashMap的改进</a><ul><li><a href="#801-hash">80.1. <code>hash()</code></a></li><li><a href="#802-红黑树">80.2. 红黑树</a></li><li><a href="#803-resize">80.3. <code>resize()</code></a></li></ul></li><li><a href="#81-如何理解nio">81. 如何理解NIO</a><ul><li><a href="#811-什么是nio">81.1. 什么是NIO</a></li><li><a href="#812-nio与io的区别">81.2. NIO与IO的区别</a></li><li><a href="#813-为什么要使用nio">81.3. 为什么要使用NIO</a></li></ul></li><li><a href="#82-concurrent包">82. concurrent包</a></li><li><a href="#83-当前线程wait后会立即阻塞吗其他线程能够进入同步块吗">83. 当前线程<code>wait()</code>后会立即阻塞吗？其他线程能够进入同步块吗？</a></li><li><a href="#84-为何调用wait可能抛出interruptedexception异常">84. 为何调用<code>wait()</code>可能抛出InterruptedException异常？</a></li><li><a href="#85-调用notify后等待的线程会被立刻唤醒吗">85. 调用<code>notify()</code>后等待的线程会被立刻唤醒吗？</a></li><li><a href="#86-notify和notifyall有什么区别">86. <code>notify()</code>和<code>notifyAll()</code>有什么区别？</a></li><li><a href="#87-notify可能引发死锁">87. <code>notify()</code>可能引发死锁。</a></li><li><a href="#88-线程的sleepyield和join有什么区别">88. 线程的<code>sleep()</code>、<code>yield()</code>和<code>join()</code>有什么区别？</a></li><li><a href="#89-类名class与类名this的区别">89. <code>类名.class</code>与<code>类名.this</code>的区别</a></li></ul><!-- /TOC --><h2 id="1-一个”-java”源文件中是否可以包括多个类"><a href="#1-一个”-java”源文件中是否可以包括多个类" class="headerlink" title="1. 一个”.java”源文件中是否可以包括多个类?"></a>1. 一个”.java”源文件中是否可以包括多个类?</h2><p>可以，但只能有一个public类，而且如果有public类的话，这个文件的名字要和这个类的名字一样。</p><h2 id="2-源文件javac出多个class文件出来是怎么回事"><a href="#2-源文件javac出多个class文件出来是怎么回事" class="headerlink" title="2. 源文件javac出多个class文件出来是怎么回事?"></a>2. 源文件javac出多个class文件出来是怎么回事?</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>这样每个class会是一个.class文件。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这会产生两个.class文件，一个A.class，一个A$B.class。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">xxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        button<span class="token punctuation">.</span><span class="token function">addActionLisener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ActionListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用匿名类，这也会产生多个.class，一个A.class，一个A$1.class。</p><h2 id="3-什么是匿名类？"><a href="#3-什么是匿名类？" class="headerlink" title="3. 什么是匿名类？"></a>3. 什么是匿名类？</h2><pre><code>new 父类构造器(参数列表)|实现接口() {        //匿名内部类的类体部分      }</code></pre><ul><li>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。</li><li>匿名内部类中是不能定义构造函数的。</li><li>匿名内部类中不能存在任何的静态成员变量和静态方法。</li><li>匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul><h2 id="4-switch-case中switch后的变量类型可以是什么？"><a href="#4-switch-case中switch后的变量类型可以是什么？" class="headerlink" title="4. switch case中switch后的变量类型可以是什么？"></a>4. <code>switch case</code>中<code>switch</code>后的变量类型可以是什么？</h2><ul><li>可以转换为int的类型。</li><li>String类型。</li><li>枚举类型。</li></ul><h2 id="5-char型变量与汉字。"><a href="#5-char型变量与汉字。" class="headerlink" title="5. char型变量与汉字。"></a>5. <code>char</code>型变量与汉字。</h2><p>Java中的一个<code>char</code>占2个字节。Java采用unicode，2个字节来表示一个字符，如<code>char x = &#39;编&#39;</code>。</p><p><code>String.getBytes(encoding)</code>方法是获取指定编码的<code>byte</code>数组表示，通常gbk/gb2312是2个字节，utf-8是3个字节。如果不指定<code>encoding</code>则取系统默认的<code>encoding</code>。</p><h2 id="6-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"><a href="#6-使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？" class="headerlink" title="6. 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？"></a>6. 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？</h2><p>使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容 还是可以改变的。</p><h2 id="7-Overload和Override的区别。"><a href="#7-Overload和Override的区别。" class="headerlink" title="7. Overload和Override的区别。"></a>7. Overload和Override的区别。</h2><p>Overload是重载的意思，Override是覆盖的意思，也就是重写。</p><h2 id="8-构造器Constructor是否可被override"><a href="#8-构造器Constructor是否可被override" class="headerlink" title="8. 构造器Constructor是否可被override?"></a>8. 构造器Constructor是否可被override?</h2><p>构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。</p><h2 id="9-Java抽象类（abstract-class）和类（class）的区别？"><a href="#9-Java抽象类（abstract-class）和类（class）的区别？" class="headerlink" title="9. Java抽象类（abstract class）和类（class）的区别？"></a>9. Java抽象类（abstract class）和类（class）的区别？</h2><ul><li>抽象类不能实例化；</li><li>抽象类允许有abstract方法；</li><li>抽象类的非抽象子类必须实现abstract方法。</li></ul><h2 id="10-Java接口与抽象类如何合作"><a href="#10-Java接口与抽象类如何合作" class="headerlink" title="10. Java接口与抽象类如何合作?"></a>10. Java接口与抽象类如何合作?</h2><ul><li>接口可以继承接口。抽象类可以实现（implements）接口，抽象类是可继承实体类，但前提是实体类必须有明确的构造函数。</li><li>一个Java抽象类实现一个接口时，可以不实现接口中所有的方法，但抽象类的子类必须实现。</li></ul><h2 id="11-Java中实现多态的机制是什么？"><a href="#11-Java中实现多态的机制是什么？" class="headerlink" title="11. Java中实现多态的机制是什么？"></a>11. Java中实现多态的机制是什么？</h2><p>多态由重载和重写体现。</p><p>重载通过静态分配实现，即依赖静态类型来定位方法执行的版本。静态分配发生在编译阶段，确定静态分配的动作实际上不是由虚拟机来执行的。</p><p>重写通过动态分配实现，即在运行期根据实际类型确定方法执行版本。Java虚拟机为类载方法区中建立一个虚方法表，虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那么子类的虚方法表里面的地址入口和父类相同方法的入口地址是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。</p><h2 id="12-Java实现了闭包吗？"><a href="#12-Java实现了闭包吗？" class="headerlink" title="12. Java实现了闭包吗？"></a>12. Java实现了闭包吗？</h2><p>Java实现了闭包，但仅实现了值捕获，没有实现引用捕获。</p><h2 id="13-String-s-new-String-quot-xyz-quot-创建了几个String-Object"><a href="#13-String-s-new-String-quot-xyz-quot-创建了几个String-Object" class="headerlink" title="13. String s = new String(&quot;xyz&quot;)创建了几个String Object?"></a>13. <code>String s = new String(&quot;xyz&quot;)</code>创建了几个String Object?</h2><p>两个或一个，<code>&quot;xyz&quot;</code>对应一个对象，这个对象放在字符串常量缓冲区，常量<code>&quot;xyz&quot;</code>不管出现多少遍，都是缓冲区中的那一个。每次<code>new</code>都会创建一个新的对象，但<code>&quot;xyz&quot;</code>仍从缓冲区获取。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String b <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"abc"</span> <span class="token operator">==</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"abc"</span> <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">String</span><span class="token punctuation">(</span>String original<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> original<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> original<span class="token punctuation">.</span>hash<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="14-try-catch-finally-return的执行顺序"><a href="#14-try-catch-finally-return的执行顺序" class="headerlink" title="14. try-catch-finally-return的执行顺序"></a>14. try-catch-finally-return的执行顺序</h2><ol><li>不管是否出现异常，finally块都会执行；</li><li>当try或catch中有return时，finally块仍然会执行；</li><li>若try或catch中执行到return，则finally是在return后的表达式执行完成后才执行的（此时return语句并未返回，而是将要返回的值保存起来，待finally执行完成后返回；如果finally中有return，则返回值以finally中为准。</li></ol><p>参考：<a href="http://blog.csdn.net/aaoxue/article/details/8535754" target="_blank" rel="noopener">Java异常捕获之try-catch-finally-return的执行顺序</a></p><h2 id="15-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法"><a href="#15-当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法" class="headerlink" title="15. 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?"></a>15. 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?</h2><p>若synchronized修饰的是static方法，则获取到的是类锁，否则是对象锁。若其他线程进入的是非synchronized修饰的方法，则可进入；若修饰的方法需要的锁与当前线程相同，则不可进入。</p><h2 id="16-ArrayList和Vector的区别"><a href="#16-ArrayList和Vector的区别" class="headerlink" title="16. ArrayList和Vector的区别"></a>16. ArrayList和Vector的区别</h2><ul><li>ArrayList在容量不够时默认是扩展50% + 1个，Vector是默认扩展1倍。</li><li>Vector提供<code>indexOf(obj, start)</code>方法，ArrayList没有。</li><li>Vector是线程安全的，而ArrayList不是。</li></ul><h2 id="17-HashMap和Hashtable的区别"><a href="#17-HashMap和Hashtable的区别" class="headerlink" title="17. HashMap和Hashtable的区别"></a>17. HashMap和Hashtable的区别</h2><ol><li>HashTable是线程安全的，而HashMap不是。</li><li>HashMap和HashTable都实现了Map接口。</li><li>HashMap继承自AbstractMap，HashTable继承自Dictionary。</li><li>HashMap允许key和value为null，而HashTable不允许。</li></ol><h2 id="18-List，Set，Map是否继承自Collection接口"><a href="#18-List，Set，Map是否继承自Collection接口" class="headerlink" title="18. List，Set，Map是否继承自Collection接口?"></a>18. List，Set，Map是否继承自Collection接口?</h2><p>List，Set是，Map不是</p><h2 id="19-Collection和-Collections的区别。"><a href="#19-Collection和-Collections的区别。" class="headerlink" title="19. Collection和 Collections的区别。"></a>19. Collection和 Collections的区别。</h2><p>Collection是集合类的上级接口，继承于它的接口主要有Set和List。</p><p>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</p><h2 id="20-Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"><a href="#20-Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？" class="headerlink" title="20. Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？"></a>20. Java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？</h2><p>字节流，字符流。字节流继承于<code>InputStream</code>/<code>OutputStream</code>，字符流继承于<code>InputStreamReader</code>/<code>OutputStreamWriter</code>。在java.io包中还有许多其他的流，主要是为了提高性能和使用方便。</p><h2 id="21-描述一下JVM加载class文件的原理机制"><a href="#21-描述一下JVM加载class文件的原理机制" class="headerlink" title="21. 描述一下JVM加载class文件的原理机制?"></a>21. 描述一下JVM加载class文件的原理机制?</h2><p>JVM中类的装载是由ClassLoader和它的子类来实现的，ClassLoader是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p><h2 id="22-能不能自己写个类，也叫java-lang-String？"><a href="#22-能不能自己写个类，也叫java-lang-String？" class="headerlink" title="22. 能不能自己写个类，也叫java.lang.String？"></a>22. 能不能自己写个类，也叫java.lang.String？</h2><p>可以，但在应用的时候，需要用自己的类加载器去加载，否则，系统的类加载器永远只是去加载re.jar包中的那个<code>java.lang.String</code>。</p><h2 id="23-Java中反射的作用是什么"><a href="#23-Java中反射的作用是什么" class="headerlink" title="23. Java中反射的作用是什么?"></a>23. Java中反射的作用是什么?</h2><p>Java反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。Java反射机制主要提供了以下功能：</p><ol><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法；</li><li>在运行时调用任意一个对象的方法；生成动态代理。</li></ol><h2 id="24-成员变量、局部变量、静态变量的区别"><a href="#24-成员变量、局部变量、静态变量的区别" class="headerlink" title="24. 成员变量、局部变量、静态变量的区别"></a>24. 成员变量、局部变量、静态变量的区别</h2><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">成员变量</th><th style="text-align:center">局部变量</th><th style="text-align:center">静态变量</th></tr></thead><tbody><tr><td style="text-align:center">定义位置</td><td style="text-align:center">在类中，方法外</td><td style="text-align:center">方法中，或者方法的形式参数</td><td style="text-align:center">在类中，方法外</td></tr><tr><td style="text-align:center">初始化值</td><td style="text-align:center">有默认初始化值</td><td style="text-align:center">无，先定义，赋值后才能使用</td><td style="text-align:center">有默认初始化值</td></tr><tr><td style="text-align:center">调用方式</td><td style="text-align:center">对象调用</td><td style="text-align:center">—</td><td style="text-align:center">对象调用，类名调用</td></tr><tr><td style="text-align:center">存储位置</td><td style="text-align:center">堆中</td><td style="text-align:center">栈中</td><td style="text-align:center">方法区</td></tr><tr><td style="text-align:center">生命周期</td><td style="text-align:center">与对象共存亡</td><td style="text-align:center">与方法共存亡</td><td style="text-align:center">与类共存亡</td></tr><tr><td style="text-align:center">别名</td><td style="text-align:center">实例变量</td><td style="text-align:center">—</td><td style="text-align:center">类变量</td></tr></tbody></table><h2 id="25-谈谈你对StrongReference、WeakReference和SoftReference的认识"><a href="#25-谈谈你对StrongReference、WeakReference和SoftReference的认识" class="headerlink" title="25. 谈谈你对StrongReference、WeakReference和SoftReference的认识"></a>25. 谈谈你对StrongReference、WeakReference和SoftReference的认识</h2><ul><li>强引用（StrongReference）：就是在代码中普遍存在的，类似<code>Object obj = new Object()</code>这类的引用，只要强引用还存在，GC永远不会回收掉被引用的对象。</li><li>软引用（SoftReference）：用来描述一些还有用但非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常时，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li><li>弱引用（WeakReference）：也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到了下一次GC发生之前。当GC工作时，无论当时内存是否足够，都会回收只被弱引用关联的对象。</li><li>虚引用（PhantomReference）：虚引用也称幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC回收是收到一个系统通知。</li></ul><h2 id="26-与equals-的区别？"><a href="#26-与equals-的区别？" class="headerlink" title="26. ==与equals()的区别？"></a>26. <code>==</code>与<code>equals()</code>的区别？</h2><ul><li><code>==</code>判断两个对象的地址是否相等（对于基本类型判断值是否相等）。</li><li><code>equals()</code>会寻找自身或最近的父类实现，调用其<code>equals()</code>。</li><li>若无任何父类实现<code>equals()</code>，则会调用Object的<code>equals()</code>，其与==相同。</li></ul><h2 id="27-equals-与hashCode-的区别？"><a href="#27-equals-与hashCode-的区别？" class="headerlink" title="27. equals()与hashCode()的区别？"></a>27. <code>equals()</code>与<code>hashCode()</code>的区别？</h2><ul><li><code>equals()</code>仅在显示调用<code>equals()</code>时使用，而<code>hashCode()</code>在如散列表中会自动调用，以判断是否为同一对象。</li><li>重写<code>equals()</code>时必须重写<code>hashCode()</code>，否则会造成不可预料的后果。</li></ul><h2 id="28-Java集合框架示意图"><a href="#28-Java集合框架示意图" class="headerlink" title="28. Java集合框架示意图"></a>28. Java集合框架示意图</h2><h3 id="28-1-集合框架概览"><a href="#28-1-集合框架概览" class="headerlink" title="28.1. 集合框架概览"></a>28.1. 集合框架概览</h3><table><thead><tr><th style="text-align:center">Collection class</th><th style="text-align:center">Allow duplicate</th><th style="text-align:center">Ordered</th><th style="text-align:center">Sorted</th><th style="text-align:center">Thread-safe</th></tr></thead><tbody><tr><td style="text-align:center">ArrayList</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">LinkedList</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">Vector</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:center">HashSet</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">LinkedHashSet</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">TreeSet</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">HashMap</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">LinkedHashMap</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center">Hashtable</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:center">TreeMap</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr></tbody></table><p><img src="/2018/12/31/java1/collections_framework_overview.png" alt="collections framework overview"></p><h3 id="28-2-List"><a href="#28-2-List" class="headerlink" title="28.2. List"></a>28.2. List</h3><p><img src="/2018/12/31/java1/List_API_class_diagram.png" alt="List API class diagram"></p><h3 id="28-3-Set"><a href="#28-3-Set" class="headerlink" title="28.3. Set"></a>28.3. Set</h3><p><img src="/2018/12/31/java1/Set_API_class_diagram.png" alt="Set API class diagram"></p><h3 id="28-4-Map"><a href="#28-4-Map" class="headerlink" title="28.4. Map"></a>28.4. Map</h3><p><img src="/2018/12/31/java1/Map_API_class_diagram.png" alt="Map API class diagram"></p><h3 id="28-5-Queue"><a href="#28-5-Queue" class="headerlink" title="28.5. Queue"></a>28.5. Queue</h3><p><img src="/2018/12/31/java1/Queue_API_class_diagram.png" alt="Queue API class diagram"></p><h2 id="29-Error和Exception的区别"><a href="#29-Error和Exception的区别" class="headerlink" title="29. Error和Exception的区别"></a>29. Error和Exception的区别</h2><p>Error类和Exception类的父类都是throwable类，他们的区别是：</p><ul><li>Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和和预防，遇到这样的错误，建议让程序终止。</li><li>Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。</li></ul><h2 id="30-用户线程（User-Thread）与守护线程（Daemon-Thread）"><a href="#30-用户线程（User-Thread）与守护线程（Daemon-Thread）" class="headerlink" title="30. 用户线程（User Thread）与守护线程（Daemon Thread）"></a>30. 用户线程（User Thread）与守护线程（Daemon Thread）</h2><ul><li>JVM中存在两种线程：用户线程和守护线程</li><li>当线程中只剩下守护线程时JVM就会退出，反之还有任意一个用户线程在，JVM都不会退出。</li><li><code>thread.setDaemon(true)</code>必须在<code>thread.start()</code>之前设置，否则会抛出IllegalThreadStateException异常。</li><li>在守护线程中产生的线程也是守护线程。</li></ul><h2 id="31-Java内存模型"><a href="#31-Java内存模型" class="headerlink" title="31. Java内存模型"></a>31. Java内存模型</h2><p>Java内存模型（Java Memory Model，JMM）用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存中和从内存中取出变量这样的底层细节（此处的变量与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数）。</p><h3 id="31-1-主内存与工作内存"><a href="#31-1-主内存与工作内存" class="headerlink" title="31.1. 主内存与工作内存"></a>31.1. 主内存与工作内存</h3><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><p><img src="/2018/12/31/java1/java_memory_model.jpg" alt="Java Memory Model"></p><h3 id="31-2-内存间交互操作"><a href="#31-2-内存间交互操作" class="headerlink" title="31.2. 内存间交互操作"></a>31.2. 内存间交互操作</h3><p>关于主内存与工作内存之间具体的交互协议，Java内存模型定义了8种操作来完成，虚拟机保证每种操作都是原子的、不可再分的：</p><ul><li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>如果要把一个变量从主内存复制到工作内存，就要顺序执行read和load操作；如果要把变量从工作内存同步到主内存，就要顺序执行store和write操作。Java内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。</p><p>Java内存模型还规定了在执行时满足的规则：</p><ul><li>不允许read和load，store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起会写了但主内存不接受的情况出现。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li><li>不允许一个线程无原因地(没有发生任何assign操作)把数据从线程的工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量，换句话说就是对一个变量实施use和store操作之前，必须先执行了load和assign操作。</li><li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li><li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load操作初始化变量的值。</li><li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许unlock一个被其它线程锁定住的变量。</li><li>对一个变量执行unlock之前，必须先把此变量同步回主内存中。</li></ul><p>这8种内存访问操作以及上述规则限制，再加上volatile的一些特殊规定，就完全确定了Java程序中哪些内存访问操作在并发下是安全的。</p><h3 id="31-3-对volatile型变量的特殊规则"><a href="#31-3-对volatile型变量的特殊规则" class="headerlink" title="31.3. 对volatile型变量的特殊规则"></a>31.3. 对volatile型变量的特殊规则</h3><p>volatile是Java虚拟机提供的最轻量级的同步机制。当一个变量定义为volatile之后，它将具备两种特性：</p><ul><li>保证此变量对所有线程的可见性。这里“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</li><li>禁止指令重排优化。</li></ul><p>假定T表示一个线程，V和W分别表示两个volatile变量，那么在进行read、load、use、assign、store和write时需要满足以下三条规则：</p><ul><li>只有当线程T对变量V执行的前一个动作是load时，T才能对V执行use；并且，只有当T对V执行的后一个动作是use时，T才能对V执行load。T对V的use动作可以认为是和线程T对V的load，read动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值）。</li><li>只有当线程T对变量V执行的前一个动作是assign时，T才能对V执行store动作；并且，只有当T对变量V执行的后一个动作是store时，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可认为是和线程T对变量V的store，write动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改）。</li><li>假定动作A是线程T对变量V实施的use或assign操作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的变量W的read或write动作。如果A先于B，那P先于Q（这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同）。</li></ul><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><p><strong>LoadLoad屏障</strong></p><p>序列：Load1, LoadLoad, Load2</p><p>确保Load1所要读入的数据能够在被Load2和后续的load指令访问前读入。通常能执行预加载指令或/和支持乱序处理的处理器中需要显式声明Loadload屏障，因为在这些处理器中正在等待的加载指令能够绕过正在等待存储的指令。而对于总是能保证处理顺序的处理器上，设置该屏障相当于无操作。</p><p><strong>StoreStore屏障</strong></p><p>序列：Store1, StoreStore, Store2</p><p>确保Store1的数据在Store2以及后续Store指令操作相关数据之前对其它处理器可见（例如向主存刷新数据）。通常情况下，如果处理器不能保证从写缓冲或/和缓存向其它处理器和主存中按顺序刷新数据，那么它需要使用StoreStore屏障。</p><p><strong>LoadStore屏障</strong></p><p>序列：Load1, LoadStore, Store2</p><p>确保Load1的数据在Store2和后续Store指令被刷新之前读取。在等待Store指令可以越过loads指令的乱序处理器上需要使用LoadStore屏障。</p><p><strong>StoreLoad屏障</strong></p><p>序列: Store1, StoreLoad, Load2</p><p>确保Store1的数据在被Load2和后续的Load指令读取之前对其他处理器可见。StoreLoad屏障可以防止一个后续的load指令 不正确的使用了Store1的数据，而不是另一个处理器在相同内存位置写入一个新数据。</p><h3 id="31-4-原子性、可见性与有序性"><a href="#31-4-原子性、可见性与有序性" class="headerlink" title="31.4. 原子性、可见性与有序性"></a>31.4. 原子性、可见性与有序性</h3><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。</p><h4 id="31-4-1-原子性（Atomicity）"><a href="#31-4-1-原子性（Atomicity）" class="headerlink" title="31.4.1. 原子性（Atomicity）"></a>31.4.1. 原子性（Atomicity）</h4><p>由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的。</p><p>如果还需要更大范围的原子性保证，Java内存模型还提供了lock和unlock操作，反映到字节码指令就是monitorenter和monitorexit，反映到Java代码中就是synchronized关键字。</p><h4 id="31-4-2-可见性（Visibility）"><a href="#31-4-2-可见性（Visibility）" class="headerlink" title="31.4.2. 可见性（Visibility）"></a>31.4.2. 可见性（Visibility）</h4><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介来实现可见性的，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程时操作变量的可见性，而普通变量则不能保证这一点。</p><p>synchronized和final关键字也能实现可见性，synchronized的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”这条规则获得的。另外，final关键字也可以实现可见性，因为被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this传递出去，那在其他线程中就能看见final字段的值。</p><h4 id="31-4-3-有序性（Ordering）"><a href="#31-4-3-有序性（Ordering）" class="headerlink" title="31.4.3. 有序性（Ordering）"></a>31.4.3. 有序性（Ordering）</h4><p>Java内存模型的有序性可以总结为一句话，如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。<br>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则规定了持有同一个锁的两个同步块只能串行地进入。</p><h3 id="31-5-先行发生原则"><a href="#31-5-先行发生原则" class="headerlink" title="31.5. 先行发生原则"></a>31.5. 先行发生原则</h3><p>对于有序性，Java语言有“先行发生”（happends-before）的原则，它是判断数据是否存在竞争、线程是否安全的主要依据。依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p><p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以随意地进行重排：</p><ul><li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。</li><li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。</li><li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作。</li><li>线程启动规则（Thread Start Rule）：Thread对象的<code>start()</code>方法先行发生于此线程的每一个动作。</li><li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测。</li><li>线程中断规则（Thread Interruption Rule）：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li><li>对象终结规则（Finalizer Rule）：一个对象初始化完成(构造方法执行完成)先行发生于它的<code>finalize()</code>方法的开始。</li><li>传递性（Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li></ul><p>一个操作“时间上的先发生”不代表这个操作会是“先行发生”，一个操作“先行发生”不代表这个操作会是“时间上的先发生”。</p><h2 id="32-Java中的BIO，NIO，AIO分别是什么"><a href="#32-Java中的BIO，NIO，AIO分别是什么" class="headerlink" title="32. Java中的BIO，NIO，AIO分别是什么?"></a>32. Java中的BIO，NIO，AIO分别是什么?</h2><h3 id="32-1-BIO（synchronous-Blocking-IO，同步阻塞IO）"><a href="#32-1-BIO（synchronous-Blocking-IO，同步阻塞IO）" class="headerlink" title="32.1. BIO（synchronous Blocking IO，同步阻塞IO）"></a>32.1. BIO（synchronous Blocking IO，同步阻塞IO）</h3><p>如Apache，Tomcat。服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p><h3 id="32-2-NIO（synchronous-Non-blocking-IO，同步非阻塞IO）"><a href="#32-2-NIO（synchronous-Non-blocking-IO，同步非阻塞IO）" class="headerlink" title="32.2. NIO（synchronous Non blocking IO，同步非阻塞IO）"></a>32.2. NIO（synchronous Non blocking IO，同步非阻塞IO）</h3><p>如Nginx，Netty。服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p><h3 id="32-3-AIO（Asynchronous-non-blocking-IO，异步非阻塞IO）"><a href="#32-3-AIO（Asynchronous-non-blocking-IO，异步非阻塞IO）" class="headerlink" title="32.3. AIO（Asynchronous non blocking IO，异步非阻塞IO）"></a>32.3. AIO（Asynchronous non blocking IO，异步非阻塞IO）</h3><p>还不是特别成熟。服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理，</p><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p><h2 id="33-Serializable接口和序列化与反序列化"><a href="#33-Serializable接口和序列化与反序列化" class="headerlink" title="33. Serializable接口和序列化与反序列化"></a>33. Serializable接口和序列化与反序列化</h2><ul><li>Serializable接口没有任何方法</li><li>一个类只要实现了Serializable接口，即可被序列化</li><li>实现Serializable接口的类，在序列化时不能有不可被序列化的成员变量</li><li>通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化</li><li>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化ID是否一致（即<code>private static final long serialVersionUID</code>）</li><li>transient关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中；在被反序列化后，transient变量的值被设为初始值。</li><li>在序列化过程中，如果被序列化的类中定义了<code>writeObject()</code>和<code>readObject()</code>方法，虚拟机就会试图调用对象类里的<code>writeObject()</code>和<code>readObject()</code>方法，进行用户自定义的序列化和反序列化。如果没有这样的方法，则默认调用是ObjectOutputStream的<code>defaultWriteObject()</code>方法以及ObjectInputStream的<code>defaultReadObject()</code>方法。</li></ul><p>序列化算法一般会按步骤做如下事情：</p><ul><li>将对象实例相关的类元数据输出。</li><li>递归地输出类的超类描述直到不再有超类。</li><li>类元数据完了以后，开始从最顶层的超类开始输出对象实例的实际数据值。</li><li>从上至下递归输出实例的数据。</li></ul><h2 id="34-ArrayList的subList-方法注意事项"><a href="#34-ArrayList的subList-方法注意事项" class="headerlink" title="34. ArrayList的subList()方法注意事项"></a>34. ArrayList的<code>subList()</code>方法注意事项</h2><p><code>subList()</code>方法接口为</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">subList</span><span class="token punctuation">(</span><span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>其返回的是原List从[fromIndex,toIndex)之间的一部分的视图（如ArrayList的内部类SubList），实际依赖于原List，且对subList的修改也会作用到原List中。</p><p>ArrayList的<code>subList()</code>结果不可以强制转换为ArrayList（否则会抛出ClassCastException异常）。</p><pre class=" language-java"><code class="language-java"><span class="token function">SubList</span><span class="token punctuation">(</span>AbstractList<span class="token operator">&lt;</span>E<span class="token operator">></span> parent<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parentOffset <span class="token operator">=</span> fromIndex<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>offset <span class="token operator">=</span> offset <span class="token operator">+</span> fromIndex<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> toIndex <span class="token operator">-</span> fromIndex<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>modCount <span class="token operator">=</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>modCount<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="35-Arrays的asList-方法注意事项"><a href="#35-Arrays的asList-方法注意事项" class="headerlink" title="35. Arrays的asList()方法注意事项"></a>35. Arrays的<code>asList()</code>方法注意事项</h2><p><code>Arrays.asList()</code>可将数组转换为集合，但转换得到的集合不能使用如<code>add()</code>、<code>remove()</code>和<code>clear()</code>等方法（否则会抛出UnsupportedOperationException异常）。</p><p>原因是<code>asList()</code>返回的是Arrays的内部类ArrayList，使用到的是适配器模式，并未实现集合的某些修改方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">asList</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token function">ArrayList</span><span class="token punctuation">(</span>E<span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token operator">==</span>null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> array<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="36-Comparator注意事项"><a href="#36-Comparator注意事项" class="headerlink" title="36. Comparator注意事项"></a>36. Comparator注意事项</h2><p>Comparator要满足自反性、传递性和对称性，否则会抛出IllegalArgumentException。</p><ul><li>自反性：x，y的比较结果和y，x的比较结果相反。</li><li>传递性：x &gt; y，y &gt; z，则x &gt; z。</li><li>对称性：x = y，则x，z的比较结果和y，z比较结果相同。</li></ul><h2 id="37-HashMap多线程下死循环问题"><a href="#37-HashMap多线程下死循环问题" class="headerlink" title="37. HashMap多线程下死循环问题"></a>37. HashMap多线程下死循环问题</h2><p>多线程<code>put()</code>时触发<code>resize()</code>，进而导致新建Entry数组，并将之前数组中每个链表都重新hash到新的数组中；由于多线程下Entry数组私有，但Entry链表中的元素共享，且由于采用头插法hash到新的链表数组中，导致链表出现环。</p><p>而当<code>get()</code>到此环，而<code>get()</code>的hash值又与此环的任何元素都不相等时，则出现死循环。</p><p><a href="http://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">疫苗：Java HashMap的死循环 | | 酷 壳 - CoolShell</a></p><h2 id="38-什么是ConcurrentHashMap"><a href="#38-什么是ConcurrentHashMap" class="headerlink" title="38. 什么是ConcurrentHashMap"></a>38. 什么是ConcurrentHashMap</h2><p>ConcurrentHashMap类中包含两个静态内部类：HashEntry和Segment。HashEntry用来封装映射表的键/值对；Segment用来充当锁的角色，每个Segment对象守护整个散列映射表的若干个桶。每个桶是由若干个HashEntry对象链接起来的链表。一个ConcurrentHashMap实例中包含由若干个Segment对象组成的数组。</p><p>Segment类继承于ReentrantLock类，从而使得Segment对象能充当锁的角色。每个Segment对象用来守护其（成员对象table中）包含的若干个桶。</p><h2 id="39-Map类集合k／V能否存储null值的情况"><a href="#39-Map类集合k／V能否存储null值的情况" class="headerlink" title="39. Map类集合k／V能否存储null值的情况"></a>39. Map类集合k／V能否存储null值的情况</h2><table><thead><tr><th style="text-align:center">集合类</th><th style="text-align:center">Key允许为null</th><th style="text-align:center">Value允许为null</th><th style="text-align:center">Super</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Hashtable</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">Dictionary</td><td style="text-align:center">线程安全</td></tr><tr><td style="text-align:center">ConcurrentHashMap</td><td style="text-align:center">No</td><td style="text-align:center">No</td><td style="text-align:center">AbstractMap</td><td style="text-align:center">分段锁技术</td></tr><tr><td style="text-align:center">TreeMap</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">AbstractMap</td><td style="text-align:center">线程不安全</td></tr><tr><td style="text-align:center">HashMap</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">AbstractMap</td><td style="text-align:center">线程不安全</td></tr></tbody></table><h2 id="40-SimpleDataFormat线程安全吗？"><a href="#40-SimpleDataFormat线程安全吗？" class="headerlink" title="40. SimpleDataFormat线程安全吗？"></a>40. SimpleDataFormat线程安全吗？</h2><p>SimpleDataFormat线程不安全，一般不要定义为static变量，如果定义为static则必须加锁，或者使用DataUtils工具类。</p><h2 id="41-Timer可以用来并行处理定时任务吗？"><a href="#41-Timer可以用来并行处理定时任务吗？" class="headerlink" title="41. Timer可以用来并行处理定时任务吗？"></a>41. Timer可以用来并行处理定时任务吗？</h2><p>一个Timer对象仅有一个线程，如果向Timer提交多个TimerTask，且某个TimerTask很耗时，则其他TimerTask即使到了执行时间，也仍会等待之前的task执行完毕；甚至，如果某个TimerTask抛出异常导致线程终止，则其后的TimerTask将不会执行。</p><h2 id="42-可以在多线程下使用Random吗？"><a href="#42-可以在多线程下使用Random吗？" class="headerlink" title="42. 可以在多线程下使用Random吗？"></a>42. 可以在多线程下使用Random吗？</h2><p>Random是线程安全的（由AtomicLong实现），但在多线程时可能遇到效率问题。Random的seed是AtomicLong类型，其使用CAS（compare-and-set）操作来更新；CAS在资源高度竞争时表现会变得很糟糕。</p><p>ThreadLocalRandom克服了如上Random的缺陷。</p><h2 id="43-Thread-join-是如何实现的？"><a href="#43-Thread-join-是如何实现的？" class="headerlink" title="43. Thread.join()是如何实现的？"></a>43. <code>Thread.join()</code>是如何实现的？</h2><p><code>join()</code>方法是通过<code>wait()</code>实现的。当当前线程调用<code>otherThread.join()</code>时，当前线程会获得对象otherThread的锁，调用该对象的<code>wait()</code>方法开始等待；直到otherThread唤醒当前线程。而当otherThread退出时，会在native方法中调<code>notifyAll()</code>从而唤醒当前线程，当前线程继续运行。</p><h2 id="44-GC中可回收对象的判定方法"><a href="#44-GC中可回收对象的判定方法" class="headerlink" title="44. GC中可回收对象的判定方法"></a>44. GC中可回收对象的判定方法</h2><h3 id="44-1-引用计数法"><a href="#44-1-引用计数法" class="headerlink" title="44.1. 引用计数法"></a>44.1. 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>其优点是简单，高效；缺点是很难处理循环引用。</p><h3 id="44-2-可达性分析算法"><a href="#44-2-可达性分析算法" class="headerlink" title="44.2. 可达性分析算法"></a>44.2. 可达性分析算法</h3><p>通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><p>可作为GC Roots的对象包括：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul><h2 id="45-垃圾收集算法"><a href="#45-垃圾收集算法" class="headerlink" title="45. 垃圾收集算法"></a>45. 垃圾收集算法</h2><h3 id="45-1-标记——清除算法"><a href="#45-1-标记——清除算法" class="headerlink" title="45.1. 标记——清除算法"></a>45.1. 标记——清除算法</h3><p>标记——清除算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象（标记过程即使用可回收对象的判定方法）。</p><p>主要有两方面的不足：</p><ul><li>效率问题，标记和清除两个过程的效率都不高。</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h3 id="45-2-复制算法"><a href="#45-2-复制算法" class="headerlink" title="45.2. 复制算法"></a>45.2. 复制算法</h3><p>复制算法将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上，然后把已使用过的内存空间一次性清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按序分配内存即可，实现简单，运行高效。</p><p>主要的不足是将内存缩小为了原来的一半，代价较高。</p><h3 id="45-3-标记——整理算法"><a href="#45-3-标记——整理算法" class="headerlink" title="45.3. 标记——整理算法"></a>45.3. 标记——整理算法</h3><p>标记——整理算法的标记过程仍然与标记——清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h3 id="45-4-分代收集算法"><a href="#45-4-分代收集算法" class="headerlink" title="45.4. 分代收集算法"></a>45.4. 分代收集算法</h3><p>分代收集算法，即：分代分配，分代回收。对象将根据存活的时间被分为：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）。</p><h4 id="45-4-1-年轻代"><a href="#45-4-1-年轻代" class="headerlink" title="45.4.1. 年轻代"></a>45.4.1. 年轻代</h4><p>年轻代可以分为3个区域：Eden区和两个存活区（Survivor 0、Survivor 1）。</p><ol><li>绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；</li><li>最初一次，当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）；</li><li>下次Eden区满了，再执行一次Minor GC，将消亡的对象清理掉，将存活的对象复制到Survivor1中，然后清空Eden区；</li><li>将Survivor0中消亡的对象清理掉，将其中可以晋级的对象晋级到Old区，将存活的对象也复制到Survivor1区，然后清空Survivor0区；</li><li>当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。</li></ol><p>这种垃圾回收的方式就是复制算法。由于绝大部分的对象都是短命的，甚至存活不到Survivor中，所以，Eden区与Survivor的比例较大，HotSpot默认是8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor + Eden中存活下来的内存超过了10%，则需要将一部分对象分配到老年代。</p><h4 id="45-4-2-年老代"><a href="#45-4-2-年老代" class="headerlink" title="45.4.2. 年老代"></a>45.4.2. 年老代</h4><p>对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫Full GC。</p><p>年老代的垃圾回收方式是标记——整理算法。</p><h4 id="45-4-3-永久代"><a href="#45-4-3-永久代" class="headerlink" title="45.4.3. 永久代"></a>45.4.3. 永久代</h4><p>永久代的回收并不是必须的。</p><p>其回收有两种：常量池中的常量和无用的类信息。常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：</p><ul><li>类的所有实例都已经被回收；</li><li>加载类的ClassLoader已经被回收；</li><li>类对象的Class对象没有被引用（即没有通过反射引用该类的地方）。</li></ul><h2 id="46-Java是值传递还是引用传递？"><a href="#46-Java是值传递还是引用传递？" class="headerlink" title="46. Java是值传递还是引用传递？"></a>46. Java是值传递还是引用传递？</h2><p>Java中方法参数传递方式是按值传递。</p><ul><li>如果参数是基本类型，传递的是基本类型的字面量值的拷贝。</li><li>如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。</li></ul><h2 id="47-线程同步的方法"><a href="#47-线程同步的方法" class="headerlink" title="47. 线程同步的方法"></a>47. 线程同步的方法</h2><ul><li>同步方法：synchronized关键字修饰的方法。</li><li>同步代码块：synchronized关键字修饰的语句块。</li><li>volatile关键字。</li><li>可重入锁：ReentrantLock类是可重入、互斥、实现了Lock接口的锁。</li><li>ThreadLocal。</li></ul><h2 id="48-Java创建线程的方式"><a href="#48-Java创建线程的方式" class="headerlink" title="48. Java创建线程的方式"></a>48. Java创建线程的方式</h2><h3 id="48-1-继承Thread类创建线程类"><a href="#48-1-继承Thread类创建线程类" class="headerlink" title="48.1. 继承Thread类创建线程类"></a>48.1. 继承Thread类创建线程类</h3><ol><li>定义Thread类的子类，并重写该类的<code>run()</code>方法，该<code>run()</code>方法的方法体就代表了线程要完成的任务。因此把<code>run()</code>方法称为执行体。</li><li>创建Thread子类的实例，即创建了线程对象。</li><li>调用线程对象的<code>start()</code>方法来启动该线程。</li></ol><h3 id="48-2-通过Runnable接口创建线程类"><a href="#48-2-通过Runnable接口创建线程类" class="headerlink" title="48.2. 通过Runnable接口创建线程类"></a>48.2. 通过Runnable接口创建线程类</h3><ol><li>定义runnable接口的实现类，并重写该接口的<code>run()</code>方法，该<code>run()</code>方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。</li><li>调用线程对象的<code>start()</code>方法来启动该线程。</li></ol><h3 id="48-3-通过Callable和Future创建线程"><a href="#48-3-通过Callable和Future创建线程" class="headerlink" title="48.3. 通过Callable和Future创建线程"></a>48.3. 通过Callable和Future创建线程</h3><ol><li><p>创建Callable接口的实现类，并实现<code>call()</code>方法，该<code>call()</code>方法将作为线程执行体，并且有返回值。</p></li><li><p>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的<code>call()</code>方法的返回值。</p></li><li><p>使用FutureTask对象作为Thread对象的target创建并启动新线程。</p></li><li><p>调用FutureTask对象的<code>get()</code>方法来获得子线程执行结束后的返回值。</p></li></ol><h2 id="49-线程池原理"><a href="#49-线程池原理" class="headerlink" title="49. 线程池原理"></a>49. 线程池原理</h2><p>java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，其构造函数为</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                            <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                            <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                            TimeUnit unit<span class="token punctuation">,</span>                            BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                            ThreadFactory threadFactory<span class="token punctuation">,</span>                            RejectedExecutionHandler handler<span class="token punctuation">)</span></code></pre><ul><li><code>corePoolSize</code>：核心池大小，默认情况下线程不会超过核心大小。</li><li><code>maximumPoolSize</code>：最大线程数，当达到一定负载时，线程数会超过核心数，但始终小于最大线程数。当负载较轻会回收线程至核心池数量。</li><li><code>keepAliveTime</code>：表示线程没有任务执行时，的存活时间。默认情况，当线程数大于核心小于最大数量时才会启用；如果调用allowCoreThreadTimeOut(boolean)方法，线程数下界为0。</li><li><code>unit</code>：<code>keepAliveTime</code>的时间单位。</li><li><code>workQueue</code>：阻塞队列，用来存储等待执行的任务。<ul><li>ArrayBlockingQueue：基于数组的先进先出，创建时必须指定大小。</li><li>PriorityBlockingQueue：优先级队列。</li><li>LinkedBlockingQueue：基于链表的队列，默认长度为Integer.MAX_VALUE。</li><li>SynchronousQueue：不保存任务，直接创建新线程。</li></ul></li><li><code>threadFactory</code>：线程工厂。</li><li><code>handler</code>：对拒绝任务的处理策略，四种参数。<ul><li>AbortPolicy：丢弃任务并抛异常。</li><li>DiscardPolicy：丢弃任务不抛异常。</li><li>DiscardOldestPolicy：丢弃最前面的任务。</li><li>CallerRunsPolicy：交由调用线程处理。</li></ul></li></ul><p>运行流程：</p><ol><li>接收到任务。</li><li>判断已存在线程数是否大于等于核心线程数，如果不是，则创建新线程执行任务；否则转3。</li><li>判断任务队列是否有界，如果不是，将任务加入队列中；否则转4。</li><li>判断任务队列是否已满，如果不是，将任务加入队列中；否则转5。</li><li>判断已存在线程数是否等于最大线程数，如果不是，则创建新线程执行任务；否则转6。</li><li>拒绝该任务。</li></ol><p>参考：<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">Java并发编程：线程池的使用 - 海 子 - 博客园</a></p><h2 id="50-类与类加载器的关系"><a href="#50-类与类加载器的关系" class="headerlink" title="50. 类与类加载器的关系"></a>50. 类与类加载器的关系</h2><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性；每个类加载器，都拥有一个独立的类名称空间。</p><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><p>这里所指的“相等”，包括代表类的class对象的<code>equals()</code>方法、<code>isAssignableFrom()</code>方法、<code>isInstance()</code>方法的返回结果，也包括使用<code>instanceof</code>关键字做对象所属关系判定等情况。</p><h2 id="51-双亲委派模型"><a href="#51-双亲委派模型" class="headerlink" title="51. 双亲委派模型"></a>51. 双亲委派模型</h2><p>从Java虚拟机角度来看，只存在两种类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：这个类加载器使用C++语言实现，是虚拟机自身的一部分。</li><li>所有其他类加载器：这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</li></ul><p>从Java开发人员角度来看，绝大多数Java程序都会用到以下3种系统提供的类加载器：</p><ul><li>启动类加载器（Bootstrap ClassLoader）：负责将存放在&lt;JAVA_HOME&gt;/lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按文件名识别，如rt.jar）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。</li><li>扩展类加载器（Extension ClassLoader）：由sun.misc.Launcher$ExtClassLoader实现，负责加载JAVA_HOME&gt;/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库。开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器（Application ClassLoader）：由sun.misc.Launcher$AppClassLoader实现，由于这个类加载器是ClassLoader中的<code>getSystemClassLoader()</code>方法的返回值，所以一般也称它为系统类加载器。负责加载用户类路径（ClassPath)上所指定的类库。开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul><p><img src="/2018/12/31/java1/parents_delegation_model.png" alt="Parents Delegation Model"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// If still not found, then invoke findClass in order</span>                <span class="token comment" spellcheck="true">// to find the class.</span>                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子类加载器才会尝试自己去加载。</p><h2 id="52-如何自定义类加载器"><a href="#52-如何自定义类加载器" class="headerlink" title="52. 如何自定义类加载器"></a>52. 如何自定义类加载器</h2><p>继承ClassLoader类，实现<code>findClass()</code>方法，调用父类的<code>defineClass()</code>方法，返回加载后的类。</p><p>需要被加载的类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>tomcat<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>自定义类加载器：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>tomcat<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ByteArrayOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>File<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileInputStream<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//类加载器的名称</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//类存放的路径</span>    <span class="token keyword">private</span> String classpath <span class="token operator">=</span> <span class="token string">"/demo/target/classes/com/example/tomcat/"</span><span class="token punctuation">;</span>    <span class="token function">MyClassLoader</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">MyClassLoader</span><span class="token punctuation">(</span>ClassLoader parent<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 重写findClass方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token function">loadClassData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">loadClassData</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"//"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            FileInputStream is <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>classpath <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ByteArrayOutputStream baos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>b <span class="token operator">=</span> is<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                baos<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> baos<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        MyClassLoader my <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClassLoader</span><span class="token punctuation">(</span><span class="token string">"myLoader"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> loadClass <span class="token operator">=</span> my<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"com.example.tomcat.Foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Foo cast <span class="token operator">=</span> <span class="token punctuation">(</span>Foo<span class="token punctuation">)</span> loadClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cast<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="53-类的生命周期"><a href="#53-类的生命周期" class="headerlink" title="53. 类的生命周期"></a>53. 类的生命周期</h2><ul><li>加载（Loading）</li><li>连接（Linking）<ul><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li></ul></li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><h2 id="54-类初始化的时机"><a href="#54-类初始化的时机" class="headerlink" title="54. 类初始化的时机"></a>54. 类初始化的时机</h2><ul><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需先触发其初始化。生成这4条指令的最常见的Java代码场景是：<ul><li>使用new关键字实例化对象的时候</li><li>读取或设置一个类的静态字段的时候</li><li>调用一个类的静态方法的时候</li></ul></li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需先触发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含<code>main()</code>方法的那个类），虚拟机会先初始化这个主类。</li></ul><h2 id="55-类的加载过程"><a href="#55-类的加载过程" class="headerlink" title="55. 类的加载过程"></a>55. 类的加载过程</h2><h3 id="55-1-加载"><a href="#55-1-加载" class="headerlink" title="55.1. 加载"></a>55.1. 加载</h3><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li></ol><h3 id="55-2-连接"><a href="#55-2-连接" class="headerlink" title="55.2. 连接"></a>55.2. 连接</h3><h4 id="55-2-1-验证"><a href="#55-2-1-验证" class="headerlink" title="55.2.1. 验证"></a>55.2.1. 验证</h4><p>验证的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致完成4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><h5 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h5><p>即验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。主要包括以下验证点：</p><ul><li>是否以魔术0xCAFEBABE开头。</li><li>主、次版本号是否在当前虚拟机处理范围之内。</li><li>常量池的常量中是否有不被支持的常量类型（检查常亮tag标识）。</li><li>指向常亮的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li><li>CONSTANT_Uft8_info型的常量中是否有不符合UTF8编码的数据。</li><li>Class文件中各个部分及文件本身是否有被删除或附加的其他信息。</li><li>……</li></ul><h5 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h5><p>即对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。这个阶段可能包括以下验证点：</p><ul><li>这个类是否有父类（除了java.lang.Object之外，所有的类都应该有父类）。</li><li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li><li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li><li>类中的字段、方法是否与父类产生矛盾（如覆盖了父类的final字段，或出现不符合规则的方法重载，如方法参数一致，但返回值类型不同）。</li><li>……</li></ul><h5 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h5><p>即通过数据流河控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，如：</p><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li><li>保证方法体中的类型转换是有效的，例如不能把父类对象赋值给子类数据类型。</li></ul><h5 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h5><p>即对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。发生在虚拟机将符号引用转化为直接引用的时候，通常包括以下几个验证点：</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li><li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可以被当前类访问。</li><li>……</li></ul><h4 id="55-2-2-准备"><a href="#55-2-2-准备" class="headerlink" title="55.2.2. 准备"></a>55.2.2. 准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括示例变量。</p><h4 id="55-2-3-解析"><a href="#55-2-3-解析" class="headerlink" title="55.2.3. 解析"></a>55.2.3. 解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p><h3 id="55-3-初始化"><a href="#55-3-初始化" class="headerlink" title="55.3. 初始化"></a>55.3. 初始化</h3><p>初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。即初始化阶段是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p><ul><li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {}块）中语句合并产生。编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但不能访问。</li><li><code>&lt;clinit&gt;()</code>方法与类的构造函数（或者说实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类<code>&lt;clinit&gt;()</code>方法已经执行完毕。</li><li>由于父类的<code>&lt;clinit&gt;()</code>方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</li><li><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。</li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li><li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。</li></ul><h2 id="56-符号引用和直接引用的区别"><a href="#56-符号引用和直接引用的区别" class="headerlink" title="56. 符号引用和直接引用的区别"></a>56. 符号引用和直接引用的区别</h2><ul><li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要使用时能无歧义地定位到目标即可。符号饮用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</li><li>直接引用（Direct References）：直接引用可以时直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。</li></ul><h2 id="57-如何理解平台无关性"><a href="#57-如何理解平台无关性" class="headerlink" title="57. 如何理解平台无关性"></a>57. 如何理解平台无关性</h2><p>虚拟机和字节码存储格式是实现语言无关性的基础。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其它辅助信息。任何一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。</p><h2 id="58-运行时数据区域"><a href="#58-运行时数据区域" class="headerlink" title="58. 运行时数据区域"></a>58. 运行时数据区域</h2><p>Java虚拟机在执行Java程序过程中会把内存区域划分为若干个不同的数据区域，这些区域各有各自的用途、创建和销毁时间。有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。</p><p><img src="/2018/12/31/java1/java_runtime_data_areas.png" alt="Java Runtime Data Areas"></p><h3 id="58-1-程序计数器（Program-Counter-Register）"><a href="#58-1-程序计数器（Program-Counter-Register）" class="headerlink" title="58.1. 程序计数器（Program Counter Register）"></a>58.1. 程序计数器（Program Counter Register）</h3><p>程序计数器占用较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说就是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</p><p>如果线程正在执行Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，则这个计数器则为空。</p><h3 id="58-2-Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#58-2-Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="58.2. Java虚拟机栈（Java Virtual Machine Stacks）"></a>58.2. Java虚拟机栈（Java Virtual Machine Stacks）</h3><p>虚拟机栈也是线程私有，而且生命周期与线程相同，每个Java方法在执行的时候都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><p>Java虚拟机规范中，对该区域规定了两种异常情况：</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，讲抛出StackOverflowError异常；</li><li>虚拟机栈可以动态拓展，当扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</li></ul><h3 id="58-3-本地方法栈（Native-Method-Stack）"><a href="#58-3-本地方法栈（Native-Method-Stack）" class="headerlink" title="58.3. 本地方法栈（Native Method Stack）"></a>58.3. 本地方法栈（Native Method Stack）</h3><p>本地方法栈的作用与虚拟机栈作用是非常类似的。虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><h3 id="58-4-Java堆（Java-Heap）"><a href="#58-4-Java堆（Java-Heap）" class="headerlink" title="58.4. Java堆（Java Heap）"></a>58.4. Java堆（Java Heap）</h3><p>对大多数应用来说，Java堆（Heap）是Java虚拟机所管理的内存中最大的一块，Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。该内存区域唯一的目的就是存放对象实例，Java对象实例以及数组都在堆上分配（随着JIT编译器发展等技术成熟，所有对象分配在堆上也渐渐不是那么“绝对”了）。</p><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样（或者说，像链表一样虽然内存上不一定连续，但逻辑上是连续）。</p><h3 id="58-5-方法区（Method-Area）"><a href="#58-5-方法区（Method-Area）" class="headerlink" title="58.5. 方法区（Method Area）"></a>58.5. 方法区（Method Area）</h3><p>方法区与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="58-6-运行时常量池（Runtime-Constant-Pool）"><a href="#58-6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="58.6. 运行时常量池（Runtime Constant Pool）"></a>58.6. 运行时常量池（Runtime Constant Pool）</h3><p>运行时常量池是方法区的一部分。Class文件中除了有关类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并非不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量池放入池中。</p><h2 id="59-Class文件结构"><a href="#59-Class文件结构" class="headerlink" title="59. Class文件结构"></a>59. Class文件结构</h2><p>Class文件由顺序的8位字节为基础单位构成的二进制流。各个项目严格按照顺序紧凑排列，无分隔符。Class文件只有两种数据结构：无符号数和表。</p><p>无符号数属于基本的数据类型，以u1、u2、u4、u8分别代表1个、2个、4个、8个字节的无符号数。可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串。</p><p>表由多个无符号数或其他表作为数据项构成的复合数据类型，所有表以“_info”结尾。表用来描述具有层次关系的复合结构数据。整个Class文件本质上就是一张表。</p><p>Class文件由魔数与Class文件的版本、常量池、访问标识、类索引、父类索引与接口索引集合、字段表集合、方法表集合、属性表集合等构成。</p><h3 id="59-1-魔数与Class文件的版本"><a href="#59-1-魔数与Class文件的版本" class="headerlink" title="59.1. 魔数与Class文件的版本"></a>59.1. 魔数与Class文件的版本</h3><p>每个Class文件的头4个字节称为魔数（Magic Number），它唯一作用就是用来确定文件是否能被虚拟机接受。</p><p>接下来的4个字节存储着Class文件的版本号，第五第六个字节为次版本号（Minor Version），第七第八为主版本号（Major Version）。版本号主要用于版本控制，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p><h3 id="59-2-常量池"><a href="#59-2-常量池" class="headerlink" title="59.2. 常量池"></a>59.2. 常量池</h3><p>紧接着版本号之后的就是常量池入口，常量池入口后面还必须有一个u2数据项作为常量池容量计数器（因为常量池数量不固定）。常量池是一个表类型的数据项，相当于Class文件的资源仓库，与Class文件其他项目关联最多，占用Class空间最大的数据项之一，且是第一个出现的表类型数据项目。</p><p>常量池主要存储两大类常量：</p><ul><li>字面量（Literal）：相当于Java语言中的常量概念，比如字符串，声明为final的常量值。</li><li>符号引用（Symbolic References）：属于编译原理方面的概念包括三类常量：<ul><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li></ul></li></ul><h3 id="59-3-访问标识"><a href="#59-3-访问标识" class="headerlink" title="59.3. 访问标识"></a>59.3. 访问标识</h3><p>常量池之后就是由两个字节代表的访问标识（access flags），这些标识用于识别一些类或者接口层次的访问信息，包括：</p><ul><li>这个Class是类还是接口；</li><li>是否定义为public；</li><li>是否定义为abstract类型；</li><li>如果是类的话，是否被final修饰。</li></ul><h3 id="59-4-类索引、父类索引与接口索引集合"><a href="#59-4-类索引、父类索引与接口索引集合" class="headerlink" title="59.4. 类索引、父类索引与接口索引集合"></a>59.4. 类索引、父类索引与接口索引集合</h3><p>访问标志位之后就是u2类型的类索引，父类索引和接口索引集合。Class文件由这三项数据确定这个类的继承关系。这三项数据（u2类型的索引值）各指向类型为CONSTANT_Class_info的类描述符常量。</p><h3 id="59-5-字段表集合"><a href="#59-5-字段表集合" class="headerlink" title="59.5. 字段表集合"></a>59.5. 字段表集合</h3><p>字段表用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。字段表中字段的各种描述信息（作用域比如public，private，是否被final，static修饰，是否可序列化等）均使用标志位表示，名称则引用常量池中的常量来描述。</p><h3 id="59-6-方法表集合"><a href="#59-6-方法表集合" class="headerlink" title="59.6. 方法表集合"></a>59.6. 方法表集合</h3><p>在方法表中，方法的描述和字段的描述基本一致，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。</p><p>方法中的代码经过编译器编译成字节码指令后存放在方法属性表集合中一个名为“Code”的属性里面。</p><p>如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。</p><h3 id="59-7-属性表集合"><a href="#59-7-属性表集合" class="headerlink" title="59.7. 属性表集合"></a>59.7. 属性表集合</h3><p>Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p><p>为了能正确解析Class文件，在Java SE 7中预定义了21项属性，虚拟机在运行时会忽略他不认识的属性。</p><h2 id="60-运行时栈帧结构"><a href="#60-运行时栈帧结构" class="headerlink" title="60. 运行时栈帧结构"></a>60. 运行时栈帧结构</h2><p>栈帧（Stack Frame）是用于虚拟机执行时方法调用和方法执行时的数据结构，它是虚拟栈数据区的组成元素。每一个方法从调用到方法返回都对应着一个栈帧入栈出栈的过程。</p><p>每一个栈帧在编译程序代码的时候所需要多大的局部变量表，多深的操作数栈都已经决定了，并且写入到方发表的Code属性之中，一次一个栈帧需要多少内存，不会受到程序运行期变量数据的影响，仅仅取决于具体的虚拟机实现。</p><p>一个线程中方法调用可能很长，很多方法都处于执行状态。对于执行引擎来说，只有处于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与之相关联的方法称为当前方法（Current Method）。</p><p>在概念模型上，典型的栈帧主要由局部变量表（Local Stack Frame）、操作数栈（Operand Stack）、动态链接（Dynamic Linking）、返回地址（Return Address）组成，如下图所示：</p><p><img src="/2018/12/31/java1/stack_frame.png" alt="Stack Frame"></p><h3 id="60-1-局部变量表（Local-Variable-Table）"><a href="#60-1-局部变量表（Local-Variable-Table）" class="headerlink" title="60.1. 局部变量表（Local Variable Table）"></a>60.1. 局部变量表（Local Variable Table）</h3><p>局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p><p>在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static的方法），那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。</p><h3 id="60-2-操作数栈（Operand-Stack）"><a href="#60-2-操作数栈（Operand-Stack）" class="headerlink" title="60.2. 操作数栈（Operand Stack）"></a>60.2. 操作数栈（Operand Stack）</h3><p>操作数栈（Operand Stack）也常称为操作栈，是一个后入先出栈。在Class文件的Code属性的max_stacks指定了执行过程中最大的栈深度。Java 虚拟机的解释执行引擎称为”基于栈的执行引擎“，这里的栈就是指操作数栈。</p><p>方法执行中进行算术运算或者是调用其他的方法进行参数传递的时候是通过操作数栈进行的。</p><p>在概念模型中，两个栈帧是相互独立的。但是大多数虚拟机的实现都会进行优化，令两个栈帧出现一部分重叠。令下面的部分操作数栈与上面的局部变量表重叠在一块，这样在方法调用的时候可以共用一部分数据，无需进行额外的参数复制传递。</p><h3 id="60-3-动态连接（Dynamic-Linking）"><a href="#60-3-动态连接（Dynamic-Linking）" class="headerlink" title="60.3. 动态连接（Dynamic Linking）"></a>60.3. 动态连接（Dynamic Linking）</h3><p>每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</p><p>Class文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p><h3 id="60-4-方法返回地址"><a href="#60-4-方法返回地址" class="headerlink" title="60.4. 方法返回地址"></a>60.4. 方法返回地址</h3><p>当一个方法开始执行以后，只有两种方法可以退出当前方法：</p><ul><li>当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口（Normal Method Invocation Completion），一般来说，调用者的PC计数器可以作为返回地址。</li><li>当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，称为异常完成出口（Abrupt Method Invocation Completion），返回地址要通过异常处理器表来确定。</li></ul><p>当方法返回时，可能进行3个操作：</p><ul><li>恢复上层方法的局部变量表和操作数栈</li><li>把返回值压入调用者调用者栈帧的操作数栈</li><li>调整PC计数器的值以指向方法调用指令后面的一条指令</li></ul><h3 id="60-5-附加信息"><a href="#60-5-附加信息" class="headerlink" title="60.5. 附加信息"></a>60.5. 附加信息</h3><p>虚拟机规范并没有规定具体虚拟机实现包含什么附加信息，这部分的内容完全取决于具体实现。在实际开发中，一般会把动态连接，方法返回地址和附加信息全部归为一类，称为栈帧信息。</p><h2 id="61-基于栈的指令集和基于寄存器的指令集"><a href="#61-基于栈的指令集和基于寄存器的指令集" class="headerlink" title="61. 基于栈的指令集和基于寄存器的指令集"></a>61. 基于栈的指令集和基于寄存器的指令集</h2><h3 id="61-1-例子"><a href="#61-1-例子" class="headerlink" title="61.1. 例子"></a>61.1. 例子</h3><p>分别使用基于栈的指令集和基于寄存器的指令集计算“1+1”的结果，基于栈的指令集会是：</p><pre><code>iconst_1iconst_1iaddistore_0</code></pre><p>两条iconst_1指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部变量表的第0个Slot中。</p><p>如果基于寄存器，那就会是：</p><pre><code>mov eax, 1add eax, 1</code></pre><p>mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面。</p><h3 id="61-2-区别"><a href="#61-2-区别" class="headerlink" title="61.2. 区别"></a>61.2. 区别</h3><p>基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。例如，现在32位80x86体系的处理器中提供了8个32位的寄存器，而ARM体系的CPU（在当前的手机、PDA中相当流行的一种处理器）则提供了16个32位的通用寄存器。如果使用栈架构的指令集，用户程序不会直接使用这些寄存器，就可以由虚拟机实现来自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存等）放到寄存器中以获取尽量好的性能，这样实现起来也更加简单一些。栈架构的指令集还有一些其他的优点，如代码相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）、编译器实现更加简单（不需要考虑空间分配的问题，所需空间都在栈上操作）等。</p><p>栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。所有主流物理机的指令集都是寄存器架构也从侧面印证了这一点。</p><p>虽然栈架构指令集的代码非常紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令数量。更重要的是，栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取栈顶缓存的手段，把最常用的操作映射到寄存器中避免直接内存访问，但这也只能是优化措施而不是解决本质问题的方法。由于指令数量和内存访问的原因，所以导致了栈架构指令集的执行速度会相对较慢。</p><h2 id="62-Javac编译过程"><a href="#62-Javac编译过程" class="headerlink" title="62. Javac编译过程"></a>62. Javac编译过程</h2><p>Javac编译过程大致可以分为3个过程：</p><ul><li>解析与填充符号表过程</li><li>插入式注解处理器的注解处理过程</li><li>分析与字节码生成过程</li></ul><p><img src="/2018/12/31/java1/javac_compiler.jpg" alt="Javac Compiler"></p><h3 id="62-1-解析与填充符号表过程"><a href="#62-1-解析与填充符号表过程" class="headerlink" title="62.1. 解析与填充符号表过程"></a>62.1. 解析与填充符号表过程</h3><h4 id="62-1-1-解析（词法、语法分析）"><a href="#62-1-1-解析（词法、语法分析）" class="headerlink" title="62.1.1. 解析（词法、语法分析）"></a>62.1.1. 解析（词法、语法分析）</h4><p>词法分析是将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为编辑，如“int a+b=2”这句代码中包含了6个标记，分别是int、a、=、b、+、2，虽然关键字int由三个字符构成，但是它只是一个Token,不可再拆分。</p><p>语法分析是根据Token序列构造抽象语法树的过程，抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。</p><h4 id="62-1-2-填充符号表"><a href="#62-1-2-填充符号表" class="headerlink" title="62.1.2. 填充符号表"></a>62.1.2. 填充符号表</h4><p>符号表是由一组符号地址和符号信息构成的表格，可以把它想象成哈希表K-V值对的形式。符号表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检测和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。</p><h3 id="62-2-注解处理器"><a href="#62-2-注解处理器" class="headerlink" title="62.2. 注解处理器"></a>62.2. 注解处理器</h3><p>在JDK1.6中实现了JSR-269规范，提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，我们可以把它看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，那么编译器将回到解析及填充符号表的过程重新处理，直到所有的插入式注解处理器都没有再对语法树进行修改位置。</p><h3 id="62-3-语义分析与字节码生成"><a href="#62-3-语义分析与字节码生成" class="headerlink" title="62.3. 语义分析与字节码生成"></a>62.3. 语义分析与字节码生成</h3><ul><li>标注检查：标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。</li><li>数据及控制流分析：数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。</li><li>解语法糖：Java中最常用的语法糖主要是泛型、变长参数、自动装箱／拆箱等，虚拟机运行时不支持这些语法，它们在编译阶段被还原回简单的基础语法结构，这个过程称为解语法糖。</li><li>字节码生成：字节码生成是Javac编译过程的最后一个阶段。字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。</li></ul><h2 id="63-什么是JIT"><a href="#63-什么是JIT" class="headerlink" title="63. 什么是JIT"></a>63. 什么是JIT</h2><p>Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为是“热点代码”（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Complier, JIT编译器）。</p><h2 id="64-什么是热点代码"><a href="#64-什么是热点代码" class="headerlink" title="64. 什么是热点代码"></a>64. 什么是热点代码</h2><p>在运行过程中会被即时编译器编译的“热点代码”有两类：</p><ul><li>被多次调用的方法</li><li>被多次执行的循环体</li></ul><h2 id="65-如何判断热点代码"><a href="#65-如何判断热点代码" class="headerlink" title="65. 如何判断热点代码"></a>65. 如何判断热点代码</h2><p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为热点探测（Hot Spot Detection），目前主要的热点探测判定方式有两种：</p><ul><li>基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是“热点代码”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li>基于计数器的热点探测：采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</li></ul><h2 id="66-Java与C／C-的编译器对比"><a href="#66-Java与C／C-的编译器对比" class="headerlink" title="66. Java与C／C++的编译器对比"></a>66. Java与C／C++的编译器对比</h2><p>Java虚拟机的即时编译器与C/C++的静态优化编译器相比，可能会由于下列原因，而导致输出的本地代码有一些劣势（下面列举的也包括一些虚拟机执行子系统的性能劣势）：</p><ul><li>因为即时编译器运行占用的是用户程序的运行时间，具有很大的时间压力，它能提供的优化手段也严重受制于编译成本。如果编译速度达不到要求，那用户将在启动程序或程序的某部分察觉到重大延迟，这点使得即时编译器不敢随便引入大规模的优化技术，而编译的时间成本在静态优化编译器中并不是主要的关注点。</li><li>Java语言是动态的类型安全语言，这就意味着需要由虚拟机来确保程序不会违反语言语义或访问非结构化内存。从实现层面上看，这就意味着虚拟机必须频繁地进行动态检查，如实例方法访问时检查空指针、数组元素访问时检查上下界范围、类型转换时检查继承关系等。对于这类程序代码没有明确写出的检查行为，尽管编译器会努力进行优化，但是总体上仍然要消耗不少的运行时间。</li><li>Java语言中虽然没有virtual关键字，但是使用虚方法的频率却远远大于C/C++语言，这意味着运行时对方法接收者进行多态选择的频率要远远大于C/C++语言，也意味着即时编译器在进行一些优化（如方法内联）时的难度要远远大于C/C++的静态优化编译器。</li><li>Java语言是可以动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得很多全局的优化难以进行，因为编译器无法看清程序的全貌，许多全局的优化都只能以激进优化的方式来完成，编译器不得不时刻注意并随着类型的变化而在运行时撤销或重新进行一些优化。</li><li>Java语言的对象内存是在堆上，只有方法的局部变量才能在栈上分配，而C/C++的对象则有多重内存分配方式，既可能在堆上分配，又可能在栈上分配，如果可以在栈上分配线程私有的对象，将减轻内存回收的压力。另外，C/C++中主要由用户用程序代码来回收分配的内存，这就不存在无用对象筛选的过程，因此效率上（仅是运行效率，排除开发效率）也比Java的垃圾收集机制要高。</li></ul><p>Java语言的这些性能上的劣势都是为了换取开发效率上的优势而付出的代价，动态安全、动态扩展、垃圾回收这些“拖后腿”的特性都为Java语言的开发效率作出了很大的贡献。Java编译器的另外一个红利时由它的动态性所带来的，由于C/C++编译器的所有优化都在编译期完成，以运行期性能监控为基础的优化措施它都无法进行，如调用频率预测（Call Frequency Prediction）、分支频率预测（Branch Frequency Prediction）、裁剪未被选择的分支（Untaken Branch Pruning）等，这些都会成为Java语言独有的性能优势。</p><h2 id="67-Java线程的实现"><a href="#67-Java线程的实现" class="headerlink" title="67. Java线程的实现"></a>67. Java线程的实现</h2><p>操作系统实现线程主要有3种方式：</p><ul><li>使用内核线程实现（一对一线程模型）</li><li>使用用户线程实现（一对多线程模型）</li><li>使用用户线程加轻量级进程混合实现（多对多线程模型）</li></ul><p>Java线程在JDK 1.2之前，是基于称为“绿色线程”（Green Threads）的用户线程实现的；而在JDK 1.2种，线程模型替换为基于操作系统原生线程模型来实现。对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windwos和Linux系统提供的线程模型就是一对一的。</p><p>线程调度主要有两种方式：</p><ul><li>协同式线程调度（Cooperative Threads-Scheduling）</li><li>抢占式线程调度（Preemptive Threads-Scheduling）</li></ul><p>Java使用的线程调度方式是抢占式调度，由操作系统自动完成。</p><h2 id="68-线程的状态和转换关系"><a href="#68-线程的状态和转换关系" class="headerlink" title="68. 线程的状态和转换关系"></a>68. 线程的状态和转换关系</h2><p>Java定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态：</p><ul><li>新建（New）：创建了但未启动</li><li>运行（Runable）：包括了操作系统线程状态中的Running和Ready。处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。</li><li>无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下方法会触发该状态：<ul><li>没有设置Timeout参数的<code>Object.wait()</code>方法。</li><li>没有设置Timeout参数的<code>Thread.join()</code>方法。</li><li><code>LockSupport.park()</code>方法。</li></ul></li><li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，但系统在一定时间后会自动唤醒它。以下方法会触发该状态：<ul><li><code>Thread.sleep()</code>方法。</li><li>设置Timeout参数的<code>Object.wait()</code>方法。</li><li>设置Timeout参数的<code>Thread.join()</code>方法。</li><li><code>LockSupport.parkNanos()</code>方法。</li><li><code>LockSupport.parkUntil()</code>方法。</li></ul></li><li>阻塞（Blocked）：阻塞状态下是在等待着获取一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；在程序等待进入同步区域的时候，线程将进入这个状态。</li><li>结束（Terminated）：线程已经结束执行。</li></ul><p><img src="/2018/12/31/java1/thread_state_transition.png" alt="Thread State Transition"></p><p><img src="/2018/12/31/java1/thread_life_cycle.png" alt="Thread Life Cycle"></p><h2 id="69-对象的访问定位"><a href="#69-对象的访问定位" class="headerlink" title="69. 对象的访问定位"></a>69. 对象的访问定位</h2><p>目前主流的访问对象方式有两种：</p><ul><li>使用句柄：Java堆划分出一块内存作为句柄池，reference种存储的是对象的句柄地址；而句柄中包含了对象实例数据和类型数据各自的地址。其优点是对象被移动（垃圾手机时移动对象是非常普遍的行为）时只会改变句柄中实例数据的地址，而reference本身不需要修改。</li><li>直接指针：reference中存储的直接就是对象实例数据的地址，而对象实例数据中需要有这个对象类型数据的地址。其优点是节省了一次指针定位的时间开销，速度更快。</li></ul><p><img src="/2018/12/31/java1/handler_access.png" alt="Handler Access"></p><p><img src="/2018/12/31/java1/direct_pointer_access.png" alt="Direct Pointer Access"></p><h2 id="70-Java有哪些语法糖"><a href="#70-Java有哪些语法糖" class="headerlink" title="70. Java有哪些语法糖"></a>70. Java有哪些语法糖</h2><ul><li>泛型与类型擦除</li><li>自动装箱、拆箱与遍历循环</li><li>条件编译</li></ul><h2 id="71-Java线程安全的实现"><a href="#71-Java线程安全的实现" class="headerlink" title="71. Java线程安全的实现"></a>71. Java线程安全的实现</h2><h3 id="71-1-互斥同步（Mutual-Exclusion-amp-Synchronization）"><a href="#71-1-互斥同步（Mutual-Exclusion-amp-Synchronization）" class="headerlink" title="71.1. 互斥同步（Mutual Exclusion &amp; Synchronization）"></a>71.1. 互斥同步（Mutual Exclusion &amp; Synchronization）</h3><p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或一些）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。互斥是因，同步是果；互斥是方法，同步是目的。</p><p>最基本的互斥同步手段时synchronized关键字，synchronized关键字在编译后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型参数来指明要锁定和解锁的对象；如果没有指明，那就根据synchronized修饰的是实例方法还是类方法，去取对象的实例或Class对象来作为锁对象。</p><p>在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，则把锁的计数器加1；相应地，在monitorexit时，锁的计数器减1，当计数器减到0时，锁就被释放了。如果获取对象锁失败，则当前线程就要阻塞等待，直到对象锁被另一线程释放。</p><p>synchronized同步块对于同一条线程来说是可重入的，不会出现自己把自己锁死的情况；同步块在已进入的线程执行完前，会阻塞后面其他线程的进入。如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到和心态，因此状态转换需要耗费很多时间。</p><p>除synchronized外，还可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步。ReentrantLock表现为API层面的互斥锁（look()和unlock()方法），synchronized表现为原生语法层面的互斥锁。ReentrantLock还增加了以下高级功能：</p><ul><li>等待可中断。当持有锁的线程长期不释放时，正在等待的线程可以选择放弃等待。</li><li>公平锁。多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认是非公平的，但可通过设置使用公平锁。</li><li>锁可绑定多个条件。ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多个条件关联，就需要添加额外的锁；而ReentrantLock则只需要多次调用newCondition()方法即可。</li></ul><h3 id="71-2-非阻塞同步（Non-Blocking-Synchronization）"><a href="#71-2-非阻塞同步（Non-Blocking-Synchronization）" class="headerlink" title="71.2. 非阻塞同步（Non-Blocking Synchronization）"></a>71.2. 非阻塞同步（Non-Blocking Synchronization）</h3><p>通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断重试，直到成功为止）。</p><p>非阻塞同步需要硬件指令的支持，常用的有：</p><ul><li>测试并设置（Test-and-Set）</li><li>获取并增加（Fetch-and-Increment）</li><li>交换（Swap）</li><li>比较和交换（Compare-and-Swap, CAS）</li><li>加载链接／条件存储（Load-Linked/Store-Conditional, LL/SC）</li></ul><p>CAS指令需要3个操作数，分别是内存位置（V）、旧的预期值（A）和新值（B）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不更新。</p><p>CAS操作由sun.misc.Unsafe类中的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供，虚拟机即时编译出来的结果就是一条平台相关的处理器CAS指令。由于Unsafe类不是提供给用户程序调用的类，我们只能通过其他的API来间接使用；如java.util.concurrent中的AtomicInteger类，其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作。</p><h3 id="71-3-无同步方案"><a href="#71-3-无同步方案" class="headerlink" title="71.3. 无同步方案"></a>71.3. 无同步方案</h3><p>如果一个方法本来就不涉及共享数据，那自然就无须任何同步措施去保证正确性。</p><ul><li>可重入代码（Reentrant Code）：可以在代码执行的任何时刻中断它，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误。</li><li>线程本地存储（Thread Local Storage）：如果共享数据的可见范围限制在同一个线程之内，这样就无须同步也能保证线程之间不会出现数据争用的问题。</li></ul><h2 id="72-锁优化"><a href="#72-锁优化" class="headerlink" title="72. 锁优化"></a>72. 锁优化</h2><p>适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，都是为了在线程之间更高效地共享数据，以解决竞争问题，提高程序执行效率。</p><h3 id="72-1-自旋锁与自适应自旋"><a href="#72-1-自旋锁与自适应自旋" class="headerlink" title="72.1. 自旋锁与自适应自旋"></a>72.1. 自旋锁与自适应自旋</h3><p>在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或两个以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让县城执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p>自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。因此，如果锁被占用的时间很短，自旋等待效果就会非常好；反之，如果锁被占用时间很长，那么自旋的线程只会白白消耗处理器资源。因此，自旋等待时间是有限度的，如果自旋超过限定次数（默认10次）仍然没有成功获得锁，则会使用传统方式去挂起线程。</p><p>JDK 1.6中默认开启了自旋锁。</p><p>在JDK 1.6中引入了自适应自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一锁上的自旋时间及锁的拥有者的状态来决定。</p><h3 id="72-2-锁消除"><a href="#72-2-锁消除" class="headerlink" title="72.2. 锁消除"></a>72.2. 锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。</p><h3 id="72-3-锁粗化"><a href="#72-3-锁粗化" class="headerlink" title="72.3. 锁粗化"></a>72.3. 锁粗化</h3><p>如果虚拟机探测到有一串连续的操作都对同一个对象加锁，将会把加锁同步的范围扩大（粗化）到整个操作序列的外部，这样只需要加一次锁就可以了。</p><h3 id="72-4-轻量级锁"><a href="#72-4-轻量级锁" class="headerlink" title="72.4. 轻量级锁"></a>72.4. 轻量级锁</h3><p>轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥产生的性能消耗。</p><p>HotSpot虚拟机的对象头（Object Header）分为两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄（Generational GC Age）等，这部分数据长度为32位或64位，称为“Mark Word”。其内容可以是：</p><p>| 存储内容 | 标志位 | 状态 |<br>| 对象哈希码、对象分代年龄 | 01 | 未锁定<br>| 指向锁记录的指针 | 00 | 轻量级锁定 |<br>| 指向重量级锁的指针 | 10 | 膨胀（重量级锁定） |<br>| 空，不需要记录信息 | 11 | GC标记 |<br>| 偏向线程ID、偏向时间戳、对象分代年龄 | 01 | 可偏向 |</p><p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（Displaced Mark Word）。</p><p>然后虚拟机使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（Mark Word的最后2 bit）将转变为“00”，即表示此对象处于轻量级锁定状态。</p><p>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行；否则说明这个锁对象已经被其他线程抢占了，这时轻量级锁膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥锁）得指针。</p><p>轻量级锁得解锁过程也是通过CAS操作来进行。如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。如果替换成功，则整个同步过程完成；否则说明有其他线程尝试获取该锁，则需要在释放锁的同时，唤醒被挂起的线程。</p><p>轻量级锁能提升程序同步性能的依据是：对于绝大部分的锁，在整个同步周期内度不是存在竞争的。</p><h3 id="72-5-偏向锁"><a href="#72-5-偏向锁" class="headerlink" title="72.5. 偏向锁"></a>72.5. 偏向锁</h3><p>偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不需要。</p><p>偏向锁的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p>当锁对象第一次被线程获取的时候，虚拟机会将会把对象头中的标志位设置为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作如轻量级锁那样执行。</p><h2 id="73-如何理解Java是一门静态多分派且动态单分派的语言？"><a href="#73-如何理解Java是一门静态多分派且动态单分派的语言？" class="headerlink" title="73. 如何理解Java是一门静态多分派且动态单分派的语言？"></a>73. 如何理解Java是一门静态多分派且动态单分派的语言？</h2><p>代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span>Fruit fruit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"People eat Fruit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span>Apple apple<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"People eat Apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Boy</span> <span class="token keyword">extends</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span>Fruit fruit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Boy eats Fruit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span>Apple apple<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Boy eats Apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行：</p><pre class=" language-java"><code class="language-java">People boy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Fruit apple <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>boy<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>结果：</p><pre class=" language-text"><code class="language-text">Boy eats Fruit</code></pre><h2 id="74-为什么synchronized修饰的变量推荐定义为final？"><a href="#74-为什么synchronized修饰的变量推荐定义为final？" class="headerlink" title="74. 为什么synchronized修饰的变量推荐定义为final？"></a>74. 为什么synchronized修饰的变量推荐定义为final？</h2><p>因为非final变量的引用常常会改变，一旦锁改变了，那synchronization就失去了意义。同时，也不推荐使用String对象作为synchronized代码块的锁，即使是<code>final String</code>。因为String存放在内存的String变量池中，可能会有其他代码或者第三方的代码使用了同一个String对象为锁，这样容易导致一些无法预测的问题。</p><h2 id="75-Object类有哪些方法"><a href="#75-Object类有哪些方法" class="headerlink" title="75. Object类有哪些方法"></a>75. Object类有哪些方法</h2><ul><li><code>protected Object clone()</code>：创建并返回此对象的一个副本。</li><li><code>boolean equals(Object obj)</code>：指示某个其他对象是否与此对象“相等”。</li><li><code>protected void finalize()</code>：当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</li><li><code>Class&lt;? extendsObject&gt; getClass()</code>：返回一个对象的运行时类。</li><li><code>int hashCode()</code>：返回该对象的哈希码值。</li><li><code>void notify()</code>：唤醒在此对象监视器上等待的单个线程。</li><li><code>void notifyAll()</code>：唤醒在此对象监视器上等待的所有线程。</li><li><code>String toString()</code>：返回该对象的字符串表示。</li><li><code>void wait()</code>：导致当前的线程等待，直到其他线程调用此对象的<code>notify()</code>方法或<code>notifyAll()</code>方法。</li><li><code>void wait(long timeout)</code>：导致当前的线程等待，直到其他线程调用此对象的<code>notify()</code>方法或<code>notifyAll()</code>方法，或者超过指定的时间量。</li><li><code>void wait(long timeout, int nanos)</code>：导致当前的线程等待，直到其他线程调用此对象的<code>notify()</code>方法或<code>notifyAll()</code>方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</li></ul><h2 id="76-sleep-和wait-的区别"><a href="#76-sleep-和wait-的区别" class="headerlink" title="76. sleep()和wait()的区别"></a>76. <code>sleep()</code>和<code>wait()</code>的区别</h2><p><img src="/2018/12/31/java1/thread_state_transition_2.jpg" alt="Thread State Transition"></p><ul><li><code>sleep()</code>是Thread类的方法，<code>wait()</code>是Object类中定义的方法。</li><li><code>Thread.sleep()</code>不会导致锁行为的改变，如果当前线程是拥有锁的，那么<code>Thread.sleep()</code>不会让线程释放锁。</li><li><code>Thread.sleep()</code>和<code>Object.wait()</code>都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。区别是，调用<code>wait()</code>后，需要别的线程执行<code>notify()</code>/<code>notifyAll()</code>才能够重新获得CPU执行时间。</li></ul><h2 id="77-Java版本历史与特性"><a href="#77-Java版本历史与特性" class="headerlink" title="77. Java版本历史与特性"></a>77. Java版本历史与特性</h2><h3 id="77-1-Java-8"><a href="#77-1-Java-8" class="headerlink" title="77.1. Java 8"></a>77.1. Java 8</h3><ul><li>Lambda表达式；</li><li>Pipelines和Streams；</li><li>Date和Time API；</li><li>Default方法；</li><li>Type注解；</li><li>Nashhorn JavaScript引擎；</li><li>并发计数器；</li><li>Parallel操作；</li><li>移除PermGen Error；</li><li>TLS SNI。</li></ul><h3 id="77-2-Java-7"><a href="#77-2-Java-7" class="headerlink" title="77.2. Java 7"></a>77.2. Java 7</h3><ul><li>switch语句块中允许以字符串作为分支条件；</li><li>在创建泛型对象时应用类型推断；</li><li>在一个语句块中捕获多种异常；</li><li>支持动态语言；</li><li>支持try-with-resources；</li><li>引入Java NIO.2开发包；</li><li>数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线；</li><li>钻石型语法；</li><li>null值的自动处理。</li></ul><h3 id="77-3-Java-6"><a href="#77-3-Java-6" class="headerlink" title="77.3. Java 6"></a>77.3. Java 6</h3><ul><li>支持脚本语言；</li><li>引入JDBC 4.0 API；</li><li>引入Java Compiler API；</li><li>可插拔注解；</li><li>增加对Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos和LDAP(Lightweight Directory Access Protocol)的支持；</li><li>继承Web Services；</li><li>做了很多优化。</li></ul><h3 id="77-4-Java-5"><a href="#77-4-Java-5" class="headerlink" title="77.4. Java 5"></a>77.4. Java 5</h3><ul><li>引入泛型；</li><li>增强循环，可以使用迭代方式；</li><li>自动装箱与自动拆箱；</li><li>类型安全的枚举；</li><li>可变参数；</li><li>静态引入；</li><li>元数据（注解）；</li><li>引入Instrumentation。</li></ul><h2 id="78-ThreadLocal原理"><a href="#78-ThreadLocal原理" class="headerlink" title="78. ThreadLocal原理"></a>78. ThreadLocal原理</h2><p>ThreadLocal类似Map。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Thread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap threadLocals <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">ThreadLocalMap <span class="token function">getMap</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> T firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="79-HashMap（Java-7）"><a href="#79-HashMap（Java-7）" class="headerlink" title="79. HashMap（Java 7）"></a>79. HashMap（Java 7）</h2><h3 id="79-1-构造函数"><a href="#79-1-构造函数" class="headerlink" title="79.1. 构造函数"></a>79.1. 构造函数</h3><p>主要是对如下几个变量的初始化：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> threshold<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 所能容纳的key-value对极限 </span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 负载因子</span><span class="token keyword">int</span> modCount<span class="token punctuation">;</span>  <span class="token keyword">int</span> size<span class="token punctuation">;</span></code></pre><ul><li><code>loadFactor</code>：Load factor为负载因子(默认值是0.75)。</li><li><code>threshold</code>：<code>Entry</code>数组初始化长度<code>length</code>默认值为16，<code>threshold</code>是HashMap所能容纳的最大数据量的<code>Entry</code>(键值对)个数。<code>threshold = length * Load factor</code>。</li><li><code>size</code>：HashMap中实际存在的键值对数量。</li><li><code>modCount</code>：主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。内部结构发生变化指的是结构发生变化，例如<code>put()</code>新键值对，但是某个key对应的value值被覆盖不属于结构变化。</li></ul><h3 id="79-2-确定索引位置"><a href="#79-2-确定索引位置" class="headerlink" title="79.2. 确定索引位置"></a>79.2. 确定索引位置</h3><p>HashMap定位数组索引位置，直接决定了<code>hash()</code>方法的离散性能。Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">indexFor</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> h <span class="token operator">&amp;</span> <span class="token punctuation">(</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>hash()</code>主要是用来“扰动”，<code>indexFor()</code>直接取hash的低位作为数组索引，所以扰动的目的就是混合<code>hashCode()</code>的高位和低位，以此来加大低位的随机性。</p><h3 id="79-3-put"><a href="#79-3-put" class="headerlink" title="79.3. put()"></a>79.3. <code>put()</code></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1. table为空则创建</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2. key为null则单独处理</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 3. 计算hash并得到数组索引</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 4. key存在则直接覆盖value</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 5. key不存在则添加</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="79-3-1-inflateTable"><a href="#79-3-1-inflateTable" class="headerlink" title="79.3.1. inflateTable()"></a>79.3.1. <code>inflateTable()</code></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">inflateTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> toSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token function">roundUpToPowerOf2</span><span class="token punctuation">(</span>toSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>capacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>inflateTable()</code>创建table，table大小永远是2的幂次，是为了计算<code>indexFor()</code>方便。</p><h4 id="79-3-2-putForNullKey"><a href="#79-3-2-putForNullKey" class="headerlink" title="79.3.2. putForNullKey()"></a>79.3.2. <code>putForNullKey()</code></h4><p><code>putForNullKey()</code>与正常的<code>put()</code>非常相似，只不过将数组索引指定为0。</p><h4 id="79-3-3-addEntry"><a href="#79-3-3-addEntry" class="headerlink" title="79.3.3. addEntry()"></a>79.3.3. <code>addEntry()</code></h4><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    value <span class="token operator">=</span> v<span class="token punctuation">;</span>    next <span class="token operator">=</span> n<span class="token punctuation">;</span>    key <span class="token operator">=</span> k<span class="token punctuation">;</span>    hash <span class="token operator">=</span> h<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>addEntry()</code>首先判断是否需要扩容（<code>size &gt;= threshold</code>），若需要则首先<code>resize()</code>扩容，重新计算数组索引，最后<code>createEntry()</code>插入到table中。<code>createEntry()</code>即采用头插法将新的<code>Entry</code>插入到table中。</p><h3 id="79-4-扩容机制"><a href="#79-4-扩容机制" class="headerlink" title="79.4. 扩容机制"></a>79.4. 扩容机制</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>        threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">)</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>resize()</code>创建一个大小为<code>2*table.length</code>的<code>Entry</code>数组，然后通过<code>transfer()</code>将原<code>Entry</code>数组中的元素重新hash到新的<code>Entry</code>数组中。这里插入到新table仍然采用头插法。</p><h3 id="79-5-get"><a href="#79-5-get" class="headerlink" title="79.5. get()"></a>79.5. <code>get()</code></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> entry <span class="token operator">=</span> <span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null <span class="token operator">==</span> entry <span class="token operator">?</span> null <span class="token operator">:</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> V <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getEntry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>get()</code>时，通过key找到入口<code>Entry</code>，再采用单链表遍历的方式找到真正的Entry（<code>e.hash == hash &amp;&amp; (e.key == key || (key != null &amp;&amp; key.equals(e.key))</code>），最后返回value。</p><p>参考：<a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">Java 8系列之重新认识HashMap</a></p><h2 id="80-Java-8对HashMap的改进"><a href="#80-Java-8对HashMap的改进" class="headerlink" title="80. Java 8对HashMap的改进"></a>80. Java 8对HashMap的改进</h2><h3 id="80-1-hash"><a href="#80-1-hash" class="headerlink" title="80.1. hash()"></a>80.1. <code>hash()</code></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Java 8中<code>hash()</code>仅扰动一次，而Java 7中扰动四次。</p><h3 id="80-2-红黑树"><a href="#80-2-红黑树" class="headerlink" title="80.2. 红黑树"></a>80.2. 红黑树</h3><p>Java 7中HashMap采用的是位桶+链表的方式。而Java 8中采用的是位桶+链表／红黑树的方式，当某个位桶的链表的长度超过8的时候，这个链表就将转换成红黑树。</p><h3 id="80-3-resize"><a href="#80-3-resize" class="headerlink" title="80.3. resize()"></a>80.3. <code>resize()</code></h3><p>Java 7在扩容时会重新计算<code>Entry</code>的数组索引，而在Java 8中只需要看看原来的hash值新增的那个bit是1还是0就好了（table数组大小每次扩容乘2），是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p><h2 id="81-如何理解NIO"><a href="#81-如何理解NIO" class="headerlink" title="81. 如何理解NIO"></a>81. 如何理解NIO</h2><h3 id="81-1-什么是NIO"><a href="#81-1-什么是NIO" class="headerlink" title="81.1. 什么是NIO"></a>81.1. 什么是NIO</h3><p>NIO包（<code>java.nio.*</code>）引入了四个关键的抽象数据类型，它们共同解决传统的I/O类中的一些问题：</p><ul><li><code>Buffer</code>：它是包含数据且用于读写的线形表结构。其中还提供了一个特殊类用于内存映射文件的I/O操作。</li><li><code>Charset</code>：它提供Unicode字符串映射到字节序列以及逆映射的操作。</li><li><code>Channels</code>：包含socket，file和pipe三种管道，它实际上是双向交流的通道。</li><li><code>Selector</code>：它将多元异步I/O操作集中到一个或多个线程中（它可以被看成是Unix中<code>select()</code>函数或Win32中<code>WaitForSingleEvent()</code>函数的面向对象版本）。</li></ul><h3 id="81-2-NIO与IO的区别"><a href="#81-2-NIO与IO的区别" class="headerlink" title="81.2. NIO与IO的区别"></a>81.2. NIO与IO的区别</h3><p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用<code>read()</code>或<code>write()</code>时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。</p><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p><h3 id="81-3-为什么要使用NIO"><a href="#81-3-为什么要使用NIO" class="headerlink" title="81.3. 为什么要使用NIO"></a>81.3. 为什么要使用NIO</h3><p>NIO 的创建目的是为了让Java程序员可以实现高速I/O而无需编写自定义的本机代码。NIO将最耗时的I/O操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。</p><h2 id="82-concurrent包"><a href="#82-concurrent包" class="headerlink" title="82. concurrent包"></a>82. concurrent包</h2><p>concurrent包主要包含：</p><ul><li>大部分关于并发的接口和类：BlockingQueue、Callable、ConcurrentMap、Executor、ExecutorService、Future、Semaphore等。</li><li>所有原子操作的类：AtomicInteger、AtomicLong等。</li><li>锁相关的类：Lock、ReentrantLock、ReadWriteLock等。</li></ul><h2 id="83-当前线程wait-后会立即阻塞吗？其他线程能够进入同步块吗？"><a href="#83-当前线程wait-后会立即阻塞吗？其他线程能够进入同步块吗？" class="headerlink" title="83. 当前线程wait()后会立即阻塞吗？其他线程能够进入同步块吗？"></a>83. 当前线程<code>wait()</code>后会立即阻塞吗？其他线程能够进入同步块吗？</h2><p>当调用<code>wait()</code>时，当前线程会放弃已经获得的锁，接着会将自己park住，放弃CPU。而在notify()中会选择一个<code>wait()</code>的线程进行unpark，被unpark的线程还需要竞争锁。</p><h2 id="84-为何调用wait-可能抛出InterruptedException异常？"><a href="#84-为何调用wait-可能抛出InterruptedException异常？" class="headerlink" title="84. 为何调用wait()可能抛出InterruptedException异常？"></a>84. 为何调用<code>wait()</code>可能抛出InterruptedException异常？</h2><p>当调用线程的<code>interrupt()</code>方法时会抛出InterruptedException，因此即使当前线程因<code>wait()</code>一直被阻塞，当被唤醒时也会去检查其状态，如果其被interrupt了，就会抛出InterruptedException。</p><h2 id="85-调用notify-后等待的线程会被立刻唤醒吗？"><a href="#85-调用notify-后等待的线程会被立刻唤醒吗？" class="headerlink" title="85. 调用notify()后等待的线程会被立刻唤醒吗？"></a>85. 调用<code>notify()</code>后等待的线程会被立刻唤醒吗？</h2><p>有不同的策略。默认策略是调用<code>notify()</code>会将一个等待队列中的线程放到锁池中，等到退出同步块时再释放锁，由锁池中的线程竞争。这里“唤醒”的定义不明确，可以说“线程由等待队列移动到锁池”是唤醒，也可以说“线程得到CPU时间”是唤醒。</p><h2 id="86-notify-和notifyAll-有什么区别？"><a href="#86-notify-和notifyAll-有什么区别？" class="headerlink" title="86. notify()和notifyAll()有什么区别？"></a>86. <code>notify()</code>和<code>notifyAll()</code>有什么区别？</h2><p>注意：<code>synchronized()</code>会使线程进入锁池，<code>wait()</code>会使线程进入等待队列。只有锁池中的线程会竞争锁，等待队列中的线程不会竞争。</p><p><code>notify()</code>会将<strong>一个</strong>等待队列中的线程移动到锁池中，<code>notifyAll()</code>则会将<strong>所有</strong>等待队列中的线程移动到锁池中。</p><h2 id="87-notify-可能引发死锁。"><a href="#87-notify-可能引发死锁。" class="headerlink" title="87. notify()可能引发死锁。"></a>87. <code>notify()</code>可能引发死锁。</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">PubSub</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> flag<span class="token punctuation">;</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">pub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"pub count "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sub count "</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> PubSub pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PubSub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            pb<span class="token punctuation">.</span><span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">try</span> <span class="token punctuation">{</span>                            pb<span class="token punctuation">.</span><span class="token function">pub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如上代码会发生死锁。<code>synchronized()</code>会使线程进入锁池，<code>wait()</code>会使线程进入等待队列，<code>notify()</code>会将一个等待队列中的线程移动到锁池中。如上代码会出现多个多次调用<code>wait()</code>导致所有线程全部处于等待队列，而无线程在锁池中的情况，导致死锁。</p><h2 id="88-线程的sleep-、yield-和join-有什么区别？"><a href="#88-线程的sleep-、yield-和join-有什么区别？" class="headerlink" title="88. 线程的sleep()、yield()和join()有什么区别？"></a>88. 线程的<code>sleep()</code>、<code>yield()</code>和<code>join()</code>有什么区别？</h2><ul><li><code>sleep()</code>：线程进入阻塞状态；</li><li><code>yield()</code>：线程进入就绪状态；</li><li><code>join()</code>：线程进入阻塞状态。</li></ul><h2 id="89-类名-class与类名-this的区别"><a href="#89-类名-class与类名-this的区别" class="headerlink" title="89. 类名.class与类名.this的区别"></a>89. <code>类名.class</code>与<code>类名.this</code>的区别</h2><p><code>类名.this</code>的语法在Java语言中叫做“qualified this”。这个语法的主要用途是：在内部类的方法中，要指定某个嵌套层次的外围类的<code>this</code>引用时，使用<code>外围类名.this</code>语法。</p><p><code>类型名.class</code>的语法在Java语言中叫做“Class Literal”，类字面量。类字面量的类型是<code>java.lang.Class&lt;类型名&gt;</code>。例如说<code>Foo.class</code>的类型就是<code>Class&lt;Foo&gt;</code>，是一个引用，指向Foo类唯一对应的那个Class对象。当需要通过Class对象来做一些反射操作的时候，常常会用到类字面量的语法。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javase </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android开发相关知识总结</title>
      <link href="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/"/>
      <url>/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Android面试题"><a href="#Android面试题" class="headerlink" title="Android面试题"></a>Android面试题</h1><!-- TOC --><ul><li><a href="#1-android四大组件">1. Android四大组件</a><ul><li><a href="#11-activity">1.1. Activity</a></li><li><a href="#12-服务">1.2. 服务</a></li><li><a href="#13-内容提供程序">1.3. 内容提供程序</a></li><li><a href="#14-广播接收器">1.4. 广播接收器</a></li></ul></li><li><a href="#2-四大组件的启动方式">2. 四大组件的启动方式</a></li><li><a href="#3-画出activity的生命周期图">3. 画出Activity的生命周期图</a></li><li><a href="#4-介绍下不同场景下activity生命周期的变化过程">4. 介绍下不同场景下Activity生命周期的变化过程</a></li><li><a href="#5-当activity-a启动activity-b时生命周期执行过程">5. 当Activity A启动Activity B时，生命周期执行过程？</a></li><li><a href="#6-内存不足时系统会杀掉后台的activity若需要进行一些临时状态的保存在哪个方法进行怎么恢复数据">6. 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？</a></li><li><a href="#7-什么是任务">7. 什么是任务？</a></li><li><a href="#8-activity的启动模式">8. Activity的启动模式？</a></li><li><a href="#9-横竖屏切换时候activity的生命周期">9. 横竖屏切换时候activity的生命周期？</a></li><li><a href="#10-如何将一个activity设置成窗口的样式">10. 如何将一个Activity设置成窗口的样式？</a></li><li><a href="#11-activity之间的数据传递有哪些方式">11. Activity之间的数据传递有哪些方式？</a></li><li><a href="#12-fragment的好处">12. Fragment的好处：</a></li><li><a href="#13-intent的原理作用可以传递哪些类型的参数">13. Intent的原理，作用，可以传递哪些类型的参数？</a></li><li><a href="#14-intent的主要使用方法">14. Intent的主要使用方法</a><ul><li><a href="#141-启动-activity">14.1. 启动 Activity</a></li><li><a href="#142-启动服务">14.2. 启动服务</a></li><li><a href="#143-传递广播">14.3. 传递广播</a></li></ul></li><li><a href="#15-intent包含哪些信息">15. Intent包含哪些信息</a></li><li><a href="#16-什么是intent过滤器">16. 什么是Intent过滤器</a></li><li><a href="#17-service的启动方式">17. Service的启动方式</a></li><li><a href="#18-service的生命周期">18. Service的生命周期</a></li><li><a href="#19-activity怎么和service绑定怎么在activity中启动自己对应的service">19. Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？</a></li><li><a href="#20-允许绑定的已启动服务的生命周期">20. 允许绑定的已启动服务的生命周期</a></li><li><a href="#21-service中可以弹toast吗">21. Service中可以弹Toast吗？</a></li><li><a href="#22-进程的优先级">22. 进程的优先级</a><ul><li><a href="#221-前台进程">22.1. 前台进程</a></li><li><a href="#222-可视进程">22.2. 可视进程</a></li><li><a href="#223-服务进程">22.3. 服务进程</a></li><li><a href="#224-后台进程">22.4. 后台进程</a></li><li><a href="#225-空进程">22.5. 空进程</a></li></ul></li><li><a href="#23-intentservice如何工作">23. IntentService如何工作？</a></li><li><a href="#24-intentservice与service的区别">24. IntentService与Service的区别？</a></li><li><a href="#25-android-service与activity之间的通信方式">25. Android Service与Activity之间的通信方式？</a></li><li><a href="#26-broadcastreceiver简介">26. BroadcastReceiver简介</a><ul><li><a href="#261-用途">26.1. 用途</a></li><li><a href="#262-使用场景">26.2. 使用场景</a></li><li><a href="#263-实现原理">26.3. 实现原理</a></li><li><a href="#264-注册方式">26.4. 注册方式</a></li></ul></li><li><a href="#27-为什么要用contentprovider它和sql的实现上有什么差别">27. 为什么要用ContentProvider？它和SQL的实现上有什么差别？</a></li><li><a href="#28-contentprovider怎么实现数据共享">28. ContentProvider怎么实现数据共享？</a></li><li><a href="#29-android如何访问自定义contentprovider">29. Android如何访问自定义ContentProvider</a></li><li><a href="#30-android中activityintentcontent-providerservice各有什么区别">30. Android中Activity，Intent，Content Provider，Service各有什么区别。</a></li><li><a href="#31-android数据存储方式">31. Android数据存储方式？</a></li><li><a href="#32-android中常用的布局都有哪些">32. Android中常用的布局都有哪些？</a></li><li><a href="#33-androidlayout_gravity和androidgravity的区别">33. <code>android:layout_gravity</code>和<code>android:gravity</code>的区别？</a></li><li><a href="#34-android平台架构">34. Android平台架构</a><ul><li><a href="#341-系统应用">34.1. 系统应用</a></li><li><a href="#342-java-api框架">34.2. Java API框架</a></li><li><a href="#343-原生cc库">34.3. 原生C/C++库</a></li><li><a href="#344-android-runtime">34.4. Android Runtime</a></li><li><a href="#345-硬件抽象层hal">34.5. 硬件抽象层（HAL）</a></li><li><a href="#346-linux-内核">34.6. Linux 内核</a></li></ul></li><li><a href="#35-fragment生命周期">35. Fragment生命周期</a></li><li><a href="#36-activity生命周期对片段生命周期的影响">36. Activity生命周期对片段生命周期的影响</a></li><li><a href="#37-android事件分发">37. Android事件分发</a><ul><li><a href="#371-public-boolean-dispatchtoucheventmotionevent-ev">37.1. <code>public boolean dispatchTouchEvent(MotionEvent ev)</code></a></li><li><a href="#372-public-boolean-onintercepttoucheventmotionevent-ev">37.2. <code>public boolean onInterceptTouchEvent(MotionEvent ev)</code></a></li><li><a href="#373-public-boolean-ontoucheventmotionevent-ev">37.3. <code>public boolean onTouchEvent(MotionEvent ev)</code></a></li></ul></li><li><a href="#38-android系统启动过程">38. Android系统启动过程</a><ul><li><a href="#381-boot-rom">38.1. Boot ROM</a></li><li><a href="#382-boot-loader">38.2. Boot Loader</a></li><li><a href="#383-kernel">38.3. Kernel</a></li><li><a href="#384-init">38.4. init</a><ul><li><a href="#3841-本地服务">38.4.1. 本地服务</a></li><li><a href="#3842-android服务">38.4.2. Android服务</a></li></ul></li><li><a href="#385-zygote-and-dalvikart">38.5. Zygote and Dalvik（ART）</a></li><li><a href="#386-system-server">38.6. System Server</a></li><li><a href="#387-boot-completed">38.7. Boot completed</a></li></ul></li><li><a href="#39-android应用启动过程">39. Android应用启动过程</a></li><li><a href="#40-dpdipdpippi区别">40. dp，dip，dpi，ppi区别</a></li><li><a href="#41-长度和字体的推荐单位">41. 长度和字体的推荐单位</a></li><li><a href="#42-android-view绘制流程">42. Android View绘制流程</a></li><li><a href="#43-listview优化">43. ListView优化</a></li><li><a href="#44-android-binder机制">44. Android Binder机制</a></li><li><a href="#45-binder机制优点">45. Binder机制优点</a></li><li><a href="#46-asynctask简介">46. AsyncTask简介</a></li><li><a href="#47-为什么handler需要声明为static">47. 为什么Handler需要声明为static？</a></li><li><a href="#48-广播注册后不解除注册会有什么问题">48. 广播注册后不解除注册会有什么问题？</a></li><li><a href="#49-自定义view">49. 自定义View</a><ul><li><a href="#491-实现步骤">49.1. 实现步骤</a></li></ul></li><li><a href="#50-需要被重写的方法">50. 需要被重写的方法</a></li><li><a href="#51-parcelable和serializable的区别">51. Parcelable和Serializable的区别</a></li><li><a href="#52-android中的内存泄漏">52. Android中的内存泄漏</a></li><li><a href="#53-mvc和mvp的区别">53. MVC和MVP的区别</a></li><li><a href="#54-内存泄露检测有什么好方法">54. 内存泄露检测有什么好方法？</a></li><li><a href="#55-android里面为什么要设计出bundle而不是直接用map结构">55. Android里面为什么要设计出Bundle而不是直接用Map结构</a></li><li><a href="#56-在android的mvp架构中使用了什么设计模式">56. 在Android的MVP架构中，使用了什么设计模式</a></li><li><a href="#57-android动画类型">57. Android动画类型</a></li><li><a href="#58-anr和fc的区别">58. ANR和FC的区别</a></li><li><a href="#59-android中的菜单">59. Android中的菜单</a><ul><li><a href="#591-选项菜单options-menu">59.1. 选项菜单（Options menu）</a></li><li><a href="#592-上下文菜单contextual-menus">59.2. 上下文菜单（Contextual Menus）</a><ul><li><a href="#5921-浮动上下文菜单floating-context-menu">59.2.1. 浮动上下文菜单（floating context menu）</a></li></ul></li><li><a href="#593-弹出菜单popup-menu">59.3. 弹出菜单（Popup Menu）</a></li></ul></li><li><a href="#60-baseadapter中需要重载的方法">60. BaseAdapter中需要重载的方法</a></li><li><a href="#61-android数字签名要点">61. Android数字签名要点</a></li><li><a href="#62-使用相同数字签名的原因">62. 使用相同数字签名的原因</a></li><li><a href="#63-theme和sytle">63. Theme和Sytle</a><ul><li><a href="#631-style">63.1. Style</a></li><li><a href="#632-theme">63.2. Theme</a></li></ul></li><li><a href="#64-toast的时长设置">64. Toast的时长设置</a></li><li><a href="#65-触发anr的情况">65. 触发ANR的情况</a></li><li><a href="#66-serviceconnection的onserviceconnected触发条件">66. ServiceConnection的<code>onServiceConnected()</code>触发条件</a></li><li><a href="#67-android虚拟设备不支持的功能">67. Android虚拟设备不支持的功能</a></li><li><a href="#68-remoteview的应用">68. RemoteView的应用</a></li><li><a href="#69-android对hashmap做了优化后推出的新的容器类是什么">69. Android对HashMap做了优化后推出的新的容器类是什么？</a><ul><li><a href="#691-sparsearray">69.1. SparseArray</a></li><li><a href="#692-arraymap">69.2. ArrayMap</a></li></ul></li><li><a href="#70-android安全沙盒">70. Android安全沙盒</a></li><li><a href="#71-onstartcommand有哪些返回值">71. <code>onStartCommand()</code>有哪些返回值</a></li><li><a href="#72-如何创建绑定服务">72. 如何创建绑定服务</a><ul><li><a href="#721-扩展binder类">72.1. 扩展Binder类</a></li><li><a href="#722-使用messenger">72.2. 使用Messenger</a></li></ul></li><li><a href="#73-如何绑定到服务">73. 如何绑定到服务</a></li><li><a href="#74-android支持的屏幕密度">74. Android支持的屏幕密度</a></li><li><a href="#75-如何支持多种屏幕">75. 如何支持多种屏幕</a></li><li><a href="#76-什么是资源id">76. 什么是资源ID</a></li><li><a href="#77-如何处理运行时变更">77. 如何处理运行时变更</a><ul><li><a href="#771-在配置变更期间保留对象">77.1. 在配置变更期间保留对象</a></li><li><a href="#772-自行处理配置变更">77.2. 自行处理配置变更</a></li></ul></li><li><a href="#78-androidmanifestxml包括哪些内容">78. AndroidManifest.xml包括哪些内容？</a></li><li><a href="#79-用户界面如何构成">79. 用户界面如何构成？</a></li><li><a href="#80-为什么要回收bitmap的内存">80. 为什么要回收Bitmap的内存</a></li><li><a href="#81-如何优化bitmap">81. 如何优化Bitmap</a></li><li><a href="#82-如何在新进程中创建activity／service">82. 如何在新进程中创建Activity／Service</a></li><li><a href="#83-onactivityresult什么时候会失效">83. <code>onActivityResult()</code>什么时候会失效？</a></li><li><a href="#84-android崩溃捕获">84. Android崩溃捕获</a><ul><li><a href="#841-java崩溃捕获">84.1. Java崩溃捕获</a></li><li><a href="#842-native崩溃捕获">84.2. Native崩溃捕获</a></li></ul></li><li><a href="#85-android-app构建流程">85. Android APP构建流程</a></li><li><a href="#86-class文件与dex文件的区别">86. class文件与.dex文件的区别</a></li><li><a href="#87-65535问题">87. 65535问题</a><ul><li><a href="#871-原因">87.1. 原因</a></li><li><a href="#872-解决方法">87.2. 解决方法</a></li></ul></li><li><a href="#88-dalvik与jvm的区别">88. Dalvik与JVM的区别</a></li><li><a href="#89-art相对dalvik的优化">89. ART相对Dalvik的优化</a></li><li><a href="#90-android中的classloader">90. Android中的ClassLoader</a></li><li><a href="#91-classloader方式实现热修复">91. ClassLoader方式实现热修复</a></li><li><a href="#92-asynctask需要在主线程中实例化吗">92. AsyncTask需要在主线程中实例化吗？</a><ul><li><a href="#921-api-16之前">92.1. API 16之前</a></li><li><a href="#922-api-16及之后api-22之前">92.2. API 16及之后，API 22之前</a></li><li><a href="#923-api-22及之后">92.3. API 22及之后</a></li></ul></li><li><a href="#93-android消息处理机制">93. Android消息处理机制</a><ul><li><a href="#931-looper">93.1. Looper</a></li><li><a href="#932-handler">93.2. Handler</a></li></ul></li><li><a href="#94-startactivity执行流程">94. <code>startActivity()</code>执行流程</a></li></ul><!-- /TOC --><h2 id="1-Android四大组件"><a href="#1-Android四大组件" class="headerlink" title="1. Android四大组件"></a>1. Android四大组件</h2><p>应用组件是Android应用的基本构建基块。每个组件都是一个不同的点，系统可以通过它进入您的应用。并非所有组件都是用户的实际入口点，有些组件相互依赖，但每个组件都以独立实体形式存在，并发挥特定作用—-每个组件都是唯一的构建基块，有助于定义应用的总体行为。</p><p>共有四种不同的应用组件类型。每种类型都服务于不同的目的，并且具有定义组件的创建和销毁方式的不同生命周期。</p><p>以下便是这四种应用组件类型：</p><h3 id="1-1-Activity"><a href="#1-1-Activity" class="headerlink" title="1.1. Activity"></a>1.1. Activity</h3><p>Activity表示具有用户界面的单一屏幕。例如，电子邮件应用可能具有一个显示新电子邮件列表的Activity、一个用于撰写电子邮件的Activity以及一个用于阅读电子邮件的Activity。尽管这些Activity通过协作在电子邮件应用中形成了一种紧密结合的用户体验，但每一个Activity都独立于其他Activity而存在。因此，其他应用可以启动其中任何一个Activity（如果电子邮件应用允许）。例如，相机应用可以启动电子邮件应用内用于撰写新电子邮件的Activity，以便用户共享图片。</p><h3 id="1-2-服务"><a href="#1-2-服务" class="headerlink" title="1.2. 服务"></a>1.2. 服务</h3><p>服务是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。服务不提供用户界面。例如，当用户位于其他应用中时，服务可能在后台播放音乐或者通过网络获取数据，但不会阻断用户与Activity的交互。诸如Activity等其他组件可以启动服务，让其运行或与其绑定以便与其进行交互。</p><h3 id="1-3-内容提供程序"><a href="#1-3-内容提供程序" class="headerlink" title="1.3. 内容提供程序"></a>1.3. 内容提供程序</h3><p>内容提供程序管理一组共享的应用数据。您可以将数据存储在文件系统、SQLite数据库、网络上或您的应用可以访问的任何其他永久性存储位置。其他应用可以通过内容提供程序查询数据，甚至修改数据（如果内容提供程序允许）。例如，Android系统可提供管理用户联系人信息的内容提供程序。因此，任何具有适当权限的应用都可以查询内容提供程序的某一部分（如<code>ContactsContract.Data</code>），以读取和写入有关特定人员的信息。</p><p>内容提供程序也适用于读取和写入您的应用不共享的私有数据。例如，记事本示例应用使用内容提供程序来保存笔记。</p><h3 id="1-4-广播接收器"><a href="#1-4-广播接收器" class="headerlink" title="1.4. 广播接收器"></a>1.4. 广播接收器</h3><p>广播接收器是一种用于响应系统范围广播通知的组件。许多广播都是由系统发起的—-例如，通知屏幕已关闭、电池电量不足或已拍摄照片的广播。应用也可以发起广播—-例如，通知其他应用某些数据已下载至设备，并且可供其使用。尽管广播接收器不会显示用户界面，但它们可以创建状态栏通知，在发生广播事件时提醒用户。但广播接收器更常见的用途只是作为通向其他组件的”通道”，设计用于执行极少量的工作。例如，它可能会基于事件发起一项服务来执行某项工作。</p><h2 id="2-四大组件的启动方式"><a href="#2-四大组件的启动方式" class="headerlink" title="2. 四大组件的启动方式"></a>2. 四大组件的启动方式</h2><ul><li>您可以通过将Intent传递到<code>startActivity()</code>或<code>startActivityForResult()</code>（当您想让Activity返回结果时）来启动Activity（或为其安排新任务）。</li><li>您可以通过将Intent传递到<code>startService()</code>来启动服务（或对执行中的服务下达新指令）。或者，您也可以通过将Intent传递到<code>bindService()</code>来绑定到该服务。</li><li>您可以通过将Intent传递到<code>sendBroadcast()</code>、<code>sendOrderedBroadcast()</code>或<code>sendStickyBroadcast()</code>等方法来发起广播。</li><li>您可以通过在ContentResolver上调用<code>query()</code>来对内容提供程序执行查询。</li></ul><h2 id="3-画出Activity的生命周期图"><a href="#3-画出Activity的生命周期图" class="headerlink" title="3. 画出Activity的生命周期图"></a>3. 画出Activity的生命周期图</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/activity_lifecycle.png" alt="activity lifecycle"></p><h2 id="4-介绍下不同场景下Activity生命周期的变化过程"><a href="#4-介绍下不同场景下Activity生命周期的变化过程" class="headerlink" title="4. 介绍下不同场景下Activity生命周期的变化过程"></a>4. 介绍下不同场景下Activity生命周期的变化过程</h2><ul><li>启动Activity：<code>onCreate()</code> –&gt; <code>onStart()</code> –&gt; <code>onResume()</code>，Activity进入运行状态。</li><li>Activity退居后台：当前Activity转到新的Activity界面或按Home键回到主屏：<code>onPause()</code> –&gt; <code>onStop()</code>，进入停滞状态；这里有一种特殊情况，如果新Activity采用了透明主题，那么当前Activity不会回调<code>onStop()</code>。</li><li>Activity返回前台：<code>onRestart()</code> –&gt; <code>onStart()</code> –&gt; <code>onResume()</code>，再次回到运行状态。</li><li>Activity退居后台，且系统内存不足，系统会杀死这个后台状态的Activity，若再次回到这个Activity，则会走<code>onCreate()</code> –&gt; <code>onStart()</code> –&gt; <code>onResume()</code>。</li><li>锁定屏与解锁屏幕只会调用<code>onPause()</code>，而不会调用<code>onStop()</code>方法，开屏后则调用<code>onResume()</code>。</li></ul><h2 id="5-当Activity-A启动Activity-B时，生命周期执行过程？"><a href="#5-当Activity-A启动Activity-B时，生命周期执行过程？" class="headerlink" title="5. 当Activity A启动Activity B时，生命周期执行过程？"></a>5. 当Activity A启动Activity B时，生命周期执行过程？</h2><p><code>A.onPause()</code> –&gt; <code>B.onCreate()</code>，<code>B.onStart()</code>，<code>B.onResume()</code> –&gt; <code>A.onStop()</code>，如果B是个透明的，或者是对话框的样式，就不会调用<code>A.onStop()</code>。</p><h2 id="6-内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？"><a href="#6-内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？" class="headerlink" title="6. 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？"></a>6. 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？</h2><ul><li>Activity的<code>onSaveInstanceState()</code>和<code>onRestoreInstanceState()</code>并不是生命周期方法，它们不同于<code>onCreate()</code>、<code>onPause()</code>等生命周期方法，它们并不一定会被触发。</li><li>当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity，<code>onSaveInstanceState()</code>会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，<code>onSaveInstanceState()</code>就不会被调用。除非该activity是被用户主动销毁的，通常<code>onSaveInstanceState()</code>只适合用于保存一些临时性的状态，而<code>onPause()</code>适合用于数据的持久化保存。</li><li>重写<code>onSaveInstanceState()</code>方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写<code>onRestoreInstanceState()</code>方法可以从中提取保存好的数据。</li></ul><h2 id="7-什么是任务？"><a href="#7-什么是任务？" class="headerlink" title="7. 什么是任务？"></a>7. 什么是任务？</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/activity_task.png" alt="Activity Task"></p><p>任务是一个有机整体，当用户开始新任务或通过“主页”按钮转到主屏幕时，可以移动到“后台”。尽管在后台时，该任务中的所有Activity全部停止，但是任务的返回栈仍旧不变，也就是说，当另一个任务发生时，该任务仅仅失去焦点而已，如图所示。然后，任务可以返回到“前台”，用户就能够回到离开时的状态。</p><h2 id="8-Activity的启动模式？"><a href="#8-Activity的启动模式？" class="headerlink" title="8. Activity的启动模式？"></a>8. Activity的启动模式？</h2><ul><li>standard（默认模式）：系统在启动Activity的任务中创建Activity的新实例并向其传送Intent。Activity可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。</li><li>singleTop：如果当前任务的顶部已存在Activity的一个实例，则系统会通过调用该实例的onNewIntent()方法向其传送Intent，而不是创建Activity的新实例。Activity可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例（但前提是位于返回栈顶部的Activity并不是Activity的现有实例）。例如，假设任务的返回栈包含根Activity A以及Activity B、C和位于顶部的D（堆栈是A-B-C-D；D位于顶部）。收到针对D类Activity的Intent。如果D具有默认的”standard”启动模式，则会启动该类的新实例，且堆栈会变成A-B-C-D-D。但是，如果D的启动模式是”singleTop”，则D的现有实例会通过onNewIntent()接收Intent，因为它位于堆栈的顶部；而堆栈仍为A-B-C-D。但是，如果收到针对B类Activity的Intent，则会向堆栈添加B的新实例，即便其启动模式为”singleTop”也是如此。</li><li>singleTask：系统创建新任务并实例化位于新任务底部的Activity。但是，如果该Activity的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的onNewIntent()方法向其传送Intent，而不是创建新实例。一次只能存在Activity的一个实例。</li><li>singleInstace：与”singleTask”相同，只是系统不会将任何其他Activity启动到包含实例的任务中。该Activity始终是其任务唯一仅有的成员；由此Activity启动的任何Activity均在单独的任务中打开。</li></ul><h2 id="9-横竖屏切换时候activity的生命周期？"><a href="#9-横竖屏切换时候activity的生命周期？" class="headerlink" title="9. 横竖屏切换时候activity的生命周期？"></a>9. 横竖屏切换时候activity的生命周期？</h2><ul><li>不设置Activity的<code>android：configChanges</code>时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。</li><li>设置Activity的<code>android：configChanges=&quot;orientation&quot;</code>时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。</li><li>设置Activity的<code>android：configChanges=&quot;orientation|keyboardHidden&quot;</code>时，切屏不会重新调用各个生命周期，只会执行<code>onConfigurationChanged()</code>方法。</li></ul><h2 id="10-如何将一个Activity设置成窗口的样式？"><a href="#10-如何将一个Activity设置成窗口的样式？" class="headerlink" title="10. 如何将一个Activity设置成窗口的样式？"></a>10. 如何将一个Activity设置成窗口的样式？</h2><p>只需要给我们的Activity配置如下属性即可<code>android:theme=&quot;@android:style/Theme.Dialog&quot;</code>。</p><h2 id="11-Activity之间的数据传递有哪些方式？"><a href="#11-Activity之间的数据传递有哪些方式？" class="headerlink" title="11. Activity之间的数据传递有哪些方式？"></a>11. Activity之间的数据传递有哪些方式？</h2><ul><li><code>intent.putExtra()</code>方法；</li><li>使用全局变量Application；</li><li>使用静态变量；</li><li>剪切板ClipboardManager传递数据；</li><li>借助Application共享Handler利用消息处理机制；</li><li>使用Broadcast广播；</li><li>使用EventBus。</li></ul><h2 id="12-Fragment的好处："><a href="#12-Fragment的好处：" class="headerlink" title="12. Fragment的好处："></a>12. Fragment的好处：</h2><ul><li>Fragment可以使你能够将activity分离成多个可重用的组件，每个都有它自己的生命周期和UI。</li><li>Fragment可以轻松得创建动态灵活的UI设计，可以适应于不同的屏幕尺寸。从手机到平板电脑。</li><li>Fragment是一个独立的模块，紧紧地与activity绑定在一起。可以运行中动态地移除、加入、交换等。</li><li>Fragment提供一个新的方式让你在不同的安卓设备上统一你的UI。</li><li>Fragment解决Activity间的切换不流畅，轻量切换。</li><li>Fragment替代TabActivity做导航，性能更好。</li><li>Fragment在Android 4.2中新增嵌套fragment使用方法，能够生成更好的界面效果。</li></ul><h2 id="13-Intent的原理，作用，可以传递哪些类型的参数？"><a href="#13-Intent的原理，作用，可以传递哪些类型的参数？" class="headerlink" title="13. Intent的原理，作用，可以传递哪些类型的参数？"></a>13. Intent的原理，作用，可以传递哪些类型的参数？</h2><ul><li>Intent是连接Activity、Service、BroadcastReceiver和ContentProvider四大组件的信使，可以传递八种基本数据类型以及<code>String</code>、<code>Bundle</code>类型，以及实现了<code>Serializable</code>或者<code>Parcelable</code>的类型。</li><li><p>Intent可以划分成显式意图和隐式意图。</p><ul><li>显式意图：调用<code>Intent.setComponent()</code>或<code>Intent.setClass()</code>方法明确指定了组件名的Intent为显式意图，显式意图明确指定了Intent应该传递给哪个组件。</li><li>隐式意图：没有明确指定组件名的Intent为隐式意图。Android系统会根据隐式意图中设置的动作（<code>action</code>）、类别（<code>category</code>）、数据（URI和数据类型）找到最合适的组件来处理这个意图。</li></ul></li></ul><h2 id="14-Intent的主要使用方法"><a href="#14-Intent的主要使用方法" class="headerlink" title="14. Intent的主要使用方法"></a>14. Intent的主要使用方法</h2><h3 id="14-1-启动-Activity"><a href="#14-1-启动-Activity" class="headerlink" title="14.1. 启动 Activity"></a>14.1. 启动 Activity</h3><p>Activity表示应用中的一个屏幕。通过将Intent传递给<code>startActivity()</code>，您可以启动新的 Activity实例。Intent描述了要启动的Activity，并携带了任何必要的数据。</p><p>如果您希望在Activity完成后收到结果，请调用<code>startActivityForResult()</code>。在 Activity的<code>onActivityResult()</code>回调中，您的Activity将结果作为单独的Intent对象接收。</p><h3 id="14-2-启动服务"><a href="#14-2-启动服务" class="headerlink" title="14.2. 启动服务"></a>14.2. 启动服务</h3><p>Service是一个不使用用户界面而在后台执行操作的组件。通过将Intent传递给<code>startService()</code>，您可以启动服务执行一次性操作（例如，下载文件）。Intent描述了要启动的服务，并携带了任何必要的数据。</p><p>如果服务旨在使用客户端——服务器接口，则通过将Intent传递给<code>bindService(</code>)，您可以从其他组件绑定到此服务。</p><h3 id="14-3-传递广播"><a href="#14-3-传递广播" class="headerlink" title="14.3. 传递广播"></a>14.3. 传递广播</h3><p>广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将Intent传递给<code>sendBroadcast()</code>、<code>sendOrderedBroadcast()</code>或<code>sendStickyBroadcast()</code>，您可以将广播传递给其他应用。</p><h2 id="15-Intent包含哪些信息"><a href="#15-Intent包含哪些信息" class="headerlink" title="15. Intent包含哪些信息"></a>15. Intent包含哪些信息</h2><ul><li>组件名称：要启动的组件名称。</li><li>操作：指定要执行的通用操作（例如，“查看”或“选取”）的字符串。</li><li>数据：引用待操作数据和／或该数据MIME类型的URI（Uri对象）。提供的数据类型通常由Intent的操作决定。例如，如果操作是<code>ACTION_EDIT</code>，则数据应包含待编辑文档的URI。</li><li>类别：一个包含应处理Intent组件类型的附加信息的字符串。</li><li>Extra：携带完成请求操作所需的附加信息的键值对。</li><li>标志：在Intent类中定义的、充当Intent元数据的标志。</li></ul><h2 id="16-什么是Intent过滤器"><a href="#16-什么是Intent过滤器" class="headerlink" title="16. 什么是Intent过滤器"></a>16. 什么是Intent过滤器</h2><p>要公布应用可以接收哪些隐式Intent，请在清单文件中使用<code>&lt;intent-filter&gt;</code>元素为每个应用组件声明一个或多个Intent过滤器。每个Intent过滤器均由应用清单文件中的<code>&lt;intent-filter&gt;</code>元素定义，并嵌套在相应的应用组件（例如，<code>&lt;activity&gt;</code>元素）中。在<code>&lt;intent-filter&gt;</code>内部，您可以使用以下三个元素中的一个或多个指定要接受的Intent类型：</p><ul><li><code>&lt;action&gt;</code>：在<code>name</code>属性中，声明接受的Intent操作。该值必须是操作的文本字符串值，而不是类常量。</li><li><code>&lt;data&gt;</code>：使用一个或多个指定数据URI各个方面（scheme、host、port、path等）和MIME类型的属性，声明接受的数据类型。</li><li><code>&lt;category&gt;</code>：在<code>name</code>属性中，声明接受的Intent类别。该值必须是操作的文本字符串值，而不是类常量。</li></ul><h2 id="17-Service的启动方式"><a href="#17-Service的启动方式" class="headerlink" title="17. Service的启动方式"></a>17. Service的启动方式</h2><ul><li><code>startService()</code>：只是启动Service，Activity和Service并没有绑定，只有当Service调用<code>stopService()</code>服务才会终止。</li><li><code>bindService()</code>：这种启动方式Activity和Service进行了绑定，启动Service的组件可以通过回调获取Service的代理对象和Service交互；当启动方销毁时，Service也会自动进行<code>unBind()</code>操作，当发现所有绑定都进行了<code>unBind()</code>时才会销毁Service。</li></ul><h2 id="18-Service的生命周期"><a href="#18-Service的生命周期" class="headerlink" title="18. Service的生命周期"></a>18. Service的生命周期</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/service_lifecycle.png" alt="service lifecycle"></p><h2 id="19-Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？"><a href="#19-Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？" class="headerlink" title="19. Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？"></a>19. Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？</h2><ul><li>Activity通过<code>bindService(Intent service，ServiceConnection conn，int flags)</code>跟Service进行绑定，当绑定成功的时候Service会将代理对象通过回调的形式传给<code>conn</code>，这样我们就拿到了Service提供的服务代理对象。</li><li>在Activity中可以通过<code>startService()</code>和<code>bindService()</code>方法启动Service。一般情况下如果想获取Service的服务对象那么肯定需要通过<code>bindService()</code>方法，比如音乐播放器，第三方支付等。如果仅仅只是为了开启一个后台任务那么可以使用<code>startService()</code>方法。</li></ul><h2 id="20-允许绑定的已启动服务的生命周期"><a href="#20-允许绑定的已启动服务的生命周期" class="headerlink" title="20. 允许绑定的已启动服务的生命周期"></a>20. 允许绑定的已启动服务的生命周期</h2><p>当服务与所有客户端之间的绑定全部取消时，Android系统便会销毁服务。不过，如果您选择实现<code>onStartCommand()</code>回调方法，则您必须显式停止服务，因为系统现在已将服务视为已启动。在此情况下，服务将一直运行到其通过<code>stopSelf()</code>自行停止，或其他组件调用<code>stopService()</code>为止，无论其是否绑定到任何客户端。</p><p>此外，如果您的服务已启动并接受绑定，则当系统调用您的<code>onUnbind()</code>方法时，如果您想在客户端下一次绑定到服务时接收<code>onRebind()</code>调用，则可选择返回true。<code>onRebind()</code>返回空值，但客户端仍在其<code>onServiceConnected()</code>回调中接收IBinder。</p><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/service_binding_tree_lifecycle.png" alt="service binding tree lifecycle"></p><h2 id="21-Service中可以弹Toast吗？"><a href="#21-Service中可以弹Toast吗？" class="headerlink" title="21. Service中可以弹Toast吗？"></a>21. Service中可以弹Toast吗？</h2><ul><li>这个问题其实就是问一下Service是执行在UI线程中吗？类似的问题还有”Service的<code>onCreate()</code>回调函数可以做耗时的操作吗？”，”Service是否在main thread中执行”，”Service和Activity在同一个线程吗？”等；</li><li>我们要牢记一句真理”默认情况下四大组件都是在UI线程中执行的”，Service本身就是Context的子类，我们可以获取到Context对象，所以Service中当然可以弹Toast，同理，Service的<code>onCreate()</code>回调函数不可以做耗时的操作。</li></ul><h2 id="22-进程的优先级"><a href="#22-进程的优先级" class="headerlink" title="22. 进程的优先级"></a>22. 进程的优先级</h2><h3 id="22-1-前台进程"><a href="#22-1-前台进程" class="headerlink" title="22.1. 前台进程"></a>22.1. 前台进程</h3><p>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</p><ul><li>托管用户正在交互的Activity（已调用Activity的<code>onResume()</code>方法）；</li><li>托管某个Service，后者绑定到用户正在交互的Activity；</li><li>托管正在”前台”运行的Service（服务已调用<code>startForeground()</code>）；</li><li>托管正执行一个生命周期回调的Service（<code>onCreate()</code>、<code>onStart()</code>或<code>onDestroy()</code>）；</li><li>托管正执行其<code>onReceive()</code>方法的BroadcastReceiver。</li></ul><p>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</p><h3 id="22-2-可视进程"><a href="#22-2-可视进程" class="headerlink" title="22.2. 可视进程"></a>22.2. 可视进程</h3><p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。如果一个进程满足以下任一条件，即视为可见进程：</p><ul><li>托管不在前台、但仍对用户可见的Activity（已调用其<code>onPause()</code>方法）。例如，如果前台Activity启动了一个对话框，允许在其后显示上一Activity，则有可能会发生这种情况。</li><li>托管绑定到可见（或前台）Activity的Service。</li></ul><p>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p><h3 id="22-3-服务进程"><a href="#22-3-服务进程" class="headerlink" title="22.3. 服务进程"></a>22.3. 服务进程</h3><p>正在运行已使用<code>startService()</code>方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p><h3 id="22-4-后台进程"><a href="#22-4-后台进程" class="headerlink" title="22.4. 后台进程"></a>22.4. 后台进程</h3><p>包含目前对用户不可见的Activity的进程（已调用Activity的<code>onStop()</code>方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。通常会有很多后台进程在运行，因此它们会保存在LRU（最近最少使用）列表中，以确保包含用户最近查看的Activity的进程最后一个被终止。如果某个Activity正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该Activity时，Activity会恢复其所有可见状态。</p><h3 id="22-5-空进程"><a href="#22-5-空进程" class="headerlink" title="22.5. 空进程"></a>22.5. 空进程</h3><p>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p><h2 id="23-IntentService如何工作？"><a href="#23-IntentService如何工作？" class="headerlink" title="23. IntentService如何工作？"></a>23. IntentService如何工作？</h2><ul><li>创建默认的工作线程，用于在应用的主线程外执行传递给<code>onStartCommand()</code>的所有Intent。</li><li>创建工作队列，用于将Intent逐一传递给<code>onHandleIntent()</code>实现，这样您就永远不必担心多线程问题。</li><li>在处理完所有启动请求后停止服务，因此您永远不必调用<code>stopSelf()</code>。</li><li>提供<code>onBind()</code>的默认实现（返回<code>null</code>）。</li><li>提供<code>onStartCommand()</code>的默认实现，可将Intent依次发送到工作队列和<code>onHandleIntent()</code>实现。</li></ul><h2 id="24-IntentService与Service的区别？"><a href="#24-IntentService与Service的区别？" class="headerlink" title="24. IntentService与Service的区别？"></a>24. IntentService与Service的区别？</h2><ul><li>Service也不是专门一条新线程，因此不应该在Service中直接处理耗时的任务；</li><li>Service不会专门启动一条单独的进程，Service与它所在应用位于同一个进程中；</li><li>IntentService是Service的子类，是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题；</li><li>IntentService会创建独立的worker线程来处理所有的Intent请求；</li><li>IntentService不会阻塞UI线程，而普通Serveice会导致ANR异常；</li><li>Intentservice若未执行完成上一次的任务，将不会新开一个线程，是等待之前的任务完成后，再执行新的任务，等任务完成后再次调用<code>stopSelf()</code>；</li><li>正在运行的IntentService的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。</li></ul><h2 id="25-Android-Service与Activity之间的通信方式？"><a href="#25-Android-Service与Activity之间的通信方式？" class="headerlink" title="25. Android Service与Activity之间的通信方式？"></a>25. Android Service与Activity之间的通信方式？</h2><ul><li><p>通过Binder对象：当Activity通过调用<code>bindService(Intent service，ServiceConnection conn，int flags)</code>，得到一个Service的一个对象，通过这个对象我们可以直接访问Service中的方法。</p><ul><li>添加一个继承Binder的内部类，并添加相应的逻辑方法。</li><li>重写Service的<code>onBind()</code>方法，返回我们刚刚定义的那个内部类实。</li><li>Activity中创建一个ServiceConnection的匿名内部类，并且重写里面的<code>onServiceConnected()</code>方法和<code>onServiceDisconnected()</code>方法，这两个方法分别会在活动与服务成功绑定以及解除绑定的时候调用，在<code>onServiceConnected()</code>方法中，我们可以得到一个刚才那个service的binder对象，通过对这个binder对象进行向下转型，得到我们那个自定义的Binder实例，有了这个实例，做可以调用这个实例里面的具体方法进行需要的操作了。</li></ul></li><li><p>通过Broadcast Receiver：当我们的进度发生变化的时候我们发送一条广播，然后在Activity的注册广播接收器，接收到广播之后更新视图</p></li><li><p>EventBus</p></li></ul><h2 id="26-BroadcastReceiver简介"><a href="#26-BroadcastReceiver简介" class="headerlink" title="26. BroadcastReceiver简介"></a>26. BroadcastReceiver简介</h2><p>在Android中，Broadcast是一种广泛运用的在应用程序之间传输信息的机制。</p><h3 id="26-1-用途"><a href="#26-1-用途" class="headerlink" title="26.1. 用途"></a>26.1. 用途</h3><ul><li>实现了不同的程序之间的数据传输与共享，因为只要是和发送广播的<code>action</code>相同的接受者都能接受这个广播。典型的应用就是Android自带的短信，电话等等广播，只要我们实现了他们的<code>action</code>的广播，那么我们就能接收他们的数据了，以便做出一些处理。比如说拦截系统短信，拦截骚扰电话等。</li><li>起到了一个通知的作用，比如在Service中要通知主程序，更新主程序的UI等。因为Service是没有界面的，所以不能直接获得主程序中的控件，这样我们就只能在主程序中实现一个广播接受者专门用来接受Service发过来的数据和通知了。</li></ul><h3 id="26-2-使用场景"><a href="#26-2-使用场景" class="headerlink" title="26.2. 使用场景"></a>26.2. 使用场景</h3><ul><li>同一app内部的同一组件内的消息通信（单个或多个线程之间）；</li><li>同一app内部的不同组件之间的消息通信（单个进程）；</li><li>同一app具有多个进程的不同组件之间的消息通信；</li><li>不同app之间的组件之间消息通信；</li><li>Android系统在特定情况下与App之间的消息通信。</li></ul><h3 id="26-3-实现原理"><a href="#26-3-实现原理" class="headerlink" title="26.3. 实现原理"></a>26.3. 实现原理</h3><p>从实现原理看上，Android中的广播使用了观察者模式，基于消息的发布/订阅事件模型。因此，从实现的角度来看，Android中的广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。具体实现流程要点粗略概括如下：</p><ol><li>广播接收者BroadcastReceiver通过Binder机制向AMS（Activity Manager Service)进行注册；</li><li>广播发送者通过binder机制向AMS发送广播；</li><li>AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；</li><li>消息循环执行拿到此广播，回调BroadcastReceiver中的<code>onReceive()</code>方法。</li></ol><h3 id="26-4-注册方式"><a href="#26-4-注册方式" class="headerlink" title="26.4. 注册方式"></a>26.4. 注册方式</h3><ul><li>静态注册；</li><li>动态注册。</li></ul><h2 id="27-为什么要用ContentProvider？它和SQL的实现上有什么差别？"><a href="#27-为什么要用ContentProvider？它和SQL的实现上有什么差别？" class="headerlink" title="27. 为什么要用ContentProvider？它和SQL的实现上有什么差别？"></a>27. 为什么要用ContentProvider？它和SQL的实现上有什么差别？</h2><ul><li>ContentProvider屏蔽了数据存储的细节，内部实现对用户完全透明，用户只需要关心操作数据的uri就可以了，ContentProvider可以实现不同app之间共享。SQL只能在该工程的内部共享数据，ContentProvider能在工程之间实现数据共享。</li><li>SQL也有增删改查的方法，但是SQL只能查询本应用下的数据库。而ContentProvider还可以去增删改查本地文件.xml文件的读取等。</li></ul><h2 id="28-ContentProvider怎么实现数据共享？"><a href="#28-ContentProvider怎么实现数据共享？" class="headerlink" title="28. ContentProvider怎么实现数据共享？"></a>28. ContentProvider怎么实现数据共享？</h2><p>一个程序可以通过实现一个ContentProvider的抽象接口将自己的数据完全暴露出去，而且ContentProvider是以类似数据库中表的方式将数据暴露。ContentProvider存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的ContentProvider中，前提是有相同数据类型并且有写入ContentProvider的权限。</p><h2 id="29-Android如何访问自定义ContentProvider"><a href="#29-Android如何访问自定义ContentProvider" class="headerlink" title="29. Android如何访问自定义ContentProvider"></a>29. Android如何访问自定义ContentProvider</h2><ol><li>得到ContentResolver类对象：<code>ContentResolver cr = getContentResolver()</code>；</li><li>定义要查询的字段<code>String</code>数组；</li><li>使用<code>cr.query()</code>返回一个<code>Cursor</code>对象；</li><li>使用<code>while</code>循环得到<code>Cursor</code>里面的内容。</li></ol><h2 id="30-Android中Activity，Intent，Content-Provider，Service各有什么区别。"><a href="#30-Android中Activity，Intent，Content-Provider，Service各有什么区别。" class="headerlink" title="30. Android中Activity，Intent，Content Provider，Service各有什么区别。"></a>30. Android中Activity，Intent，Content Provider，Service各有什么区别。</h2><ul><li>Activity：活动，是最基本的Android应用程序组件。一个活动就是一个单独的屏幕，每一个活动都被实现为一个独立的类，并且从活动基类继承而来。</li><li>Intent：意图，描述应用想干什么。最重要的部分是动作和动作对应的数据。</li><li>Content Provider：内容提供器，Android应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当你想将你的应用数据和其他应用共享时，内容提供器就可以发挥作用了。</li><li>Service：服务，具有一段较长生命周期且没有用户界面的程序。</li></ul><h2 id="31-Android数据存储方式？"><a href="#31-Android数据存储方式？" class="headerlink" title="31. Android数据存储方式？"></a>31. Android数据存储方式？</h2><ul><li>SharedPreferences：以键值对的形式保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。</li><li>文件存储数据：Context提供了两个方法来打开数据文件里的文件IO流<code>FileInputStream openFileInput(String name)</code>，<code>FileOutputStream(String name，int mode)</code>，这两个方法第一个参数用于指定文件名，第二个参数指定打开文件的模式；文件默认存储位置：<code>/data/data/包名/files/文件名</code>。</li><li>SQLite存储数据。</li><li>使用ContentProvider存储数据。</li><li>网络存储数据。</li></ul><h2 id="32-Android中常用的布局都有哪些？"><a href="#32-Android中常用的布局都有哪些？" class="headerlink" title="32. Android中常用的布局都有哪些？"></a>32. Android中常用的布局都有哪些？</h2><ul><li>FrameLayout；</li><li>RelativeLayout；</li><li>LinearLayout；</li><li>AbsoluteLayout；</li><li>TableLayout；</li><li>GridLayout。</li></ul><h2 id="33-android-layout-gravity和android-gravity的区别？"><a href="#33-android-layout-gravity和android-gravity的区别？" class="headerlink" title="33. android:layout_gravity和android:gravity的区别？"></a>33. <code>android:layout_gravity</code>和<code>android:gravity</code>的区别？</h2><ul><li><code>android:layout_gravity</code>是让该布局在其父控件中的布局方式。</li><li><code>android:gravity</code>是该布局布置其子对象的布局方式。</li></ul><h2 id="34-Android平台架构"><a href="#34-Android平台架构" class="headerlink" title="34. Android平台架构"></a>34. Android平台架构</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/android_platform.png" alt="android platform"></p><h3 id="34-1-系统应用"><a href="#34-1-系统应用" class="headerlink" title="34.1. 系统应用"></a>34.1. 系统应用</h3><p>Android随附一套用于电子邮件、短信、日历、互联网浏览和联系人等的核心应用。平台随附的应用与用户可以选择安装的应用一样，没有特殊状态。因此第三方应用可成为用户的默认网络浏览器、短信Messenger甚至默认键盘（有一些例外，例如系统的”设置”应用）。</p><p>系统应用可用作用户的应用，以及提供开发者可从其自己的应用访问的主要功能。例如，如果您的应用要发短信，您无需自己构建该功能，可以改为调用已安装的短信应用向您指定的接收者发送消息。</p><h3 id="34-2-Java-API框架"><a href="#34-2-Java-API框架" class="headerlink" title="34.2. Java API框架"></a>34.2. Java API框架</h3><p>您可通过以Java语言编写的API使用Android OS的整个功能集。这些API形成创建Android应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务：</p><ul><li>丰富、可扩展的视图系统，可用以构建应用的UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器；</li><li>资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件；</li><li>通知管理器，可让所有应用在状态栏中显示自定义提醒；</li><li>Activity管理器，用于管理应用的生命周期，提供常见的导航返回栈；</li><li>内容提供程序，可让应用访问其他应用（例如”联系人”应用）中的数据或者共享其自己的数据。</li></ul><p>开发者可以完全访问Android系统应用使用的框架API。</p><h3 id="34-3-原生C-C-库"><a href="#34-3-原生C-C-库" class="headerlink" title="34.3. 原生C/C++库"></a>34.3. 原生C/C++库</h3><p>许多核心Android系统组件和服务（例如ART和HAL）构建自原生代码，需要以C和C++编写的原生库。Android平台提供Java框架API以向应用显示其中部分原生库的功能。例如，您可以通过Android框架的Java OpenGL API访问OpenGL ES，以支持在应用中绘制和操作2D和3D图形。</p><p>如果开发的是需要C或C++代码的应用，可以使用Android NDK直接从原生代码访问某些原生平台库。</p><h3 id="34-4-Android-Runtime"><a href="#34-4-Android-Runtime" class="headerlink" title="34.4. Android Runtime"></a>34.4. Android Runtime</h3><p>对于运行Android 5.0（API级别21）或更高版本的设备，每个应用都在其自己的进程中运行，并且有其自己的Android Runtime(ART)实例。ART编写为通过执行DEX文件在低内存设备上运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如Jack）将Java源代码编译为DEX字节码，使其可在Android平台上运行。</p><p>ART的部分主要功能包括：</p><ul><li>预先（AOT）和即时（JIT）编译；</li><li>优化的垃圾回收（GC）；</li><li>更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置监视点以监控特定字段；</li></ul><p>在Android版本5.0（API级别21）之前，Dalvik是Android Runtime。如果您的应用在ART上运行效果很好，那么它应该也可在Dalvik上运行，但反过来不一定。</p><p>Android还包含一套核心运行时库，可提供Java API框架使用的Java编程语言大部分功能，包括一些Java 8语言功能。</p><h3 id="34-5-硬件抽象层（HAL）"><a href="#34-5-硬件抽象层（HAL）" class="headerlink" title="34.5. 硬件抽象层（HAL）"></a>34.5. 硬件抽象层（HAL）</h3><p>硬件抽象层（HAL）提供标准界面，向更高级别的Java API框架显示设备硬件功能。HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当框架API要求访问设备硬件时，Android系统将为该硬件组件加载库模块。</p><h3 id="34-6-Linux-内核"><a href="#34-6-Linux-内核" class="headerlink" title="34.6. Linux 内核"></a>34.6. Linux 内核</h3><p>Android平台的基础是Linux内核。例如，Android Runtime（ART）依靠Linux内核来执行底层功能，例如线程和低层内存管理。</p><p>使用Linux内核可让Android利用主要安全功能，并且允许设备制造商为著名的内核开发硬件驱动程序。</p><h2 id="35-Fragment生命周期"><a href="#35-Fragment生命周期" class="headerlink" title="35. Fragment生命周期"></a>35. Fragment生命周期</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/fragment_lifecycle.png" alt="fragment lifecycle"></p><ul><li><code>onCreate()</code>：系统会在创建片段时调用此方法。您应该在实现内初始化您想在片段暂停或停止后恢复时保留的必需片段组件。</li><li><code>onCreateView()</code>：系统会在片段首次绘制其用户界面时调用此方法。要想为您的片段绘制UI，您从此方法中返回的View必须是片段布局的根视图。如果片段未提供UI，您可以返回<code>null</code>。</li><li><code>onPause()</code>：系统将此方法作为用户离开片段的第一个信号（但并不总是意味着此片段会被销毁）进行调用。您通常应该在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。</li></ul><h2 id="36-Activity生命周期对片段生命周期的影响"><a href="#36-Activity生命周期对片段生命周期的影响" class="headerlink" title="36. Activity生命周期对片段生命周期的影响"></a>36. Activity生命周期对片段生命周期的影响</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/activity_fragment_lifecycle.png" alt="activity fragment lifecycle"></p><p>片段所在的Activity的生命周期会直接影响片段的生命周期，其表现为，Activity的每次生命周期回调都会引发每个片段的类似回调。例如，当Activity收到<code>onPause()</code>时，Activity中的每个片段也会收到<code>onPause()</code>。</p><p>不过，片段还有几个额外的生命周期回调，用于处理与Activity的唯一交互，以执行构建和销毁片段UI等操作。这些额外的回调方法是：</p><ul><li><code>onAttach()</code>：在片段已与Activity关联时调用（Activity传递到此方法内）；</li><li><code>onCreateView()</code>：调用它可创建与片段关联的视图层次结构；</li><li><code>onActivityCreated()</code>：在Activity的<code>onCreate()</code>方法已返回时调用；</li><li><code>onDestroyView()</code>：在移除与片段关联的视图层次结构时调用；</li><li><code>onDetach()</code>：在取消片段与Activity的关联时调用。</li></ul><h2 id="37-Android事件分发"><a href="#37-Android事件分发" class="headerlink" title="37. Android事件分发"></a>37. Android事件分发</h2><table><thead><tr><th style="text-align:center">事件相关方法</th><th style="text-align:center">方法功能</th><th style="text-align:center">Activity</th><th style="text-align:center">ViewGroup</th><th style="text-align:center">View</th></tr></thead><tbody><tr><td style="text-align:center"><code>dispatchTouchEvent</code></td><td style="text-align:center">事件分发</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:center"><code>onInterceptTouchEvent</code></td><td style="text-align:center">事件拦截</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center"><code>onTouchEvent</code></td><td style="text-align:center">事件消费</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr></tbody></table><h3 id="37-1-public-boolean-dispatchTouchEvent-MotionEvent-ev"><a href="#37-1-public-boolean-dispatchTouchEvent-MotionEvent-ev" class="headerlink" title="37.1. public boolean dispatchTouchEvent(MotionEvent ev)"></a>37.1. <code>public boolean dispatchTouchEvent(MotionEvent ev)</code></h3><p>当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的<code>dispatchTouchEvent(MotionEvent ev)</code>方法，该方法对事件进行分发。</p><ul><li><code>return true</code>：表示该View内部消化掉了所有事件。</li><li><code>return false</code>：事件在本层不再继续进行分发，并交由上层控件的<code>onTouchEvent()</code>方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。</li><li>如果事件分发返回系统默认的<code>super.dispatchTouchEvent(ev)</code>，事件将分发给本层的事件拦截<code>onInterceptTouchEvent()</code>方法进行处理。</li></ul><h3 id="37-2-public-boolean-onInterceptTouchEvent-MotionEvent-ev"><a href="#37-2-public-boolean-onInterceptTouchEvent-MotionEvent-ev" class="headerlink" title="37.2. public boolean onInterceptTouchEvent(MotionEvent ev)"></a>37.2. <code>public boolean onInterceptTouchEvent(MotionEvent ev)</code></h3><ul><li><code>return true</code>：表示将事件进行拦截，并将拦截到的事件交由本层控件的<code>onTouchEvent()</code>进行处理。</li><li><code>return false</code>：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的<code>dispatchTouchEvent()</code>进行处理。</li><li>如果返回<code>super.onInterceptTouchEvent(ev)</code>，默认表示拦截该事件，并将事件传递给当前View的<code>onTouchEvent()</code>方法，和<code>return true</code>一样。</li></ul><h3 id="37-3-public-boolean-onTouchEvent-MotionEvent-ev"><a href="#37-3-public-boolean-onTouchEvent-MotionEvent-ev" class="headerlink" title="37.3. public boolean onTouchEvent(MotionEvent ev)"></a>37.3. <code>public boolean onTouchEvent(MotionEvent ev)</code></h3><p>在<code>dispatchTouchEvent()</code>（事件分发）返回<code>super.dispatchTouchEvent(ev)</code>并且<code>onInterceptTouchEvent()</code>（事件拦截返回<code>true</code>或<code>super.onInterceptTouchEvent(ev)</code>的情况下，那么事件会传递到<code>onTouchEvent()</code>方法，该方法对事件进行响应。</p><ul><li>如果<code>return true</code>，表示<code>onTouchEvent()</code>处理完事件后消费了此次事件。此时事件终结。</li><li>如果<code>return fasle</code>，则表示不响应事件，那么该事件将会不断向上层View的<code>onTouchEvent()</code>方法传递，直到某个View的<code>onTouchEvent()</code>方法返回<code>true</code>，如果到了最顶层View还是返回<code>false</code>，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的<code>onTouchEvent()</code>进行处理。</li><li>如果<code>return super.dispatchTouchEvent(ev)</code>，则表示不响应事件，结果与<code>return false</code>一样。</li></ul><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/touch_eventbus.gif" alt="touch eventbus"></p><ul><li>如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的<code>onTouchEvent()</code>不会被触发。</li><li>可以通过复写<code>onInterceptTouchEvent(ev)</code>方法，拦截子View的事件（即<code>return true</code>），把事件交给自己处理，则会执行自己对应的<code>onTouchEvent()</code>方法。</li><li>子View可以通过调用<code>getParent().requestDisallowInterceptTouchEvent(true)</code>阻止ViewGroup对其<code>MOVE</code>或者<code>UP</code>事件进行拦截。</li><li>一个点击事件产生后，它的传递过程如下：Activity-&gt;Window-&gt;View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的<code>onTouchEvent()</code>方法返回<code>false</code>，那么将会交给父容器的<code>onTouchEvent()</code>方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的<code>onTouchEvent()</code>进行处理。</li><li>如果某一个View开始处理事件，如果他不消耗<code>ACTION_DOWN</code>事件（也就是<code>onTouchEvent()</code>返回<code>false</code>），则同一事件序列比如接下来进行<code>ACTION_MOVE</code>，则不会再交给该View处理。</li><li>ViewGroup默认不拦截任何事件。</li><li>诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用<code>onTouchEvent()</code>方法，它们本身没有<code>onInterceptTouchEvent()</code>方法。正常情况下，它们都会消耗事件（返回<code>true</code>），除非它们是不可点击的（<code>clickable</code>和<code>longClickable</code>都为<code>false</code>），那么就会交由父容器的<code>onTouchEvent()</code>处理。</li><li>点击事件分发过程如下<code>dispatchTouchEvent()</code> —&gt; <code>OnTouchListener</code>的<code>onTouch()</code>方法 —&gt; <code>onTouchEvent()</code> –&gt; <code>OnClickListener</code>的<code>onClick()</code>方法。也就是说，我们平时调用的<code>setOnClickListener()</code>，优先级是最低的，所以，<code>onTouchEvent()</code>或<code>OnTouchListener()</code>的<code>onTouch()</code>方法如果返回<code>true</code>，则不响应<code>onClick()</code>方法。</li></ul><p>参考：<a href="https://github.com/Mr-YangCheng/ForAndroidInterview/blob/master/android/Android%20View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">ForAndroidInterview/Android View事件分发机制源码分析.md at master · Mr-YangCheng/ForAndroidInterview</a></p><p>参考：<a href="https://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html" target="_blank" rel="noopener">Android 编程下 Touch 事件的分发和消费机制 - sunzn - 博客园</a></p><h2 id="38-Android系统启动过程"><a href="#38-Android系统启动过程" class="headerlink" title="38. Android系统启动过程"></a>38. Android系统启动过程</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/android_boot_process.png" alt="android boot process"></p><h3 id="38-1-Boot-ROM"><a href="#38-1-Boot-ROM" class="headerlink" title="38.1. Boot ROM"></a>38.1. Boot ROM</h3><p>Android设备上电后，首先会从处理器片上ROM的启动引导代码开始执行，片上ROM会寻找Bootloader代码，并加载到内存。</p><h3 id="38-2-Boot-Loader"><a href="#38-2-Boot-Loader" class="headerlink" title="38.2. Boot Loader"></a>38.2. Boot Loader</h3><p>BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。</p><h3 id="38-3-Kernel"><a href="#38-3-Kernel" class="headerlink" title="38.3. Kernel"></a>38.3. Kernel</h3><p>Android内核启动时，会设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。</p><h3 id="38-4-init"><a href="#38-4-init" class="headerlink" title="38.4. init"></a>38.4. init</h3><p>init进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。init始终是第一个进程。</p><p>init程序最核心的工作主要有3点：</p><ul><li>创建和挂载一些系统目录/设备节点，设置权限，如：<code>/dev</code>，<code>/proc</code>，和<code>/sys</code>；</li><li>解析init.rc，并启动属性服务，以及一系列的服务和进程；</li><li>显示boot logo，默认是”Android”字样。</li></ul><p>第二步的这些服务包含2部分，一部分是本地服务，另一部分是Android服务，所有的这些服务都会向ServiceManager进程注册，由它统一管理，这些服务的启动过程介绍如下：</p><h4 id="38-4-1-本地服务"><a href="#38-4-1-本地服务" class="headerlink" title="38.4.1. 本地服务"></a>38.4.1. 本地服务</h4><p>本地服务是指运行在C++层的系统守护进程，一部分本地服务是init进程直接启动的，它们定义在init.rc脚本中，如ueventd、servicemanager、debuggerd、rild、mediaserver等。还有一部分本地服务，是由这些本地服务进一步创建的，如mediaserver服务会启动AudioFlinger，MediaPlayerService，以及CameraService等本地服务。</p><p>注意，每一个由init直接启动的本地服务都是一个独立的Linux进程，在系统启动以后，我们通过<code>adb shell</code>命令进入手机后，输入<code>top</code>命令就可以查看到这些本地进程的存在。</p><h4 id="38-4-2-Android服务"><a href="#38-4-2-Android服务" class="headerlink" title="38.4.2. Android服务"></a>38.4.2. Android服务</h4><p>init进程会执行app_process程序，创建Zygote进程，它是Android系统最重要的进程，所有后续的Android应用程序都是由它<code>fork</code>出来的。</p><p>Zygote进程会首先<code>fork</code>出SystemServer进程，SystemServer进程的全部任务就是将所有的Android核心服务启动起来。</p><h3 id="38-5-Zygote-and-Dalvik（ART）"><a href="#38-5-Zygote-and-Dalvik（ART）" class="headerlink" title="38.5. Zygote and Dalvik（ART）"></a>38.5. Zygote and Dalvik（ART）</h3><p>Zygote被init进程启动，开始运行和初始化dalvik虚拟机。</p><h3 id="38-6-System-Server"><a href="#38-6-System-Server" class="headerlink" title="38.6. System Server"></a>38.6. System Server</h3><p>系统服务是在系统中运行的第一个java组件，它会启动所有的Android服务，比如：电话服务，蓝牙服务，每个服务的启动被直接写在<code>SystemServer.java</code>这个类的<code>run()</code>方法里面。</p><h3 id="38-7-Boot-completed"><a href="#38-7-Boot-completed" class="headerlink" title="38.7. Boot completed"></a>38.7. Boot completed</h3><p>一旦系统服务启动并运行，Android系统启动就完成了，同时发出<code>ACTION_BOOT_COMPLETED</code>广播。</p><h2 id="39-Android应用启动过程"><a href="#39-Android应用启动过程" class="headerlink" title="39. Android应用启动过程"></a>39. Android应用启动过程</h2><ol><li>Launcher接收到点击事件，获取应用的信息，向SystemServer（ActivityManagerService简称AMS运行在里面）发起启动应用的请求；</li><li>SystemServer（AMS）请求Launcher Pause（Launcher需要保存状态进入后台）；</li><li>LauncherPause，向SystemServer（AMS）发送Pause完毕；</li><li>SystemServer（AMS）向Zygote请求启动一个新进程（calculator）；</li><li>Zygote fork出新进程（calculator），在新进程中执行ActivityThread类的<code>main()</code>方法；</li><li>calculator向SystemServer（AMS）请求attach到AMS；</li><li>SystemServer（AMS）请求calculator launch；</li><li>calculator调用<code>onCreate()</code>，<code>onResume()</code>回调；</li><li>calculator界面显示自屏幕上（还需细分）。</li></ol><p>参考：<a href="http://androidzhibinw.github.io/android/app/startup/activity/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/%E5%90%AF%E5%8A%A8/%E5%88%86%E6%9E%90/2015/09/21/android-app-startup-process/" target="_blank" rel="noopener">Android 应用程序启动过程分析</a></p><h2 id="40-dp，dip，dpi，ppi区别"><a href="#40-dp，dip，dpi，ppi区别" class="headerlink" title="40. dp，dip，dpi，ppi区别"></a>40. dp，dip，dpi，ppi区别</h2><p>px（Pixels，像素）：屏幕上的点。 in（Inch，英寸）：长度单位。 mm（Millimeter，毫米）：长度单位。 pt（Point，磅）：1/72in。 dpi（Dots Per Inch，每英寸所打印的点数）：1in长度的点数。 ppi（Pixels Per Inch，像素密度）：1in长度的像素点数。 dp/dip（Density-independent Pixels，与密度无关的像素）：一种基于屏幕密度的抽象单位。在160dpi的显示器上，1dp = 1px。 sp（Scale-independent Pixels，与刻度无关的像素）：与dp类似，但是可以根据用户的字体大小首选项进行缩放。</p><p>在屏幕密度为160dpi，1dp = 1px，1pt = 160/72sp，1pt = 1/72in。当屏幕密度为240dpi时，1dp = 1.5px。</p><p>参考：<a href="http://stackoverflow.com/questions/8478882/how-do-dp-dip-dpi-ppi-pixels-and-inches-relate" target="_blank" rel="noopener">mobile - How do dp, dip, dpi, ppi, pixels and inches relate? - Stack Overflow</a></p><h2 id="41-长度和字体的推荐单位"><a href="#41-长度和字体的推荐单位" class="headerlink" title="41. 长度和字体的推荐单位"></a>41. 长度和字体的推荐单位</h2><p>长度推荐dp（Density-independent Pixels），字号大小推荐sp（Scale-independent Pixels）。</p><h2 id="42-Android-View绘制流程"><a href="#42-Android-View绘制流程" class="headerlink" title="42. Android View绘制流程"></a>42. Android View绘制流程</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/android_draw_view_flow.png" alt="android_draw_view_flow"></p><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/android_draw_view_chain.png" alt="android_draw_view_chain"></p><p>参考：<a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tech/viewdrawflow" target="_blank" rel="noopener">android-open-project-analysis/tech/viewdrawflow at master · android-cn/android-open-project-analysis</a></p><p>参考：<a href="http://vincgao.com/2016/02/android-layout/" target="_blank" rel="noopener">Android Layout绘制</a></p><h2 id="43-ListView优化"><a href="#43-ListView优化" class="headerlink" title="43. ListView优化"></a>43. ListView优化</h2><ul><li>复用convertView：用以避免重复创建View，重复创建View代价较大，而且如果重用view不改变宽高，重用View可以减少重新分配缓存造成的内存频繁分配/回收。</li><li>使用View Holder模式：findViewById的实现是遍历，如果你定义的View越复杂代价越大。 Google推荐的做法是用ViewHolder，然后保存在view的tag中。现在RecyclerView也是强制使用ViewHolder了。</li><li>分批加载与分页加载相结合：不需要一次等待好几分钟把数据都加载完再在ListView上显示。</li><li>使用异步线程加载图片</li><li>在快速滑动时不要加载图片</li><li>使用RecyclerView</li></ul><h2 id="44-Android-Binder机制"><a href="#44-Android-Binder机制" class="headerlink" title="44. Android Binder机制"></a>44. Android Binder机制</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/binder_architecture.jpg" alt="binder architecture"></p><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/binder_architecture_2.jpg" alt="binder architecture 2"></p><ol><li>Server进程启动之后，会进入中断等待状态，等待Client的请求。</li><li>当Client需要和Server通信时，会将请求发送给Binder驱动。</li><li>Binder驱动收到请求之后，会唤醒Server进程。</li><li>接着，Binder驱动还会反馈信息给Client，告诉Client：它发送给Binder驱动的请求，Binder驱动已经收到。</li><li>Client将请求发送成功之后，就进入等待状态。等待Server的回复。</li><li>Binder驱动唤醒Server之后，就将请求转发给Server进程。</li><li>Server进程解析出请求内容，并将回复内容发送给Binder驱动。</li><li>Binder驱动收到回复之后，唤醒Client进程。</li><li>接着，Binder驱动还会反馈信息给Server，告诉Server：它发送给Binder驱动的回复，Binder驱动已经收到。</li><li>Server将回复发送成功之后，再次进入等待状态，等待Client的请求。</li><li>最后，Binder驱动将回复转发给Client。</li></ol><h2 id="45-Binder机制优点"><a href="#45-Binder机制优点" class="headerlink" title="45. Binder机制优点"></a>45. Binder机制优点</h2><ul><li>性能：Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。</li><li>稳定性：Binder是基于C/S架构的，Server端与Client端相对独立，稳定性较好。</li><li>安全性：传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份。Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行。</li></ul><h2 id="46-AsyncTask简介"><a href="#46-AsyncTask简介" class="headerlink" title="46. AsyncTask简介"></a>46. AsyncTask简介</h2><p>包含4个方法：</p><ul><li><code>onPreExecute()</code>：UI线程；</li><li><code>doInBackground(Params...)</code>：非UI线程；</li><li><code>onProgressUpdate(Progress...)</code>：UI线程；</li><li><code>onPostExecute(Result)</code>：UI线程。</li></ul><p>原理：</p><ul><li>线程池；</li><li>单例模式；</li><li><code>mainLooper()</code>；</li><li>串行。</li></ul><h2 id="47-为什么Handler需要声明为static？"><a href="#47-为什么Handler需要声明为static？" class="headerlink" title="47. 为什么Handler需要声明为static？"></a>47. 为什么Handler需要声明为static？</h2><p>所有发送到消息队列的消息Message都会拥有一个对Handler的引用，在java里，非静态内部类和匿名类都会潜在的引用它们所属的外部类。但是，静态内部类却不会。当Activity结束（finish）时，里面的延时消息在得到处理前，会一直保存在主线程的消息队列里持续10分钟。这条消息持有对handler的引用，而handler又持有对其外部类（在这里，即SampleActivity）的潜在引用。这条引用关系会一直保持直到消息得到处理，从而，这阻止了SampleActivity被垃圾回收器回收，同时造成应用程序的泄漏。</p><h2 id="48-广播注册后不解除注册会有什么问题？"><a href="#48-广播注册后不解除注册会有什么问题？" class="headerlink" title="48. 广播注册后不解除注册会有什么问题？"></a>48. 广播注册后不解除注册会有什么问题？</h2><p>内存泄漏。系统会保留Receiver的引用。</p><h2 id="49-自定义View"><a href="#49-自定义View" class="headerlink" title="49. 自定义View"></a>49. 自定义View</h2><h3 id="49-1-实现步骤"><a href="#49-1-实现步骤" class="headerlink" title="49.1. 实现步骤"></a>49.1. 实现步骤</h3><ol><li>继承View类或其子类；</li><li>复写view中的一些函数；</li><li>为自定义View类增加属性（两种方式）；</li><li>绘制控件（导入布局）；</li><li>响应用户事件；</li><li>定义回调函数（根据自己需求来选择）。</li></ol><h2 id="50-需要被重写的方法"><a href="#50-需要被重写的方法" class="headerlink" title="50. 需要被重写的方法"></a>50. 需要被重写的方法</h2><ul><li><code>onDraw()</code>：view中<code>onDraw()</code>是个空函数，也就是说具体的视图都要覆写该函数来实现自己的绘制。对于ViewGroup则不需要实现该函数，因为作为容器是”没有内容”的（但必须实现<code>dispatchDraw()</code>函数，告诉子view绘制自己）。</li><li><code>onLayout()</code>：主要是为viewGroup类型布局子视图用的，在View中这个函数为空函数。</li><li><code>onMeasure()</code>：用于计算视图大小（即长和宽）的方式，并通过<code>setMeasuredDimension(width, height)</code>保存计算结果。</li><li><code>onTouchEvent()</code>：定义触屏事件来响应用户操作。</li></ul><h2 id="51-Parcelable和Serializable的区别"><a href="#51-Parcelable和Serializable的区别" class="headerlink" title="51. Parcelable和Serializable的区别"></a>51. Parcelable和Serializable的区别</h2><p>Serializable仅需实现Serializable接口。缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。</p><p>Parcelable需要实现Parcelable接口，但序列化的过程已经提前确定，所以运行速度快。</p><h2 id="52-Android中的内存泄漏"><a href="#52-Android中的内存泄漏" class="headerlink" title="52. Android中的内存泄漏"></a>52. Android中的内存泄漏</h2><ol><li>查询数据库没有关闭游标。</li><li>构造Adapter时，没有使用缓存的convertView。</li><li>Bitmap对象不再使用时调用<code>recycle()</code>释放内存。</li><li>无用时没有释放对象的引用。</li><li>在Activity中使用非静态的内部类，并开启一个长时间运行的线程，因为内部类持有Activity的引用，会导致Activity本来可以被GC时却长期得不到回收。</li><li>使用Handler处理消息前，Activity通过例如<code>finish()</code>退出，导致内存泄漏。</li><li>动态注册广播在Activity销毁前没有<code>unregisterReceiver()</code>。</li></ol><h2 id="53-MVC和MVP的区别"><a href="#53-MVC和MVP的区别" class="headerlink" title="53. MVC和MVP的区别"></a>53. MVC和MVP的区别</h2><p>我们都知道MVP是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter（MVC中的Controller）来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过Controller。</p><h2 id="54-内存泄露检测有什么好方法？"><a href="#54-内存泄露检测有什么好方法？" class="headerlink" title="54. 内存泄露检测有什么好方法？"></a>54. 内存泄露检测有什么好方法？</h2><ol><li>DDMS Heap发现内存泄露dataObject totalSize的大小，是否稳定在一个范围内，如果操作程序，不断增加，说明内存泄露。</li><li>使用Heap Tool进行内存快照前后对比BlankActivity手动触发GC进行前后对比，对象是否被及时回收。</li></ol><h2 id="55-Android里面为什么要设计出Bundle而不是直接用Map结构"><a href="#55-Android里面为什么要设计出Bundle而不是直接用Map结构" class="headerlink" title="55. Android里面为什么要设计出Bundle而不是直接用Map结构"></a>55. Android里面为什么要设计出Bundle而不是直接用Map结构</h2><p>Map里实现了Serializable接口，而在Bundle实现了Parcelable的接口。</p><h2 id="56-在Android的MVP架构中，使用了什么设计模式"><a href="#56-在Android的MVP架构中，使用了什么设计模式" class="headerlink" title="56. 在Android的MVP架构中，使用了什么设计模式"></a>56. 在Android的MVP架构中，使用了什么设计模式</h2><ul><li>Observer模式：通过EventBus实现订阅者，发布者的功能，实现Model与Presenter的交互。</li><li>Proxy模式：View保持对Presenter的引用，通过Presenter代理，进行交互操作。</li></ul><h2 id="57-Android动画类型"><a href="#57-Android动画类型" class="headerlink" title="57. Android动画类型"></a>57. Android动画类型</h2><ul><li>属性动画（Property Animation）：是Android 3.0之后推出的，其机制不再是针对 View 来设计的，也不限于只能实现移动、缩放、旋转和淡入这几种简单的动画操作，同时也不再只是一种视觉上的动画效果。属性动画实际上是一种在一定时间段内不断修改某个对象的某个属性值的机制。</li><li><p>视图动画（View Animation）：</p><ul><li><p>补间动画（Tween animation）：是操作某一个控件让其展现出旋转、渐变、移动、缩放的一种转换过程。是一种视觉上的变化，不是真正位置上的变化。只能运用在 View 对象上，并且功能相对来说较为局限。例如：旋转动画只能够在x、y轴进行，而不能在z轴放心进行旋转。因此，补间动画通常用于执行一些比较简单的动画。</p><ul><li>渐变动画（AlphaAnimation）；</li><li>缩放动画（ScaleAnimation）；</li><li>位移动画（TranslateAnimation）；</li><li>旋转动画（RotateAnimation）。</li></ul></li><li><p>帧动画（Frame animation）：帧动画是一系列图片按照一定的顺序展示的过程，和放电影的机制相似，它的原理是在一定的时间段内切换多张有细微差异的图片从而达到动画的效果。由于是一帧一帧加载，所以需要较多的图片。从而增大 APK 的大小，不过 Frame 动画可以实现一些比较难的效果，例如：等待的环形进度。</p></li></ul></li></ul><h2 id="58-ANR和FC的区别"><a href="#58-ANR和FC的区别" class="headerlink" title="58. ANR和FC的区别"></a>58. ANR和FC的区别</h2><ul><li>ANR（Application Not Responding）：主线程阻塞。</li><li>FC（Forced Close）：内存耗尽，堆栈溢出，运行时错误等。</li></ul><h2 id="59-Android中的菜单"><a href="#59-Android中的菜单" class="headerlink" title="59. Android中的菜单"></a>59. Android中的菜单</h2><h3 id="59-1-选项菜单（Options-menu）"><a href="#59-1-选项菜单（Options-menu）" class="headerlink" title="59.1. 选项菜单（Options menu）"></a>59.1. 选项菜单（Options menu）</h3><p>在选项菜单中，您应当包括与当前Activity上下文相关的操作和其他选项，如”搜索”、”撰写电子邮件”和”设置”。</p><ul><li>要为Activity指定选项菜单，请重写<code>onCreateOptionsMenu()</code>。</li><li>此外，您还可以使用<code>add()</code>添加菜单项，并使用<code>findItem()</code>检索项目，以便使用MenuItem API修改其属性。</li><li>系统将在启动Activity时调用<code>onCreateOptionsMenu()</code>，以便向应用栏显示项目。</li><li>用户从选项菜单中选择项目时，系统将调用Activity的<code>onOptionsItemSelected()</code>方法。此方法将传递所选的MenuItem。您可以通过调用<code>getItemId()</code>方法来识别项目，该方法将返回菜单项的唯一ID。</li><li>系统调用<code>onCreateOptionsMenu()</code>后，将保留您填充的Menu实例。除非菜单由于某些原因而失效，否则不会再次调用<code>onCreateOptionsMenu()</code>。</li><li>如需根据在Activity生命周期中发生的事件修改选项菜单，则可通过<code>onPrepareOptionsMenu()</code>方法执行此操作。此方法向您传递Menu对象（因为该对象目前存在），以便您能够对其进行修改，如添加、移除或禁用项目。</li><li>当菜单项显示在应用栏中时，选项菜单被视为始终处于打开状态。 发生事件时，如果您要执行菜单更新，则必须调用<code>invalidateOptionsMenu()</code>来请求系统调用<code>onPrepareOptionsMenu()</code>。</li></ul><h3 id="59-2-上下文菜单（Contextual-Menus）"><a href="#59-2-上下文菜单（Contextual-Menus）" class="headerlink" title="59.2. 上下文菜单（Contextual Menus）"></a>59.2. 上下文菜单（Contextual Menus）</h3><h4 id="59-2-1-浮动上下文菜单（floating-context-menu）"><a href="#59-2-1-浮动上下文菜单（floating-context-menu）" class="headerlink" title="59.2.1. 浮动上下文菜单（floating context menu）"></a>59.2.1. 浮动上下文菜单（floating context menu）</h4><p>用户长按（按住）一个声明支持上下文菜单的视图时，菜单显示为菜单项的浮动列表（类似于对话框）。</p><ul><li>通过调用<code>registerForContextMenu()</code>，注册应与上下文菜单关联的View并将其传递给View。</li><li>在Activity或Fragment中实现<code>onCreateContextMenu()</code>方法。</li><li><p>实现<code>onContextItemSelected()</code>。</p><h4 id="上下文操作模式（contextual-action-mode）"><a href="#上下文操作模式（contextual-action-mode）" class="headerlink" title="上下文操作模式（contextual action mode）"></a>上下文操作模式（contextual action mode）</h4><p>上下文操作模式是 ActionMode 的一种系统实现，它将用户交互的重点转到执行上下文操作上。用户通过选择项目启用此模式时，屏幕顶部将出现一个”上下文操作栏”，显示用户可对当前所选项执行的操作。 启用此模式后，用户可以选择多个项目（若您允许）、取消选择项目以及继续在 Activity 内导航（在您允许的最大范围内）。</p></li><li><p>实现ActionMode.Callback接口。在其回调方法中，您既可以为上下文操作栏指定操作，又可以响应操作项目的点击事件，还可以处理操作模式的其他生命周期事件。</p></li><li><p>当需要显示操作栏时（例如，用户长按视图），请调用<code>startActionMode()</code>。</p></li></ul><h3 id="59-3-弹出菜单（Popup-Menu）"><a href="#59-3-弹出菜单（Popup-Menu）" class="headerlink" title="59.3. 弹出菜单（Popup Menu）"></a>59.3. 弹出菜单（Popup Menu）</h3><p>PopupMenu 是锚定到 View 的模态菜单。如果空间足够，它将显示在定位视图下方，否则显示在其上方。</p><ul><li>实例化PopupMenu及其构造函数，该函数将提取当前应用的Context以及菜单应锚定到的View。</li><li>使用MenuInflater将菜单资源扩充到<code>PopupMenu.getMenu()</code>返回的Menu对象中。</li><li>调用<code>PopupMenu.show()</code>。</li></ul><h2 id="60-BaseAdapter中需要重载的方法"><a href="#60-BaseAdapter中需要重载的方法" class="headerlink" title="60. BaseAdapter中需要重载的方法"></a>60. BaseAdapter中需要重载的方法</h2><p>最基本的：</p><ul><li><code>int getCount ()</code>：How many items are in the data set represented by this Adapter.</li><li><code>Object getItem (int position)</code>：Get the data item associated with the specified position in the data set.</li><li><code>long getItemId (int position)</code>：Get the row id associated with the specified position in the list.</li><li><code>View getView (int position, View convertView, ViewGroup parent)</code>：Get a View that displays the data at the specified position in the data set.</li></ul><p>如果有多种View：</p><ul><li><code>int getItemViewType (int position)</code>：Get the type of View that will be created by getView(int, View, ViewGroup) for the specified item.</li><li><code>int getViewTypeCount ()</code>：Returns the number of types of Views that will be created by getView(int, View, ViewGroup).</li></ul><h2 id="61-Android数字签名要点"><a href="#61-Android数字签名要点" class="headerlink" title="61. Android数字签名要点"></a>61. Android数字签名要点</h2><ul><li>所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序。</li><li>Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证。</li><li>如果要正式发布一个Android应用，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使调试证书来发布。</li><li>数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。</li></ul><h2 id="62-使用相同数字签名的原因"><a href="#62-使用相同数字签名的原因" class="headerlink" title="62. 使用相同数字签名的原因"></a>62. 使用相同数字签名的原因</h2><ul><li>应用升级：当系统安装应用的更新时，它会比较新版本和现有版本中的证书。如果证书匹配，则系统允许更新。如果您使用不同的证书签署新版本，则必须为应用分配另一个软件包名称—-在此情况下，用户将新版本作为全新应用安装。</li><li>应用模块化：Android允许通过相同证书签署的多个APK在同一个进程中运行（如果应用请求这样），以便系统将它们视为单个应用。通过此方式，您可以在模块中部署您的应用，且用户可以独立更新每个模块。</li><li>通过权限共享代码/数据：Android提供基于签名的权限执行，以便应用可以将功能展示给使用指定证书签署的另一应用。通过使用同一个证书签署多个APK并使用基于签名的权限检查功能，您的应用可采用安全的方式共享代码和数据。</li></ul><h2 id="63-Theme和Sytle"><a href="#63-Theme和Sytle" class="headerlink" title="63. Theme和Sytle"></a>63. Theme和Sytle</h2><h3 id="63-1-Style"><a href="#63-1-Style" class="headerlink" title="63.1. Style"></a>63.1. Style</h3><p>样式是指为View或窗口指定外观和格式的属性集合。样式可以指定高度、填充、字体颜色、字号、背景色等许多属性。 样式是在与指定布局的XML不同的XML资源中进行定义。</p><ul><li>要创建一组样式，请在您的项目的<code>res/values/</code>目录中保存一个XML文件。</li><li>该XML文件的根节点必须是<code>&lt;resources&gt;</code>。</li><li>对于您想创建的每个样式，向该文件添加一个<code>&lt;style&gt;</code>元素，该元素带有对样式进行唯一标识的<code>name</code>属性（该属性为必需属性）。</li><li>然后为该样式的每个属性添加一个<code>&lt;item&gt;</code>元素，该元素带有声明样式属性以及属性值的<code>name</code>（该属性为必需属性）。</li><li>根据样式属性，<code>&lt;item&gt;</code>的值可以是关键字字符串、十六进制颜色值、对另一资源类型的引用或其他值。</li><li>您可以通过<code>&lt;style&gt;</code>元素中的<code>parent</code>属性指定应作为您的样式所继承属性来源的样式。</li><li>当您对布局中的单个View应用样式时，该样式定义的属性只应用于该View。如果对ViewGroup应用样式，子View元素将不会继承样式属性—-只有被您直接应用样式的元素才会应用其属性。</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CodeFont<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:style/TextAppearance.Medium<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">        &lt;item name=<span class="token string">"android:layout_width"</span>>fill_parent&lt;/item>        &lt;item name=<span class="token string">"android:layout_height"</span>>wrap_content&lt;/item>        &lt;item name=<span class="token string">"android:textColor"</span>><span class="token hexcode">#00FF00</span>&lt;/item>        &lt;item name=<span class="token string">"android:typeface"</span>>monospace&lt;/item>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span></code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span><span class="token style-attr language-css"><span class="token attr-name">    <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value">@style/CodeFont</span><span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/hello<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><h3 id="63-2-Theme"><a href="#63-2-Theme" class="headerlink" title="63.2. Theme"></a>63.2. Theme</h3><p>主题是指对整个Activity或应用而不是对单个View（如上例所示）应用的样式。以主题形式应用样式时，Activity或应用中的每个视图都将应用其支持的每个样式属性。例如，您可以Activity主题形式应用同一CodeFont样式，之后该Activity内的所有文本都将具有绿色固定宽度字体。</p><ul><li>在XML中定义您想用作Activity或应用主题的样式与定义视图样式的方法完全相同。</li><li>Activity或应用内的每个View都将应用其支持的每个属性。例如，如果您对某个Activity应用前面示例中的CodeFont样式，则所有支持这些文本样式属性的View元素也会应用这些属性。任何不支持这些属性的View都会忽略这些属性。如果某个View仅支持部分属性，将只应用这些属性。</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span> <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@style/CustomTheme<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span> <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:style/Theme.Dialog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h2 id="64-Toast的时长设置"><a href="#64-Toast的时长设置" class="headerlink" title="64. Toast的时长设置"></a>64. Toast的时长设置</h2><p>Toast的显示时长仅有两种：<code>LENGTH_SHORT</code>和<code>LENGTH_LONG</code>。</p><p><code>Toast makeText (Context context, CharSequence text, int duration)</code>：duration <code>int</code>: How long to display the message. Either <code>LENGTH_SHORT</code> or <code>LENGTH_LONG</code>。</p><h2 id="65-触发ANR的情况"><a href="#65-触发ANR的情况" class="headerlink" title="65. 触发ANR的情况"></a>65. 触发ANR的情况</h2><ul><li>KeyDispatchTimeout(5 seconds)：按键或触摸事件在特定时间内无响应；</li><li>BroadcastTimeout(10 seconds)：BroadcastReceiver在特定时间内无法处理完成；</li><li>ServiceTimeout(20 seconds)：Service在特定的时间内无法处理完成</li></ul><h2 id="66-ServiceConnection的onServiceConnected-触发条件"><a href="#66-ServiceConnection的onServiceConnected-触发条件" class="headerlink" title="66. ServiceConnection的onServiceConnected()触发条件"></a>66. ServiceConnection的<code>onServiceConnected()</code>触发条件</h2><ul><li><code>bindService()</code>方法执行成功；</li><li><code>onBind()</code>方法返回非空IBinder对象。</li></ul><h2 id="67-Android虚拟设备不支持的功能"><a href="#67-Android虚拟设备不支持的功能" class="headerlink" title="67. Android虚拟设备不支持的功能"></a>67. Android虚拟设备不支持的功能</h2><ul><li>WLAN</li><li>蓝牙</li><li>NFC</li><li>SD 卡插入/弹出</li><li>连接到设备的耳机</li><li>USB</li></ul><h2 id="68-RemoteView的应用"><a href="#68-RemoteView的应用" class="headerlink" title="68. RemoteView的应用"></a>68. RemoteView的应用</h2><ul><li>AppWidget</li><li>Notification</li></ul><h2 id="69-Android对HashMap做了优化后推出的新的容器类是什么？"><a href="#69-Android对HashMap做了优化后推出的新的容器类是什么？" class="headerlink" title="69. Android对HashMap做了优化后推出的新的容器类是什么？"></a>69. Android对HashMap做了优化后推出的新的容器类是什么？</h2><h3 id="69-1-SparseArray"><a href="#69-1-SparseArray" class="headerlink" title="69.1. SparseArray"></a>69.1. SparseArray</h3><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间。</p><h3 id="69-2-ArrayMap"><a href="#69-2-ArrayMap" class="headerlink" title="69.2. ArrayMap"></a>69.2. ArrayMap</h3><p>ArrayMap是一个&lt;key,value&gt;映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作。</p><h2 id="70-Android安全沙盒"><a href="#70-Android安全沙盒" class="headerlink" title="70. Android安全沙盒"></a>70. Android安全沙盒</h2><ul><li>Android操作系统是一种多用户Linux系统，其中的每个应用都是一个不同的用户；</li><li>默认情况下，系统会为每个应用分配一个唯一的Linux用户ID（该ID仅由系统使用，应用并不知晓）。系统为应用中的所有文件设置权限，使得只有分配给该应用的用户ID才能访问这些文件；</li><li>每个进程都具有自己的虚拟机 (VM)，因此应用代码是在与其他应用隔离的环境中运行；</li><li>默认情况下，每个应用都在其自己的Linux进程内运行。Android会在需要执行任何应用组件时启动该进程，然后在不再需要该进程或系统必须为其他应用恢复内存时关闭该进程。</li></ul><h2 id="71-onStartCommand-有哪些返回值"><a href="#71-onStartCommand-有哪些返回值" class="headerlink" title="71. onStartCommand()有哪些返回值"></a>71. <code>onStartCommand()</code>有哪些返回值</h2><p><code>onStartCommand()</code>的返回值用于描述系统应该如何在服务终止的情况下继续运行服务。其值可以为</p><ul><li><code>START_NOT_STICKY</code>：如果系统在<code>onStartCommand()</code>返回后终止服务，则除非有挂起Intent要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</li><li><code>START_STICKY</code>：如果系统在<code>onStartCommand()</code>返回后终止服务，则会重建服务并调用<code>onStartCommand()</code>，但不会重新传递最后一个Intent。相反，除非有挂起Intent要启动服务（在这种情况下，将传递这些Intent），否则系统会通过空Intent调用<code>onStartCommand()</code>。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</li><li><code>START_REDELIVER_INTENT</code>：如果系统在<code>onStartCommand()</code>返回后终止服务，则会重建服务，并通过传递给服务的最后一个Intent调用<code>onStartCommand()</code>。任何挂起Intent均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</li></ul><h2 id="72-如何创建绑定服务"><a href="#72-如何创建绑定服务" class="headerlink" title="72. 如何创建绑定服务"></a>72. 如何创建绑定服务</h2><p>建提供绑定的服务时，您必须提供IBinder，用以提供客户端用来与服务进行交互的编程接口。</p><h3 id="72-1-扩展Binder类"><a href="#72-1-扩展Binder类" class="headerlink" title="72.1. 扩展Binder类"></a>72.1. 扩展Binder类</h3><p>如果服务是供您的自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展Binder类并从<code>onBind()</code>返回它的一个实例来创建接口。客户端收到Binder后，可利用它直接访问Binder实现中乃至Service中可用的公共方法。</p><ol><li>在您的服务中，创建一个可满足下列任一要求的Binder实例：</li></ol><ul><li>包含客户端可调用的公共方法</li><li>返回当前Service实例，其中包含客户端可调用的公共方法</li><li>或返回由服务承载的其他类的实例，其中包含客户端可调用的公共方法</li></ul><ol start="2"><li>从<code>onBind()</code>回调方法返回此Binder实例。</li><li>在客户端中，从<code>onServiceConnected()</code>回调方法接收Binder，并使用提供的方法调用绑定服务。</li></ol><h3 id="72-2-使用Messenger"><a href="#72-2-使用Messenger" class="headerlink" title="72.2. 使用Messenger"></a>72.2. 使用Messenger</h3><ol><li>服务实现一个Handler，由其接收来自客户端的每个调用的回调</li><li>Handler用于创建Messenger对象（对Handler的引用）</li><li>Messenger创建一个IBinder，服务通过<code>onBind()</code>使其返回客户端</li><li>客户端使用IBinder将Messenger（引用服务的Handler）实例化，然后使用后者将Message对象发送给服务</li><li>服务在其Handler中（具体地讲，是在<code>handleMessage()</code>方法中）接收每个 Message。</li></ol><p>这样，客户端并没有调用服务的“方法”。而客户端传递的“消息”（Message对象）是服务在其Handler中接收的。</p><h2 id="73-如何绑定到服务"><a href="#73-如何绑定到服务" class="headerlink" title="73. 如何绑定到服务"></a>73. 如何绑定到服务</h2><p>应用组件（客户端）可通过调用<code>bindService()</code>绑定到服务。Android系统随后调用服务的onBind()方法，该方法返回用于与服务交互的IBinder。</p><p>绑定是异步的。<code>bindService()</code>会立即返回，“不会”使IBinder返回客户端。要接收IBinder，客户端必须创建一个ServiceConnection实例，并将其传递给<code>bindService()</code>。ServiceConnection包括一个回调方法，系统通过调用它来传递IBinder。</p><ol><li><p>实现ServiceConnection。您的实现必须重写两个回调方法：<code>onServiceConnected()</code>：系统会调用该方法以传递服务的onBind()方法返回的IBinder。<code>onServiceDisconnected()</code>：Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统“不会”调用该方法。</p></li><li><p>调用<code>bindService()</code>，传递ServiceConnection实现。</p></li><li><p>当系统调用您的<code>onServiceConnected()</code>回调方法时，您可以使用接口定义的方法开始调用服务。</p></li><li><p>要断开与服务的连接，请调用<code>unbindService()</code>。如果应用在客户端仍绑定到服务时销毁客户端，则销毁会导致客户端取消绑定。更好的做法是在客户端与服务交互完成后立即取消绑定客户端。</p></li></ol><h2 id="74-Android支持的屏幕密度"><a href="#74-Android支持的屏幕密度" class="headerlink" title="74. Android支持的屏幕密度"></a>74. Android支持的屏幕密度</h2><ul><li>ldpi（低）：120dpi</li><li>mdpi（中）：160dpi</li><li>hdpi（高）：240dpi</li><li>xhdpi（超高）：320dpi</li><li>xxhdpi（超超高）：480dpi</li><li>xxxhdpi（超超超高）：640dpi</li></ul><h2 id="75-如何支持多种屏幕"><a href="#75-如何支持多种屏幕" class="headerlink" title="75. 如何支持多种屏幕"></a>75. 如何支持多种屏幕</h2><ul><li>在清单中显式声明您的应用支持哪些屏幕尺寸；</li><li>为不同屏幕尺寸提供不同的布局；</li><li>为不同屏幕密度提供不同的位图可绘制对象。</li></ul><h2 id="76-什么是资源ID"><a href="#76-什么是资源ID" class="headerlink" title="76. 什么是资源ID"></a>76. 什么是资源ID</h2><p>所有资源ID都在您项目的R类中定义，后者由aapt工具自动生成。</p><p>编译应用时，aapt会生成R类，其中包含您的res/目录中所有资源的资源ID。每个资源类型都有对应的R子类（例如，R.drawable对应于所有可绘制对象资源），而该类型的每个资源都有对应的静态整型数（例如，R.drawable.icon）。这个整型数就是可用来检索资源的资源ID。</p><p>资源ID始终由以下部分组成：</p><ul><li>资源类型：每个资源都被分到一个“类型”组中，例如string、drawable和layout。</li><li>资源名称：它是不包括扩展名的文件名；或是XML android:name属性中的值，如果资源是简单值的话（例如字符串）。</li></ul><h2 id="77-如何处理运行时变更"><a href="#77-如何处理运行时变更" class="headerlink" title="77. 如何处理运行时变更"></a>77. 如何处理运行时变更</h2><p>有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。发生这种变化时，Android会重启正在运行的Activity（先后调用<code>onDestroy()</code>和<code>onCreate()</code>）。</p><h3 id="77-1-在配置变更期间保留对象"><a href="#77-1-在配置变更期间保留对象" class="headerlink" title="77.1. 在配置变更期间保留对象"></a>77.1. 在配置变更期间保留对象</h3><p>如果Activity因配置变更而重启，则可通过保留Fragment来减轻重新初始化Activity的负担。此片段可能包含对您要保留的有状态对象的引用。</p><ol><li>扩展Fragment类并声明对有状态对象的引用。</li><li>在创建片段后调用<code>setRetainInstance(boolean)</code>。</li><li>将片段添加到Activity。</li><li>重启Activity后，使用FragmentManager检索片段。</li></ol><h3 id="77-2-自行处理配置变更"><a href="#77-2-自行处理配置变更" class="headerlink" title="77.2. 自行处理配置变更"></a>77.2. 自行处理配置变更</h3><p>要声明由Activity处理配置变更，请在清单文件中编辑相应的<code>&lt;activity&gt;</code>元素，以包含<code>android:configChanges</code>属性以及代表要处理的配置的值。<code>android:configChanges</code>属性的文档中列出了该属性的可能值（最常用的值包括”orientation”和”keyboardHidden”，分别用于避免因屏幕方向和可用键盘改变而导致重启）。</p><h2 id="78-AndroidManifest-xml包括哪些内容？"><a href="#78-AndroidManifest-xml包括哪些内容？" class="headerlink" title="78. AndroidManifest.xml包括哪些内容？"></a>78. AndroidManifest.xml包括哪些内容？</h2><ul><li>为应用的Java软件包命名。软件包名称充当应用的唯一标识符。</li><li>描述应用的各个组件，包括构成应用的Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理的Intent消息。这些声明向Android系统告知有关组件以及可以启动这些组件的条件的信息。</li><li>确定托管应用组件的进程。</li><li>声明应用必须具备哪些权限才能访问API中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限。</li><li>声明应用所需的最低Android API级别。</li><li>列出应用必须链接到的库。</li></ul><h2 id="79-用户界面如何构成？"><a href="#79-用户界面如何构成？" class="headerlink" title="79. 用户界面如何构成？"></a>79. 用户界面如何构成？</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/viewgroup.png" alt="View Group"></p><p>Android应用中的所有用户界面元素都是使用View和ViewGroup对象构建而成。View对象用于在屏幕上绘制可供用户交互的内容。ViewGroup对象用于储存其他View（和ViewGroup）对象，以便定义界面的布局。</p><p>每个应用组件的用户界面都是使用View和ViewGroup对象的层次结构定义的。每个视图组都是一个用于组织子视图的不可见容器，而子视图可以是输入控件或其他可绘制某一UI部分的小部件。 </p><h2 id="80-为什么要回收Bitmap的内存"><a href="#80-为什么要回收Bitmap的内存" class="headerlink" title="80. 为什么要回收Bitmap的内存"></a>80. 为什么要回收Bitmap的内存</h2><p>Bitmap的实例化只能通过BitmapFactory，而Bitmap对象的生成则是通过JNI调用，所以Bitmap包含Java和C两部分内存。Java部分内存可以通过虚拟机自动回收，但C部分则需要手动释放，所以需要显式调用<code>recycle()</code>方法来释放。</p><h2 id="81-如何优化Bitmap"><a href="#81-如何优化Bitmap" class="headerlink" title="81. 如何优化Bitmap"></a>81. 如何优化Bitmap</h2><ul><li>加载合适尺寸的图片；</li><li>及时回收Bitmap；</li><li>捕获OOM异常；</li><li>压缩图片；</li><li>使用合适的颜色模式。</li></ul><h2 id="82-如何在新进程中创建Activity／Service"><a href="#82-如何在新进程中创建Activity／Service" class="headerlink" title="82. 如何在新进程中创建Activity／Service"></a>82. 如何在新进程中创建Activity／Service</h2><p>在AndroidManifest中，组件元素条目（activity、service、receiver或provider）中设置<code>android:process</code>属性，此属性可以指定该组件应在哪个进程运行。</p><p>每新建一个进程，Application的<code>onCreate()</code>都将被调用一次。</p><h2 id="83-onActivityResult-什么时候会失效？"><a href="#83-onActivityResult-什么时候会失效？" class="headerlink" title="83. onActivityResult()什么时候会失效？"></a>83. <code>onActivityResult()</code>什么时候会失效？</h2><p>在<code>startActivity()</code>为SingleTask时会失效。</p><blockquote><p>For example, if the activity you are launching uses the singleTask launch mode, it will not run in your task and thus you will immediately receive a cancel result.</p></blockquote><p>如果你正加载的activity使用了singleTask的加载模式，它不会在你的栈中运行，而且这样你会马上收到一个取消的结果。即在<code>onActivityResult()</code>里马上得到一个RESULT_CANCEL。</p><h2 id="84-Android崩溃捕获"><a href="#84-Android崩溃捕获" class="headerlink" title="84. Android崩溃捕获"></a>84. Android崩溃捕获</h2><h3 id="84-1-Java崩溃捕获"><a href="#84-1-Java崩溃捕获" class="headerlink" title="84.1. Java崩溃捕获"></a>84.1. Java崩溃捕获</h3><p>Java提供有UncaughtExceptionHandler接口，该接口含有一个方法：<code>void uncaughtException(Thread t, Throwable e)</code>。</p><p>Uncaught异常发生时会终止线程，此时，系统便会通知UncaughtExceptionHandler，调用<code>uncaughtException()</code>函数。如果该handler没有被显式设置，则会调用对应线程组的默认handler。</p><p>如果要捕获该异常，必须实现UncaughtExceptionHandler，并通过<code>public static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)</code>进行设置。</p><h3 id="84-2-Native崩溃捕获"><a href="#84-2-Native崩溃捕获" class="headerlink" title="84.2. Native崩溃捕获"></a>84.2. Native崩溃捕获</h3><p>对Native代码的崩溃，可以通过调用<code>int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact))</code>注册信号处理函数来完成。</p><h2 id="85-Android-APP构建流程"><a href="#85-Android-APP构建流程" class="headerlink" title="85. Android APP构建流程"></a>85. Android APP构建流程</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/build_process.png" alt="Build Process"></p><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/build_process_2.png" alt="Build Process"></p><p>典型的Android APP构建流程：</p><ol><li>Java编译器对工程本身的java代码进行编译，这些java代码有三个来源：app的源代码，由资源文件生成的R文件（aapt工具），以及有aidl文件生成的java接口文件（aidl工具）。产出为.class文件。</li><li>class文件和依赖的三方库文件通过dex工具生成Delvik虚拟机可执行的.dex文件，可能有一个或多个，包含了所有的class信息，包括项目自身的class和依赖的class。产出为.dex文件。</li><li>apkbuilder工具将.dex文件和编译后的资源文件生成未经签名对齐的apk文件。这里编译后的资源文件包括两部分，一是由aapt编译产生的编译后的资源文件，二是依赖的三方库里的资源文件。产出为未经签名的.apk文件。</li><li>分别由Jarsigner和zipalign对apk文件进行签名和对齐，生成最终的apk文件。</li></ol><h2 id="86-class文件与-dex文件的区别"><a href="#86-class文件与-dex文件的区别" class="headerlink" title="86. class文件与.dex文件的区别"></a>86. class文件与.dex文件的区别</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/class_vs_dex.png" alt="class vs dex"></p><h2 id="87-65535问题"><a href="#87-65535问题" class="headerlink" title="87. 65535问题"></a>87. 65535问题</h2><h3 id="87-1-原因"><a href="#87-1-原因" class="headerlink" title="87.1. 原因"></a>87.1. 原因</h3><p>单个dex文件中，method个数采用使用原生类型short来索引，即2个字节最多65536个method，field、class的个数也均有此限制。</p><h3 id="87-2-解决方法"><a href="#87-2-解决方法" class="headerlink" title="87.2. 解决方法"></a>87.2. 解决方法</h3><p>build.gradle中配置<code>multiDexEnabled true</code>，将dex分包。</p><h2 id="88-Dalvik与JVM的区别"><a href="#88-Dalvik与JVM的区别" class="headerlink" title="88. Dalvik与JVM的区别"></a>88. Dalvik与JVM的区别</h2><ul><li>JVM可以执行的文件是.class结尾的字节码文件，而Dalvik执行的是dex文件（不符合JVM规范）。</li><li>Dalvik基于寄存器，而JVM基于栈。</li><li>Dalvik负责进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。</li></ul><p>除此之外：</p><ul><li>有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，它会完成虚拟机的初始化、库的加载、预制类库和初始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的速度提供给系统。</li></ul><h2 id="89-ART相对Dalvik的优化"><a href="#89-ART相对Dalvik的优化" class="headerlink" title="89. ART相对Dalvik的优化"></a>89. ART相对Dalvik的优化</h2><ul><li>AOT替换JIT：使用AOT直接在安装时用dex2oat将其完全翻译成native代码。</li><li>GC性能提升：并行GC。</li><li>提升内存效率：专门开辟内存存放large object，因为large object移动成本太大；引入moving collector技术，将不连续的物理内存块对齐，解决内存碎片化问题。</li></ul><p>参考：<a href="https://source.android.com/devices/tech/dalvik/" target="_blank" rel="noopener">ART and Dalvik | Android Open Source Project</a></p><h2 id="90-Android中的ClassLoader"><a href="#90-Android中的ClassLoader" class="headerlink" title="90. Android中的ClassLoader"></a>90. Android中的ClassLoader</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/classloader.png" alt="ClassLoader"></p><ul><li>在Android中，App安装到手机后，apk里面的class.dex中的class均是通过PathClassLoader来加载的。</li><li>DexClassLoader可以用来加载SD卡上加载包含class.dex的.jar和.apk文件。</li><li>DexClassLoader和PathClassLoader的基类BaseDexClassLoader查找class是通过其内部的<code>DexPathList pathList</code>来查找的。</li><li>DexPathList内部有一个<code>Element[] dexElements</code>数组，其<code>findClass()</code>方法的实现就是遍历该数组，查找class，一旦找到需要的类，就直接返回，停止遍历。</li></ul><h2 id="91-ClassLoader方式实现热修复"><a href="#91-ClassLoader方式实现热修复" class="headerlink" title="91. ClassLoader方式实现热修复"></a>91. ClassLoader方式实现热修复</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/classloader_hotpatch.jpg" alt="ClassLoader Hot Patch"></p><p>主要步骤：</p><ol><li>假设MainActivity中有一个方法<code>showMsg()</code>需要修复。</li><li>修复<code>showMsg()</code>方法，制作补丁包patch.jar，该patch.jar文件中就包含已经修复了的dex文件。</li><li>在Application的<code>onCreate()</code>方法中检测是否已经下载好补丁包，如果存在补丁包，就通过DexClassLoader加载patch.jar，然后通过反射拿到DexClassLoader中的 DexPathList对象，进而拿到<code>Element[] dexElements</code>数组，这里标记该Element数组为<code>newDexElements</code>。</li><li>还是通过反射，拿到App默认的ClassLoader即PathClassLoader的DexPathList对象，进而拿到Element数组，这里标记下该数组为<code>baseDexElements</code>。</li><li>将<code>newDexElements</code>和<code>baseDexElements</code>合成一个新的数组<code>allDexElements</code>，且保证<code>newDexElements</code>中的值在<code>allDexElements</code>数组的最前面。</li><li>然后还是通过通过反射，将合成的Element数组设置给PathClassLoader的DexPathList对象。</li><li>在Application完成初始化之后，会开始加载MainActivity，加载过程就是通过DexPathList对象的<code>findClass()</code>方法来完成的，会从头开始遍历其Element数组，会优先查找到之前插入的补丁包中的dexFile，而原apk中的则不会查找到，因此就实现了热修复的目的。</li></ol><p>参考：<a href="http://jaeger.itscoder.com/android/2016/09/20/nuva-source-code-analysis.html" target="_blank" rel="noopener">热修复实现：ClassLoader 方式的实现</a></p><h2 id="92-AsyncTask需要在主线程中实例化吗？"><a href="#92-AsyncTask需要在主线程中实例化吗？" class="headerlink" title="92. AsyncTask需要在主线程中实例化吗？"></a>92. AsyncTask需要在主线程中实例化吗？</h2><h3 id="92-1-API-16之前"><a href="#92-1-API-16之前" class="headerlink" title="92.1. API 16之前"></a>92.1. API 16之前</h3><p>AsyncTask的静态Handler创建和初始化时默认采用的是当前现场的Looper。若子线程无Looper，则会出错；若有Looper则会导致处理消息时无法在主线程执行，出错。所以AsyncTask必须在主线程实例化。</p><h3 id="92-2-API-16及之后，API-22之前"><a href="#92-2-API-16及之后，API-22之前" class="headerlink" title="92.2. API 16及之后，API 22之前"></a>92.2. API 16及之后，API 22之前</h3><p>在ActivityThread的<code>main()</code>中直接调用了<code>AsyncTask.init()</code>，保证Handler在主线程实例化。所以AsyncTask不需要在主线程实例化。</p><h3 id="92-3-API-22及之后"><a href="#92-3-API-22及之后" class="headerlink" title="92.3. API 22及之后"></a>92.3. API 22及之后</h3><p>不再在ActivityThread的<code>main()</code>中调用。AsyncTask通过<code>getMainLooper()</code>获得主线程Looper。所以AsyncTask不需要在主线程实例化。</p><h2 id="93-Android消息处理机制"><a href="#93-Android消息处理机制" class="headerlink" title="93. Android消息处理机制"></a>93. Android消息处理机制</h2><p>Android消息处理机制主要涉及4个类：Looper、Handler、MessageQueue和Message。</p><h3 id="93-1-Looper"><a href="#93-1-Looper" class="headerlink" title="93.1. Looper"></a>93.1. Looper</h3><p>Looper的使用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LooperThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Handler mHandler<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Looper<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// process incoming messages here</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        Looper<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Looper概览：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Looper</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>Looper<span class="token operator">></span> sThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> MessageQueue mQueue<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueue</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Only one Looper may be created per thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Looper <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            Message msg <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// might block</span>            msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">dispatchMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            msg<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>prepare()</code>会检查此线程是否已经存在Looper，随后便会实例化一个Looper（创建一个MessageQueue），并将此Looper设置为此线程的ThreadLocal变量，这样完成Looper和线程的绑定。</p><p><code>loop()</code>即进从MessageQueue取消息并处理的死循环。</p><h3 id="93-2-Handler"><a href="#93-2-Handler" class="headerlink" title="93.2. Handler"></a>93.2. Handler</h3><p>Handler概览：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Looper mLooper<span class="token punctuation">;</span>    <span class="token keyword">final</span> MessageQueue mQueue<span class="token punctuation">;</span>    <span class="token keyword">final</span> Handler<span class="token punctuation">.</span>Callback mCallback<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mLooper <span class="token operator">=</span> Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mLooper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>                    <span class="token string">"Can't create handler inside thread that has not called Looper.prepare()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        mQueue <span class="token operator">=</span> mLooper<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispatchMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>callback <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleCallback</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> what<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Message <span class="token function">getPostMessage</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Message m <span class="token operator">=</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m<span class="token punctuation">.</span>callback <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">return</span> m<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">post</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MessageQueue queue <span class="token operator">=</span> mQueue<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>MessageQueue queue<span class="token punctuation">,</span> Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        msg<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">enqueueMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handleCallback</span><span class="token punctuation">(</span>Message message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        message<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>一般的用法是对<code>mHandler</code>调用<code>obtainMessage()</code>获得Message并设置参数后通过<code>sendMessage()</code>发送出去。在<code>obtainMessage()</code>和<code>sendMessage()</code>都会设置Message的Handler为本Handler（Message的<code>target</code>变量），若需向Message传递Runnable对象，则会在Message的<code>callback</code>变量中记录。</p><p><code>sendMessage()</code>最终会调用MessageQueue的<code>enqueueMessage()</code>方法，将此Message绑定到对应Looper对应的MessageQueue上。而Looper中收到Message后，会调用Message的<code>target</code>变量（即Handler）的<code>dispatchMessage()</code>方法。对于普通Message，<code>dispatchMessage()</code>又会去调用<code>handleMessage()</code>方法，而这个方法会被用户重载，所以会执行<code>mHandler</code>中指定的代码。</p><p>参考：<a href="http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html" target="_blank" rel="noopener">android的消息处理机制（图+源码分析）——Looper,Handler,Message - CodingMyWorld - 博客园</a></p><h2 id="94-startActivity-执行流程"><a href="#94-startActivity-执行流程" class="headerlink" title="94. startActivity()执行流程"></a>94. <code>startActivity()</code>执行流程</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/start_activity_process.jpg" alt="Start Activity Process"></p><ul><li>当Activity的目标进程不存在时，会首先创建进程。</li><li>Activity Manager Service（AMS）向目标进程的主线程发送<code>LAUNCH_ACTIVITY</code>，目标进程通过反射创建目标Activity，然后进入<code>onCreate()</code>生命周期。</li></ul><p>参考：<a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析 - Gityuan博客 | 袁辉辉博客</a></p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安卓开发项目相关问题总结</title>
      <link href="/2018/12/31/an-zhuo-kai-fa-xiang-mu-xiang-guan-wen-ti-zong-jie/"/>
      <url>/2018/12/31/an-zhuo-kai-fa-xiang-mu-xiang-guan-wen-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h1><!-- TOC --><ul><li><a href="#1-基于android和java的流式二维码数据传输系统">1. 基于Android和Java的流式二维码数据传输系统</a><ul><li><a href="#11-简介">1.1. 简介</a></li><li><a href="#12-应用和优点">1.2. 应用和优点</a></li><li><a href="#13-传输效率">1.3. 传输效率</a></li><li><a href="#14-研究贡献">1.4. 研究贡献</a><ul><li><a href="#141-第一阶段">1.4.1. 第一阶段</a></li><li><a href="#142-第二阶段">1.4.2. 第二阶段</a></li></ul></li><li><a href="#15-开发app遇到的问题">1.5. 开发APP遇到的问题</a><ul><li><a href="#151-不能实时解码">1.5.1. 不能实时解码</a></li><li><a href="#152-代码扩展性差">1.5.2. 代码扩展性差</a></li></ul></li><li><a href="#16-用到了哪些机器学习方法">1.6. 用到了哪些机器学习方法</a></li><li><a href="#17-mediacodec应用在哪里">1.7. <code>MediaCodec</code>应用在哪里？</a></li><li><a href="#18-代码结构">1.8. 代码结构</a><ul><li><a href="#181-发送方">1.8.1. 发送方</a></li><li><a href="#182-接收方">1.8.2. 接收方</a></li></ul></li></ul></li><li><a href="#2-基于androidflask和mysql的用户情绪和隐私收集系统">2. 基于Android、Flask和MySQL的用户情绪和隐私收集系统</a><ul><li><a href="#21-简介">2.1. 简介</a></li><li><a href="#22-收集哪些隐私信息">2.2. 收集哪些隐私信息</a></li><li><a href="#23-如何长驻后台">2.3. 如何长驻后台</a></li><li><a href="#24-如何实现用户登录注册">2.4. 如何实现用户登录注册</a></li><li><a href="#25-问卷内容是什么">2.5. 问卷内容是什么？</a></li><li><a href="#26-调查问卷如何分发和收集">2.6. 调查问卷如何分发和收集</a></li><li><a href="#27-app如何定时抓取用户信息">2.7. APP如何定时抓取用户信息</a></li><li><a href="#28-如何上传用户数据">2.8. 如何上传用户数据</a></li><li><a href="#29-app崩溃如何分析恢复">2.9. APP崩溃如何分析恢复</a></li><li><a href="#210-后台提供哪些统计和管理">2.10. 后台提供哪些统计和管理</a></li><li><a href="#211-用到哪些第三方库">2.11. 用到哪些第三方库</a></li><li><a href="#212-后台是如何搭建的">2.12. 后台是如何搭建的</a></li><li><a href="#213-遇到过哪些问题">2.13. 遇到过哪些问题</a></li></ul></li></ul><!-- /TOC --><h2 id="1-基于Android和Java的流式二维码数据传输系统"><a href="#1-基于Android和Java的流式二维码数据传输系统" class="headerlink" title="1. 基于Android和Java的流式二维码数据传输系统"></a>1. 基于Android和Java的流式二维码数据传输系统</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1. 简介"></a>1.1. 简介</h3><p>流式二维码数据传输系统，以动态二维码的形式在手机／电脑之间传送文件。发送端可以是手机、电脑等任意有屏幕的设备，接收端是带有摄像头的手机。发送端将文件数据编码后嵌入到多个二维码中，二维码动态显式于电脑／手机屏幕上。接收端APP通过摄像头连续捕捉发送的二维码，识别并解码还原出数据，完成文件传输过程。</p><h3 id="1-2-应用和优点"><a href="#1-2-应用和优点" class="headerlink" title="1.2. 应用和优点"></a>1.2. 应用和优点</h3><ul><li>目前手机之间需要传送小文件（如照片）需要蓝牙或wifi进行配对连接，然后传输文件，这样有两个弊端：需要设备硬件支持，需要提前配对连接。而这种基于二维码的传输不需要硬件支持（手机几乎全都有摄像头），运行于软件层面上；且不需要提前建立连接，即用即传。</li><li>目前将文件从台式电脑传送到手机需要通过USB有线连接，或手机加入与台式机在同一局域网的wifi网络，这样很不方便。而通过基于二维码的传输只需要将二维码在电脑屏幕上显示，手机打开摄像头拍摄即可完成文件传输。</li><li>一些如企业等有保密需求的环境下，手机不能连接wifi加入同一局域网，通过基于二维码的传输则可方便解决。</li></ul><h3 id="1-3-传输效率"><a href="#1-3-传输效率" class="headerlink" title="1.3. 传输效率"></a>1.3. 传输效率</h3><p>在发送方最高为30fps的环境下，我们设计的黑白二维码可以达到200kbps，彩色（4色）二维码可以达到300kbps，应用机器学习后可以达到380kbps。</p><p>1080P每帧的处理时间在20ms左右。边界检测6ms，小方块采样8ms，识别2ms，纠错2ms。</p><h3 id="1-4-研究贡献"><a href="#1-4-研究贡献" class="headerlink" title="1.4. 研究贡献"></a>1.4. 研究贡献</h3><p>两个阶段</p><h4 id="1-4-1-第一阶段"><a href="#1-4-1-第一阶段" class="headerlink" title="1.4.1. 第一阶段"></a>1.4.1. 第一阶段</h4><ul><li>新的二维码布局：不同于一个小方块一种颜色，ShiftCode可以在小方块内部嵌套了一个更小的方块，以小方块的移动方向来嵌入数据。优点：嵌入数据更多，可扩展，为解决帧重叠问题提供可能。</li><li>解决帧重叠问题：对于30fps的接收方，当发送方帧速率超过15fps时就会出现帧重叠的问题。采用前后两帧相同位置小方块前景色和后景色相反的设计，可以在小方块发生帧重叠时正确区分前后帧小方块的移动方向，从而将重叠帧分离开。</li><li>可靠性解决方案：对于每一帧的数据，使用Reed-Solomon纠错编码，其优点是可以对连续出错有较好的纠错能力。对所有发送的帧数据使用RaptorQ冗余编码，因为这种传输是单向传输，并没有丢帧重传机制，RaptorQ可以将原始的N帧数据计算生成(N + K)帧数据，只要接收到任意的N帧即可还原出原数据。</li></ul><h4 id="1-4-2-第二阶段"><a href="#1-4-2-第二阶段" class="headerlink" title="1.4.2. 第二阶段"></a>1.4.2. 第二阶段</h4><ul><li>基于机器学习的通用动态二维码识别方案：对于任何现有的基于规则的动态二维码方案，都可以将其识别步骤替换为机器学习方案，识别效率和准确度上都有很大提升。</li><li>统一的识别框架：只需要将小方块采样点颜色和其对应的真实数据交给机器学习训练，得到机器学习模型，后续真正传输时只需要采样小方块，交给模型即可得到真实数据。</li><li>解决帧重叠问题：以黑白为例，重叠帧中小方块可能有4个状态：【黑+黑】、【黑+白】、【白+黑】和【白+白】，通过人为制造【黑+黑】、【黑+白】、【白+黑】和【白+白】这4个状态，接下就只需要确定小方块属于其中哪个状态。这实际是一个分类问题，只需要提前训练好状态的分类，即可判断出小方块的重叠情况。更细节的需要涉及到rolling shutter现象。</li></ul><h3 id="1-5-开发APP遇到的问题"><a href="#1-5-开发APP遇到的问题" class="headerlink" title="1.5. 开发APP遇到的问题"></a>1.5. 开发APP遇到的问题</h3><h4 id="1-5-1-不能实时解码"><a href="#1-5-1-不能实时解码" class="headerlink" title="1.5.1. 不能实时解码"></a>1.5.1. 不能实时解码</h4><p>问题：接收端为30fps，即一秒钟要处理30张图片，每一张图片总的（边界检测、采样、识别、纠错）处理时间要在33ms内。前期没有专门优化导致每帧处理时间需要1秒以上。</p><p>解决方法：</p><ul><li>使用Android Device Monitor的TraceView工具分析每一帧的处理耗时分布，找到耗时最长的函数进行优化，如此循环。</li><li>因Android提供的帧数据是NV21格式，最初是将图片由NV21转换为RGB，非常耗时。最初尝试将转换函数的浮点运算转换为整数运算，效果不好；之后尝试使用OpenGL ES的shader，即GPU来进行转换运算，有一定效果但耗时仍长；再尝试使用JNI即C++来运算，仍未达到预期。再后来转变思路，因为不会用到图片中所有像素点，所以可以在需要时再当场对单个像素点转换，这样暂时解决了问题。但后来发现因为采样点还是比较多，总体来看转换函数耗时还是很大，最后项目整体由RGB转到YUV，不再需要颜色转换，问题顺利解决。</li><li>二维码边界检测是使用一个小矩形逐渐放大直到框住二维码，这个过程需要逐像素行检查和扩展，很耗时。考虑到传输过程中摄像头不会大幅度移动，即二维码相对图片中的位置较为稳定，那么框住的矩形也会较为稳定，这样在确定一个矩形后，对于下一帧，只需要将矩形缩小1/3或1/5即可，节约了很多计算。</li><li>边界检测的结果是定位到二维码的四个顶点，最初是根据这四个顶点通过反透视变换生成一个标准的二维码，需要将原二维码中每个像素计算映射到标准二维码中，很耗时。后来考虑到反透视变换实际上只是计算出一个变换矩阵，而对于拍到二维码，只需要获得采样点的像素值即可，不需要将整个二维码中全部像素点都映射；所以只在需要某个采样点像素值时，将其标准化坐标通过透视变换矩阵转换为真实坐标，再获得像素值即可。</li><li>其他主要是Java语法层面优化，比如变量复用，减少<code>new</code>之类的。</li></ul><h4 id="1-5-2-代码扩展性差"><a href="#1-5-2-代码扩展性差" class="headerlink" title="1.5.2. 代码扩展性差"></a>1.5.2. 代码扩展性差</h4><p>问题：如有新的处理方法或新的二维码加入，需要修改代码时就有种牵一发而动全身的感觉，代码扩展性差。</p><p>解决方法：</p><ul><li>恶补面向对象编程思想，设计模式。</li><li>充分利用继承和抽象复用代码，如不同形状二维码，不同颜色二维码。</li><li>使用工厂方法管理不同二维码的实例化，复用同一套处理框架。</li><li>使用策略模式根据不同需求调整使用不同的二维码定位算法。</li><li>将各种不同二维码的构造生成方法抽象为统一的平台，将二维码分割成border、padding、数据区等块，对于每一块独立指定二维码形状和数据等即可生成二维码。这样避免了为每种二维码写一个大同小异的生成方法，也避免了需要计算各种偏移量等。</li></ul><h3 id="1-6-用到了哪些机器学习方法"><a href="#1-6-用到了哪些机器学习方法" class="headerlink" title="1.6. 用到了哪些机器学习方法"></a>1.6. 用到了哪些机器学习方法</h3><ul><li>实际是一个分类问题，features是小方块采样点颜色和对应参考颜色，class是小方块的真实数据。</li><li>最基本的是使用决策树（Decision Tree），分类效果较好。</li><li>为解决决策树学习时间长的问题，使用随机森林（Random Forest），学习速度有明显提高。</li><li>为解决每次传输需要当场学习出一个模型的问题，使用混合专家模型（Mixture of Experts），对不同场景进行几次传输得到多个模型，使用混合专家模型时只需要在最开始放上少量的学习帧，即可得到各模型的权重，形成一个新的模型。</li></ul><h3 id="1-7-MediaCodec应用在哪里？"><a href="#1-7-MediaCodec应用在哪里？" class="headerlink" title="1.7. MediaCodec应用在哪里？"></a>1.7. <code>MediaCodec</code>应用在哪里？</h3><ul><li><code>MediaCodec</code>用来快速将视频文件解码为图片帧。</li><li>项目支持的输入包括摄像头预览、图片和视频。</li><li>视频的解码最初使用<code>MediaMetadataRetriever</code>，这样有两个主要缺点：软件解码，耗时长；只能使用<code>getFrameAtTime()</code>获取帧，不精确。</li><li><code>MediaCodec</code>是Android提供的硬件解码API，可以快速将视频文件解码为图片帧。</li><li>但<code>MediaCodec</code>存在一个问题：其仅支持处理器芯片支持的帧格式（YUV420中的众多格式），且没有通用支持的格式，即没有设备通用性。</li><li>利用Android API 21的新特性：<code>COLOR_FormatYUV420Flexible</code>的支持，和新的<code>Image</code>类。</li><li>在解码时指定解码格式为<code>COLOR_FormatYUV420Flexible</code>（这个所有设备都支持），解码生成的帧指定为Image类，其可以单独获取YUV各个分量的数据。拼接这些数据即可得到指定YUV420格式的图片帧。实现了设备通用性。</li><li>对1080P的视频，每个图片帧可以在30ms内得到。</li></ul><h3 id="1-8-代码结构"><a href="#1-8-代码结构" class="headerlink" title="1.8. 代码结构"></a>1.8. 代码结构</h3><h4 id="1-8-1-发送方"><a href="#1-8-1-发送方" class="headerlink" title="1.8.1. 发送方"></a>1.8.1. 发送方</h4><ul><li>二维码由Districts、District、Zone组成，其将二维码划分为不同区域（Zone）。每个区域指定其Block的类型，以及二进制数据。由底层处理数据向二维码图片的转换，包括位置、偏移、大小等。</li><li>不同的二维码可能有类似的边框样式或数据内容，通过继承关系组织不同的二维码，如BlackWhiteCode是最基础的二维码，其上可以衍生出ColorCode、ShiftCode等。</li></ul><h4 id="1-8-2-接收方"><a href="#1-8-2-接收方" class="headerlink" title="1.8.2. 接收方"></a>1.8.2. 接收方</h4><ul><li>使用两个线程一个队列，一个线程用来从摄像头／视频文件获取图片帧，并放入队列；另一个线程从队列中取出图片帧，处理图片帧，直到再无图片帧或数据传输完成。</li><li>将图片帧数据封装为RawImage，提供像素值获取、二维码定位等功能。</li><li>RawImage由MediatBarcode封装，MediatBarcode同时提供反透视变换功能，将二维码分割为Districts、District、Zone区域，提供获取区域像素值数据等功能。</li><li>MediateBarcode供不同的二维码使用，这些二维码同样有继承关系，最基本的BlackWhiteCode提供有通用的Zone处理方法，如获取帧编号等。</li><li>StreamDecode提供处理队列中二维码的骨架，其管理二维码间的关联关系，如二维码定位矩阵的保存、帧间冗余算法的纪录。</li></ul><h2 id="2-基于Android、Flask和MySQL的用户情绪和隐私收集系统"><a href="#2-基于Android、Flask和MySQL的用户情绪和隐私收集系统" class="headerlink" title="2. 基于Android、Flask和MySQL的用户情绪和隐私收集系统"></a>2. 基于Android、Flask和MySQL的用户情绪和隐私收集系统</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1. 简介"></a>2.1. 简介</h3><p>APP主要包括两部分，一部分是填写调查问卷，另一部分是在后台持续收集用户隐私信息。调查问卷由用户向服务器请求得到，填写完成后提交给服务器；收集隐私是APP长驻后台，定时抓取用户数据并保存到本地数据库，定时将数据库发送给服务器。</p><h3 id="2-2-收集哪些隐私信息"><a href="#2-2-收集哪些隐私信息" class="headerlink" title="2.2. 收集哪些隐私信息"></a>2.2. 收集哪些隐私信息</h3><p>收集的隐私信息包括录音（持续5秒）、通话记录、短信、联系人信息、地理位置（高德地图API）、手机信息、传感器信息（磁力计、陀螺仪等）、周围wifi、屏幕亮灭、前台运行APP、后台运行APP等。</p><h3 id="2-3-如何长驻后台"><a href="#2-3-如何长驻后台" class="headerlink" title="2.3. 如何长驻后台"></a>2.3. 如何长驻后台</h3><ul><li>服务启动时即拿到PARTIAL_WAKE_LOCK，且不放弃。PARTIAL_WAKE_LOCK在屏幕熄灭的情况下仍保持CPU运行。</li><li>使用第三方云巴推送平台，定时向所有用户推送消息，用来唤醒APP。</li><li>用户配合关闭手机厂商的省电设置等。</li></ul><h3 id="2-4-如何实现用户登录注册"><a href="#2-4-如何实现用户登录注册" class="headerlink" title="2.4. 如何实现用户登录注册"></a>2.4. 如何实现用户登录注册</h3><p>因为是科研项目，并没有实现完整的登录注册功能。只需要填写学号、手机号，服务器后台查询不冲突即注册成功；只需要填写学号，服务器能够查询到相关信息即可登录。</p><h3 id="2-5-问卷内容是什么？"><a href="#2-5-问卷内容是什么？" class="headerlink" title="2.5. 问卷内容是什么？"></a>2.5. 问卷内容是什么？</h3><p>问卷内容我不关系。主要是询问用户是否开心、沮丧等，及其程度。</p><h3 id="2-6-调查问卷如何分发和收集"><a href="#2-6-调查问卷如何分发和收集" class="headerlink" title="2.6. 调查问卷如何分发和收集"></a>2.6. 调查问卷如何分发和收集</h3><ul><li>用户收到APP推送或主动打开APP，点击“填写调查问卷”即向服务器发送请求，服务器判断距离用户上次提交问卷时间间隔有没有达到6小时，若未达到则返回错误提示；若达到则进入分发问卷流程。</li><li>分发问卷时，服务器从数据库中读取题目，并拼装为json格式，同时针对每次分发生成一个唯一的id，用来记录问卷的提交。</li><li>用户填写完问卷点击提交时，同步提交问卷的唯一id；服务器首先验证唯一id是否有效，然后读取客户端发送的json格式回答，解析后保存到数据库中。</li></ul><h3 id="2-7-APP如何定时抓取用户信息"><a href="#2-7-APP如何定时抓取用户信息" class="headerlink" title="2.7. APP如何定时抓取用户信息"></a>2.7. APP如何定时抓取用户信息</h3><p>APP启动同步创建一个Service，Service启动时即实例化一个<code>SingleThreadScheduledExecutor</code>，并设定定时执行周期为一分钟。</p><p>本地数据库中新建一个表，每行纪录需要运行的任务（抓取哪些信息、心跳、上传数据库、清理数据库、切换新数据库）、执行间隔时间、下次运行时间。每当定时周期达到时，就查询数据库，一旦某个任务的下次运行时间小于当前时间，则执行任务，并根据执行间隔时间确定下次运行时间。</p><h3 id="2-8-如何上传用户数据"><a href="#2-8-如何上传用户数据" class="headerlink" title="2.8. 如何上传用户数据"></a>2.8. 如何上传用户数据</h3><p>当执行上传用户数据任务时，则从数据库中读取还未上传的数据库的名字，并逐个通过HTTP POST请求发送本地压缩后的数据库，并在本地数据库中标记此数据库已上传。</p><h3 id="2-9-APP崩溃如何分析恢复"><a href="#2-9-APP崩溃如何分析恢复" class="headerlink" title="2.9. APP崩溃如何分析恢复"></a>2.9. APP崩溃如何分析恢复</h3><p>使用第三方库ACRA进行崩溃信息的收集和上报。</p><p>当APP崩溃后，下次运行时对于不完整或异常的任务在撤销后重新执行并写数据库，保证数据库数据的一致性。</p><h3 id="2-10-后台提供哪些统计和管理"><a href="#2-10-后台提供哪些统计和管理" class="headerlink" title="2.10. 后台提供哪些统计和管理"></a>2.10. 后台提供哪些统计和管理</h3><ul><li>后台展示每个用户的心跳历史、问卷填写历史、上传用户数据时间等。</li><li>可以从后台向特定用户发送推送通知，可以针对不同用户指定不同的APP版本。</li></ul><h3 id="2-11-用到哪些第三方库"><a href="#2-11-用到哪些第三方库" class="headerlink" title="2.11. 用到哪些第三方库"></a>2.11. 用到哪些第三方库</h3><p>Android上的HTTP通信部分使用了okhttp。</p><h3 id="2-12-后台是如何搭建的"><a href="#2-12-后台是如何搭建的" class="headerlink" title="2.12. 后台是如何搭建的"></a>2.12. 后台是如何搭建的</h3><p>后台是基于Python和flask的，flask提供了一套http的处理框架，只需要注册对应的url即可。对于数据的持久存储等则是利用到了MySQL。</p><h3 id="2-13-遇到过哪些问题"><a href="#2-13-遇到过哪些问题" class="headerlink" title="2.13. 遇到过哪些问题"></a>2.13. 遇到过哪些问题</h3><ul><li>APP经常退出前台即被杀死。最初考虑一般的保活方法，如使用AlarmManager，发现用处不大。后来才发现是国内厂商动了手脚，非白名单的APP一律不允许后台运行。所以后来除在技术上尽可能保证APP不被杀死外，还建议用户在手机的设置中将APP加入到白名单。</li><li>经常在抓取用户数据时crash。最初以为是本身代码有问题，一番排查后才发现国内厂商在权限管理上动了手脚。按照官方文档，如果执行某些代码时用户未授权则会返回null值或抛出异常，但国内厂商直接在framework层进行了修改，不知道在哪会去检查权限，一旦未授权则直接抛出异常，导致APP crash。最后不得已对一些敏感信息收集时使用大段的try catch，避免未知的crash。</li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot基础</title>
      <link href="/2018/11/25/springboot-ji-chu/"/>
      <url>/2018/11/25/springboot-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h2><ol><li>能够理解Spring的优缺点</li><li>能够理解SpringBoot的特点</li><li>能够理解SpringBoot的核心功能</li><li>能够搭建SpringBoot的环境</li><li>能够完成application.properties配置文件的配置</li><li>能够完成application.yml配置文件的配置</li><li>能够使用SpringBoot集成Mybatis</li><li>能够使用SpringBoot集成Junit</li><li>能够使用SpringBoot集成SpringData JPA</li></ol><h1 id="一、SpringBoot简介"><a href="#一、SpringBoot简介" class="headerlink" title="一、SpringBoot简介"></a>一、SpringBoot简介</h1><h2 id="1-1-原有Spring优缺点分析"><a href="#1-1-原有Spring优缺点分析" class="headerlink" title="1.1  原有Spring优缺点分析"></a>1.1  原有Spring优缺点分析</h2><h3 id="1-1-1-Spring的优点分析"><a href="#1-1-1-Spring的优点分析" class="headerlink" title="1.1.1 Spring的优点分析"></a>1.1.1 Spring的优点分析</h3><p>Spring是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的Enterprise JavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。</p><h3 id="1-1-2-Spring的缺点分析"><a href="#1-1-2-Spring的缺点分析" class="headerlink" title="1.1.2 Spring的缺点分析"></a>1.1.2 Spring的缺点分析</h3><p>虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。</p><p>所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。</p><p>除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。</p><h2 id="1-2-SpringBoot的概述"><a href="#1-2-SpringBoot的概述" class="headerlink" title="1.2 SpringBoot的概述"></a>1.2 SpringBoot的概述</h2><h3 id="1-2-1-SpringBoot解决上述Spring的缺点"><a href="#1-2-1-SpringBoot解决上述Spring的缺点" class="headerlink" title="1.2.1 SpringBoot解决上述Spring的缺点"></a>1.2.1 SpringBoot解决上述Spring的缺点</h3><p>SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。</p><h3 id="1-2-2-SpringBoot的特点"><a href="#1-2-2-SpringBoot的特点" class="headerlink" title="1.2.2 SpringBoot的特点"></a>1.2.2 SpringBoot的特点</h3><ul><li>为基于Spring的开发提供更快的入门体验</li><li>开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求</li><li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等</li><li>SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</li></ul><h3 id="1-2-3-SpringBoot的核心功能"><a href="#1-2-3-SpringBoot的核心功能" class="headerlink" title="1.2.3 SpringBoot的核心功能"></a>1.2.3 SpringBoot的核心功能</h3><ul><li><p>起步依赖</p><p>起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。</p><p>简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</p></li><li><p>自动配置</p><p>Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</p></li></ul><p>​    注意：起步依赖和自动配置的原理剖析会在第三章《SpringBoot原理分析》进行详细讲解</p><h1 id="二、SpringBoot快速入门"><a href="#二、SpringBoot快速入门" class="headerlink" title="二、SpringBoot快速入门"></a>二、SpringBoot快速入门</h1><h2 id="2-1-代码实现"><a href="#2-1-代码实现" class="headerlink" title="2.1 代码实现"></a>2.1 代码实现</h2><h3 id="2-1-1-创建Maven工程"><a href="#2-1-1-创建Maven工程" class="headerlink" title="2.1.1 创建Maven工程"></a>2.1.1 创建Maven工程</h3><p>使用idea工具创建一个maven工程，该工程为普通的java工程即可</p><p><img src="/2018/11/25/springboot-ji-chu/img/1.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/2.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/3.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/4.png" alt=""></p><h3 id="2-1-2-添加SpringBoot的起步依赖"><a href="#2-1-2-添加SpringBoot的起步依赖" class="headerlink" title="2.1.2 添加SpringBoot的起步依赖"></a>2.1.2 添加SpringBoot的起步依赖</h3><p>SpringBoot要求，项目要继承SpringBoot的起步依赖spring-boot-starter-parent</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span></code></pre><p>SpringBoot要集成SpringMVC进行Controller的开发，所以项目要导入web的启动依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><h3 id="2-1-3-编写SpringBoot引导类"><a href="#2-1-3-编写SpringBoot引导类" class="headerlink" title="2.1.3 编写SpringBoot引导类"></a>2.1.3 编写SpringBoot引导类</h3><p>要通过SpringBoot提供的引导类起步SpringBoot才可以进行访问</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>itheima<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MySpringBootApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>MySpringBootApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-1-4-编写Controller"><a href="#2-1-4-编写Controller" class="headerlink" title="2.1.4 编写Controller"></a>2.1.4 编写Controller</h3><p>在引导类MySpringBootApplication同级包或者子级包中创建QuickStartController</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>controller<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Controller<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ResponseBody<span class="token punctuation">;</span><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickStartController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/quick"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">quick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"springboot 访问成功!"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-1-5-测试"><a href="#2-1-5-测试" class="headerlink" title="2.1.5 测试"></a>2.1.5 测试</h3><p>执行SpringBoot起步类的主方法，控制台打印日志如下：</p><pre><code>.   ____          _            __ _ _ /\\ / ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | &#39;_ | &#39;_| | &#39;_ \/ _` | \ \ \ \ \\/  ___)| |_)| | | | | || (_| |  ) ) ) )  &#39;  |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::        (v2.0.1.RELEASE)2018-05-08 14:29:59.714  INFO 5672 --- [           main] com.itheima.MySpringBootApplication      : Starting MySpringBootApplication on DESKTOP-RRUNFUH with PID 5672 (C:\Users\muzimoo\IdeaProjects\IdeaTest\springboot_quick\target\classes started by muzimoo in C:\Users\muzimoo\IdeaProjects\IdeaTest)... ... ...o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2018-05-08 14:30:03.126  INFO 5672 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup2018-05-08 14:30:03.196  INFO 5672 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#39;&#39;2018-05-08 14:30:03.206  INFO 5672 --- [           main] com.itheima.MySpringBootApplication      : Started MySpringBootApplication in 4.252 seconds (JVM running for 5.583)</code></pre><p>通过日志发现，Tomcat started on port(s): 8080 (http) with context path ‘’</p><p>tomcat已经起步，端口监听8080，web应用的虚拟工程名称为空</p><p>打开浏览器访问url地址为：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a></p><p><img src="/2018/11/25/springboot-ji-chu/img/5.png" alt=""></p><h2 id="2-2-快速入门解析"><a href="#2-2-快速入门解析" class="headerlink" title="2.2 快速入门解析"></a>2.2 快速入门解析</h2><h3 id="2-2-2-SpringBoot代码解析"><a href="#2-2-2-SpringBoot代码解析" class="headerlink" title="2.2.2 SpringBoot代码解析"></a>2.2.2 SpringBoot代码解析</h3><ul><li>@SpringBootApplication：标注SpringBoot的启动类，该注解具备多种功能（后面详细剖析）</li><li>SpringApplication.run(MySpringBootApplication.class) 代表运行SpringBoot的启动类，参数为SpringBoot启动类的字节码对象</li></ul><h3 id="2-2-3-SpringBoot工程热部署"><a href="#2-2-3-SpringBoot工程热部署" class="headerlink" title="2.2.3 SpringBoot工程热部署"></a>2.2.3 SpringBoot工程热部署</h3><p>我们在开发中反复修改类、页面等资源，每次修改后都是需要重新启动才生效，这样每次启动都很麻烦，浪费了大量的时间，我们可以在修改代码后不重启就能生效，在 pom.xml 中添加如下配置就可以实现这样的功能，我们称之为热部署。</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--热部署配置--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>注意：IDEA进行SpringBoot热部署失败原因</p><p>出现这种情况，并不是热部署配置问题，其根本原因是因为Intellij IEDA默认情况下不会自动编译，需要对IDEA进行自动编译的设置，如下：</p><p><img src="/2018/11/25/springboot-ji-chu/img/19.png" alt=""></p><p>然后 Shift+Ctrl+Alt+/，选择Registry</p><p><img src="/2018/11/25/springboot-ji-chu/img/20.png" alt=""></p><h3 id="2-2-4-使用idea快速创建SpringBoot项目"><a href="#2-2-4-使用idea快速创建SpringBoot项目" class="headerlink" title="2.2.4 使用idea快速创建SpringBoot项目"></a>2.2.4 使用idea快速创建SpringBoot项目</h3><p><img src="/2018/11/25/springboot-ji-chu/img/6.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/7.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/8.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/9.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/10.png" alt=""></p><p>通过idea快速创建的SpringBoot项目的pom.xml中已经导入了我们选择的web的起步依赖的坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.itheima<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springboot_quick2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>springboot_quick2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>可以使用快速入门的方式创建Controller进行访问，此处不再赘述</p><h1 id="三、SpringBoot原理分析"><a href="#三、SpringBoot原理分析" class="headerlink" title="三、SpringBoot原理分析"></a>三、SpringBoot原理分析</h1><h2 id="3-1-起步依赖原理分析"><a href="#3-1-起步依赖原理分析" class="headerlink" title="3.1 起步依赖原理分析"></a>3.1 起步依赖原理分析</h2><h3 id="3-1-1-分析spring-boot-starter-parent"><a href="#3-1-1-分析spring-boot-starter-parent" class="headerlink" title="3.1.1 分析spring-boot-starter-parent"></a>3.1.1 分析spring-boot-starter-parent</h3><p>按住Ctrl点击pom.xml中的spring-boot-starter-parent，跳转到了spring-boot-starter-parent的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">></span></span>../../spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relativePath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span></code></pre><p>按住Ctrl点击pom.xml中的spring-boot-starter-dependencies，跳转到了spring-boot-starter-dependencies的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activemq.version</span><span class="token punctuation">></span></span>5.15.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activemq.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>antlr2.version</span><span class="token punctuation">></span></span>2.7.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>antlr2.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appengine-sdk.version</span><span class="token punctuation">></span></span>1.9.63<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appengine-sdk.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artemis.version</span><span class="token punctuation">></span></span>2.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artemis.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aspectj.version</span><span class="token punctuation">></span></span>1.8.13<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aspectj.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assertj.version</span><span class="token punctuation">></span></span>3.9.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assertj.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>atomikos.version</span><span class="token punctuation">></span></span>4.0.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>atomikos.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bitronix.version</span><span class="token punctuation">></span></span>2.1.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bitronix.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build-helper-maven-plugin.version</span><span class="token punctuation">></span></span>3.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build-helper-maven-plugin.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>byte-buddy.version</span><span class="token punctuation">></span></span>1.7.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>byte-buddy.version</span><span class="token punctuation">></span></span>      ... ... ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>          ... ... ...    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pluginManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.jetbrains.kotlin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>kotlin-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${kotlin.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.jooq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jooq-codegen-maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${jooq.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>              ... ... ...        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pluginManagement</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span></code></pre><p>从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分坐标的版本、依赖管理、插件管理已经定义好，所以我们的SpringBoot工程继承spring-boot-starter-parent后已经具备版本锁定等配置了。所以起步依赖的作用就是进行依赖的传递。</p><h3 id="3-1-2-分析spring-boot-starter-web"><a href="#3-1-2-分析spring-boot-starter-web" class="headerlink" title="3.1.2 分析spring-boot-starter-web"></a>3.1.2 分析spring-boot-starter-web</h3><p>按住Ctrl点击pom.xml中的spring-boot-starter-web，跳转到了spring-boot-starter-web的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starters<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>Spring Boot Web Starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-json<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.hibernate.validator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hibernate-validator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>6.0.9.Final<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-webmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>从上面的spring-boot-starter-web的pom.xml中我们可以发现，spring-boot-starter-web就是将web开发要使用的spring-web、spring-webmvc等坐标进行了“打包”，这样我们的工程只要引入spring-boot-starter-web起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的作用。</p><h2 id="3-2-自动配置原理解析"><a href="#3-2-自动配置原理解析" class="headerlink" title="3.2 自动配置原理解析"></a>3.2 自动配置原理解析</h2><p>按住Ctrl点击查看启动类MySpringBootApplication上的注解@SpringBootApplication</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MySpringBootApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>MySpringBootApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注解@SpringBootApplication的源码</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> TypeExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> AutoConfigurationExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Exclude specific auto-configuration classes such that they will never be applied.     * @return the classes to exclude     */</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> EnableAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>其中，</p><p>@SpringBootConfiguration：等同与@Configuration，既标注该类是Spring的一个配置类</p><p>@EnableAutoConfiguration：SpringBoot自动配置功能开启</p><p>按住Ctrl点击查看注解@EnableAutoConfiguration</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@AutoConfigurationPackage</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>AutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>其中，@Import(AutoConfigurationImportSelector.class) 导入了AutoConfigurationImportSelector类</p><p>按住Ctrl点击查看AutoConfigurationImportSelector源码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span>AnnotationMetadata annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> configurations <span class="token operator">=</span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span>                                                                   attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>        configurations <span class="token operator">=</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> exclusions <span class="token operator">=</span> <span class="token function">getExclusions</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">checkExcludedClasses</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        configurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        configurations <span class="token operator">=</span> <span class="token function">filter</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> autoConfigurationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fireAutoConfigurationImportEvents</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> StringUtils<span class="token punctuation">.</span><span class="token function">toStringArray</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>AnnotationMetadata metadata<span class="token punctuation">,</span>            AnnotationAttributes attributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> configurations <span class="token operator">=</span> SpringFactoriesLoader<span class="token punctuation">.</span><span class="token function">loadFactoryNames</span><span class="token punctuation">(</span>                <span class="token function">getSpringFactoriesLoaderFactoryClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> configurations<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中，SpringFactoriesLoader.loadFactoryNames 方法的作用就是从META-INF/spring.factories文件中读取指定类对应的类名称列表 </p><p><img src="/2018/11/25/springboot-ji-chu/img/11.png" alt=""></p><p>spring.factories 文件中有关自动配置的配置信息如下：</p><pre><code>... ... ...org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\... ... ...</code></pre><p>上面配置文件存在大量的以Configuration为结尾的类名称，这些类就是存有自动配置信息的类，而SpringApplication在获取这些类名后再加载</p><p>我们以ServletWebServerFactoryAutoConfiguration为例来分析源码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@AutoConfigureOrder</span><span class="token punctuation">(</span>Ordered<span class="token punctuation">.</span>HIGHEST_PRECEDENCE<span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span>ServletRequest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span><span class="token punctuation">(</span>type <span class="token operator">=</span> Type<span class="token punctuation">.</span>SERVLET<span class="token punctuation">)</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span>ServerProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ServletWebServerFactoryAutoConfiguration<span class="token punctuation">.</span>BeanPostProcessorsRegistrar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        ServletWebServerFactoryConfiguration<span class="token punctuation">.</span>EmbeddedTomcat<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        ServletWebServerFactoryConfiguration<span class="token punctuation">.</span>EmbeddedJetty<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        ServletWebServerFactoryConfiguration<span class="token punctuation">.</span>EmbeddedUndertow<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServletWebServerFactoryAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>其中，</p><p>@EnableConfigurationProperties(ServerProperties.class) 代表加载ServerProperties服务器配置属性类</p><p>进入ServerProperties.class源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"server"</span><span class="token punctuation">,</span> ignoreUnknownFields <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerProperties</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Server HTTP port.     */</span>    <span class="token keyword">private</span> Integer port<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Network address to which the server should bind.     */</span>    <span class="token keyword">private</span> InetAddress address<span class="token punctuation">;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>其中，</p><p>prefix = “server” 表示SpringBoot配置文件中的前缀，SpringBoot会将配置文件中以server开始的属性映射到该类的字段中。映射关系如下：</p><p><img src="/2018/11/25/springboot-ji-chu/img/12.png" alt=""></p><h1 id="四、SpringBoot的配置文件"><a href="#四、SpringBoot的配置文件" class="headerlink" title="四、SpringBoot的配置文件"></a>四、SpringBoot的配置文件</h1><h2 id="4-1-SpringBoot配置文件类型"><a href="#4-1-SpringBoot配置文件类型" class="headerlink" title="4.1 SpringBoot配置文件类型"></a>4.1 SpringBoot配置文件类型</h2><h3 id="4-1-1-SpringBoot配置文件类型和作用"><a href="#4-1-1-SpringBoot配置文件类型和作用" class="headerlink" title="4.1.1 SpringBoot配置文件类型和作用"></a>4.1.1 SpringBoot配置文件类型和作用</h3><p>SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。</p><p>SpringBoot默认会从Resources目录下加载application.properties或application.yml（application.yaml）文件</p><p>其中，application.properties文件是键值对类型的文件，之前一直在使用，所以此处不在对properties文件的格式进行阐述。除了properties文件外，SpringBoot还可以使用yml文件进行配置，下面对yml文件进行讲解。</p><h3 id="4-1-2-application-yml配置文件"><a href="#4-1-2-application-yml配置文件" class="headerlink" title="4.1.2 application.yml配置文件"></a>4.1.2 application.yml配置文件</h3><h4 id="4-1-2-1-yml配置文件简介"><a href="#4-1-2-1-yml配置文件简介" class="headerlink" title="4.1.2.1 yml配置文件简介"></a>4.1.2.1 yml配置文件简介</h4><p>YML文件格式是YAML (YAML Aint Markup Language)编写的文件格式，YAML是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。</p><p>YML文件的扩展名可以使用.yml或者.yaml。</p><h4 id="4-1-2-2-yml配置文件的语法"><a href="#4-1-2-2-yml配置文件的语法" class="headerlink" title="4.1.2.2 yml配置文件的语法"></a>4.1.2.2 yml配置文件的语法</h4><h5 id="4-1-2-2-1-配置普通数据"><a href="#4-1-2-2-1-配置普通数据" class="headerlink" title="4.1.2.2.1 配置普通数据"></a>4.1.2.2.1 配置普通数据</h5><ul><li><p>语法： key: value</p></li><li><p>示例代码：</p></li><li><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> haohao</code></pre></li><li><p>注意：value之前有一个空格</p></li></ul><h5 id="4-1-2-2-2-配置对象数据"><a href="#4-1-2-2-2-配置对象数据" class="headerlink" title="4.1.2.2.2 配置对象数据"></a>4.1.2.2.2 配置对象数据</h5><ul><li><p>语法： </p><p>​    key: </p><p>​        key1: value1</p><p>​        key2: value2</p><p>​    或者：</p><p>​    key: {key1: value1,key2: value2}</p></li><li><p>示例代码：</p></li><li><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">person</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> haohao  <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">31</span>  <span class="token key atrule">addr</span><span class="token punctuation">:</span> beijing<span class="token comment" spellcheck="true">#或者</span><span class="token key atrule">person</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token key atrule">name</span><span class="token punctuation">:</span> haohao<span class="token punctuation">,</span><span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">31</span><span class="token punctuation">,</span><span class="token key atrule">addr</span><span class="token punctuation">:</span> beijing<span class="token punctuation">}</span></code></pre></li><li><p>注意：key1前面的空格个数不限定，在yml语法中，相同缩进代表同一个级别</p></li></ul><h5 id="4-1-2-2-2-配置Map数据"><a href="#4-1-2-2-2-配置Map数据" class="headerlink" title="4.1.2.2.2 配置Map数据"></a>4.1.2.2.2 配置Map数据</h5><p>同上面的对象写法</p><h5 id="4-1-2-2-3-配置数组（List、Set）数据"><a href="#4-1-2-2-3-配置数组（List、Set）数据" class="headerlink" title="4.1.2.2.3 配置数组（List、Set）数据"></a>4.1.2.2.3 配置数组（List、Set）数据</h5><ul><li><p>语法： </p><p>​    key: </p><p>​        - value1</p><p>​        - value2</p><p>或者：</p><p>​    key: [value1,value2]</p></li><li><p>示例代码：</p></li><li><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">city</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> beijing  <span class="token punctuation">-</span> tianjin  <span class="token punctuation">-</span> shanghai  <span class="token punctuation">-</span> chongqing<span class="token comment" spellcheck="true">#或者</span><span class="token key atrule">city</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>beijing<span class="token punctuation">,</span>tianjin<span class="token punctuation">,</span>shanghai<span class="token punctuation">,</span>chongqing<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#集合中的元素是对象形式</span><span class="token key atrule">student</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> zhangsan    <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span>    <span class="token key atrule">score</span><span class="token punctuation">:</span> <span class="token number">100</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> lisi    <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">28</span>    <span class="token key atrule">score</span><span class="token punctuation">:</span> <span class="token number">88</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> wangwu    <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">38</span>    <span class="token key atrule">score</span><span class="token punctuation">:</span> <span class="token number">90</span></code></pre></li><li><p>注意：value1与之间的 - 之间存在一个空格</p></li></ul><h3 id="4-1-3-SpringBoot配置信息的查询"><a href="#4-1-3-SpringBoot配置信息的查询" class="headerlink" title="4.1.3 SpringBoot配置信息的查询"></a>4.1.3 SpringBoot配置信息的查询</h3><p>上面提及过，SpringBoot的配置文件，主要的目的就是对配置信息进行修改的，但在配置时的key从哪里去查询呢？我们可以查阅SpringBoot的官方文档</p><p>文档URL：<a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties</a></p><p>常用的配置摘抄如下：</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># QUARTZ SCHEDULER (QuartzProperties)</span><span class="token attr-name">spring.quartz.jdbc.initialize-schema</span><span class="token punctuation">=</span><span class="token attr-value">embedded # Database schema initialization mode.</span><span class="token attr-name">spring.quartz.jdbc.schema</span><span class="token punctuation">=</span><span class="token attr-value">classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span><span class="token attr-name">spring.quartz.job-store-type</span><span class="token punctuation">=</span><span class="token attr-value">memory # Quartz job store type.</span><span class="token attr-name">spring.quartz.properties.*</span><span class="token punctuation">=</span> <span class="token attr-value"># Additional Quartz Scheduler properties.</span><span class="token comment" spellcheck="true"># ----------------------------------------</span><span class="token comment" spellcheck="true"># WEB PROPERTIES</span><span class="token comment" spellcheck="true"># ----------------------------------------</span><span class="token comment" spellcheck="true"># EMBEDDED SERVER CONFIGURATION (ServerProperties)</span><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8080 # Server HTTP port.</span><span class="token attr-name">server.servlet.context-path</span><span class="token punctuation">=</span> <span class="token attr-value"># Context path of the application.</span><span class="token attr-name">server.servlet.path</span><span class="token punctuation">=</span><span class="token attr-value">/ # Path of the main dispatcher servlet.</span><span class="token comment" spellcheck="true"># HTTP encoding (HttpEncodingProperties)</span><span class="token attr-name">spring.http.encoding.charset</span><span class="token punctuation">=</span><span class="token attr-value">UTF-8 # Charset of HTTP requests and responses. Added to the "Content-Type" header if not set explicitly.</span><span class="token comment" spellcheck="true"># JACKSON (JacksonProperties)</span><span class="token attr-name">spring.jackson.date-format</span><span class="token punctuation">=</span> <span class="token attr-value"># Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.</span><span class="token comment" spellcheck="true"># SPRING MVC (WebMvcProperties)</span><span class="token attr-name">spring.mvc.servlet.load-on-startup</span><span class="token punctuation">=</span><span class="token attr-value">-1 # Load on startup priority of the dispatcher servlet.</span><span class="token attr-name">spring.mvc.static-path-pattern</span><span class="token punctuation">=</span><span class="token attr-value">/** # Path pattern used for static resources.</span><span class="token attr-name">spring.mvc.view.prefix</span><span class="token punctuation">=</span> <span class="token attr-value"># Spring MVC view prefix.</span><span class="token attr-name">spring.mvc.view.suffix</span><span class="token punctuation">=</span> <span class="token attr-value"># Spring MVC view suffix.</span><span class="token comment" spellcheck="true"># DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)</span><span class="token attr-name">spring.datasource.driver-class-name</span><span class="token punctuation">=</span> <span class="token attr-value"># Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span> <span class="token attr-value"># Login password of the database.</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span> <span class="token attr-value"># JDBC URL of the database.</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span> <span class="token attr-value"># Login username of the database.</span><span class="token comment" spellcheck="true"># JEST (Elasticsearch HTTP client) (JestProperties)</span><span class="token attr-name">spring.elasticsearch.jest.password</span><span class="token punctuation">=</span> <span class="token attr-value"># Login password.</span><span class="token attr-name">spring.elasticsearch.jest.proxy.host</span><span class="token punctuation">=</span> <span class="token attr-value"># Proxy host the HTTP client should use.</span><span class="token attr-name">spring.elasticsearch.jest.proxy.port</span><span class="token punctuation">=</span> <span class="token attr-value"># Proxy port the HTTP client should use.</span><span class="token attr-name">spring.elasticsearch.jest.read-timeout</span><span class="token punctuation">=</span><span class="token attr-value">3s # Read timeout.</span><span class="token attr-name">spring.elasticsearch.jest.username</span><span class="token punctuation">=</span> <span class="token attr-value"># Login username.</span></code></pre><p>我们可以通过配置application.poperties 或者 application.yml 来修改SpringBoot的默认配置</p><p>例如：</p><p>application.properties文件</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8888</span><span class="token attr-name">server.servlet.context-path</span><span class="token punctuation">=</span><span class="token attr-value">demo</span></code></pre><p>application.yml文件</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8888</span>  <span class="token key atrule">servlet</span><span class="token punctuation">:</span>    <span class="token key atrule">context-path</span><span class="token punctuation">:</span> /demo</code></pre><h2 id="4-2-配置文件与配置类的属性映射方式"><a href="#4-2-配置文件与配置类的属性映射方式" class="headerlink" title="4.2 配置文件与配置类的属性映射方式"></a>4.2 配置文件与配置类的属性映射方式</h2><h3 id="4-2-1-使用注解-Value映射"><a href="#4-2-1-使用注解-Value映射" class="headerlink" title="4.2.1 使用注解@Value映射"></a>4.2.1 使用注解@Value映射</h3><p>我们可以通过@Value注解将配置文件中的值映射到一个Spring管理的Bean的字段上</p><p>例如：</p><p>application.properties配置如下：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">person</span><span class="token punctuation">:</span><span class="token attr-name">  name</span><span class="token punctuation">:</span> <span class="token attr-value">zhangsan</span><span class="token attr-name">  age</span><span class="token punctuation">:</span> <span class="token attr-value">18</span></code></pre><p>或者，application.yml配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">person</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zhangsan  <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span></code></pre><p>实体Bean代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickStartController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${person.name}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${person.age}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/quick"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">quick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"springboot 访问成功! name="</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">",age="</span><span class="token operator">+</span>age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>浏览器访问地址：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a> 结果如下：</p><p><img src="/2018/11/25/springboot-ji-chu/img/13.png" alt=""></p><h3 id="4-2-2-使用注解-ConfigurationProperties映射"><a href="#4-2-2-使用注解-ConfigurationProperties映射" class="headerlink" title="4.2.2 使用注解@ConfigurationProperties映射"></a>4.2.2 使用注解@ConfigurationProperties映射</h3><p>通过注解@ConfigurationProperties(prefix=”配置文件中的key的前缀”)可以将配置文件中的配置自动与实体进行映射</p><p>application.properties配置如下：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">person</span><span class="token punctuation">:</span><span class="token attr-name">  name</span><span class="token punctuation">:</span> <span class="token attr-value">zhangsan</span><span class="token attr-name">  age</span><span class="token punctuation">:</span> <span class="token attr-value">18</span></code></pre><p>或者，application.yml配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">person</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zhangsan  <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span></code></pre><p>实体Bean代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickStartController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/quick"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">quick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"springboot 访问成功! name="</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">",age="</span><span class="token operator">+</span>age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span>Integer age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>浏览器访问地址：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a> 结果如下：</p><p><img src="/2018/11/25/springboot-ji-chu/img/13.png" alt=""></p><p>注意：使用@ConfigurationProperties方式可以进行配置文件与实体字段的自动映射，但需要字段必须提供set方法才可以，而使用@Value注解修饰的字段不需要提供set方法</p><h1 id="五、SpringBoot与整合其他技术"><a href="#五、SpringBoot与整合其他技术" class="headerlink" title="五、SpringBoot与整合其他技术"></a>五、SpringBoot与整合其他技术</h1><h2 id="5-1-SpringBoot整合Mybatis"><a href="#5-1-SpringBoot整合Mybatis" class="headerlink" title="5.1 SpringBoot整合Mybatis"></a>5.1 SpringBoot整合Mybatis</h2><h3 id="5-1-1-添加Mybatis的起步依赖"><a href="#5-1-1-添加Mybatis的起步依赖" class="headerlink" title="5.1.1 添加Mybatis的起步依赖"></a>5.1.1 添加Mybatis的起步依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--mybatis起步依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-1-2-添加数据库驱动坐标"><a href="#5-1-2-添加数据库驱动坐标" class="headerlink" title="5.1.2 添加数据库驱动坐标"></a>5.1.2 添加数据库驱动坐标</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- MySQL连接驱动 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-1-3-添加数据库连接信息"><a href="#5-1-3-添加数据库连接信息" class="headerlink" title="5.1.3 添加数据库连接信息"></a>5.1.3 添加数据库连接信息</h3><p>在application.properties中添加数据量的连接信息</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#DB Configuration:</span><span class="token attr-name">spring.datasource.driverClassName</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">root</span></code></pre><h3 id="5-1-4-创建user表"><a href="#5-1-4-创建user表" class="headerlink" title="5.1.4 创建user表"></a>5.1.4 创建user表</h3><p>在test数据库中创建user表</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- ----------------------------</span><span class="token comment" spellcheck="true">-- Table structure for `user`</span><span class="token comment" spellcheck="true">-- ----------------------------</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>username<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>password<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">10</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- ----------------------------</span><span class="token comment" spellcheck="true">-- Records of user</span><span class="token comment" spellcheck="true">-- ----------------------------</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'zhangsan'</span><span class="token punctuation">,</span> <span class="token string">'123'</span><span class="token punctuation">,</span> <span class="token string">'张三'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'lisi'</span><span class="token punctuation">,</span> <span class="token string">'123'</span><span class="token punctuation">,</span> <span class="token string">'李四'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="5-1-5-创建实体Bean"><a href="#5-1-5-创建实体Bean" class="headerlink" title="5.1.5 创建实体Bean"></a>5.1.5 创建实体Bean</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 主键</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用户名</span>    <span class="token keyword">private</span> String username<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 密码</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 姓名</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//此处省略getter和setter方法 .. ..</span><span class="token punctuation">}</span></code></pre><h3 id="5-1-6-编写Mapper"><a href="#5-1-6-编写Mapper" class="headerlink" title="5.1.6 编写Mapper"></a>5.1.6 编写Mapper</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">queryUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>注意：@Mapper标记该类是一个mybatis的mapper接口，可以被spring boot自动扫描到spring上下文中</p><h3 id="5-1-7-配置Mapper映射文件"><a href="#5-1-7-配置Mapper映射文件" class="headerlink" title="5.1.7 配置Mapper映射文件"></a>5.1.7 配置Mapper映射文件</h3><p>在src\main\resources\mapper路径下加入UserMapper.xml配置文件”</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token doctype">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" ></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>queryUserList<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><h3 id="5-1-8-在application-properties中添加mybatis的信息"><a href="#5-1-8-在application-properties中添加mybatis的信息" class="headerlink" title="5.1.8 在application.properties中添加mybatis的信息"></a>5.1.8 在application.properties中添加mybatis的信息</h3><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#spring集成Mybatis环境</span><span class="token comment" spellcheck="true">#pojo别名扫描包</span><span class="token attr-name">mybatis.type-aliases-package</span><span class="token punctuation">=</span><span class="token attr-value">com.itheima.domain</span><span class="token comment" spellcheck="true">#加载Mybatis映射文件</span><span class="token attr-name">mybatis.mapper-locations</span><span class="token punctuation">=</span><span class="token attr-value">classpath:mapper/*Mapper.xml</span></code></pre><h3 id="5-1-9-编写测试Controller"><a href="#5-1-9-编写测试Controller" class="headerlink" title="5.1.9 编写测试Controller"></a>5.1.9 编写测试Controller</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserMapper userMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/queryUser"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">queryUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">queryUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> users<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-1-10-测试"><a href="#5-1-10-测试" class="headerlink" title="5.1.10 测试"></a>5.1.10 测试</h3><p><img src="/2018/11/25/springboot-ji-chu/img/14.png" alt=""></p><h2 id="5-2-SpringBoot整合Junit"><a href="#5-2-SpringBoot整合Junit" class="headerlink" title="5.2 SpringBoot整合Junit"></a>5.2 SpringBoot整合Junit</h2><h3 id="5-2-1-添加Junit的起步依赖"><a href="#5-2-1-添加Junit的起步依赖" class="headerlink" title="5.2.1 添加Junit的起步依赖"></a>5.2.1 添加Junit的起步依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--测试的起步依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-2-2-编写测试类"><a href="#5-2-2-编写测试类" class="headerlink" title="5.2.2 编写测试类"></a>5.2.2 编写测试类</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>MySpringBootApplication<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span>UserMapper<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>RunWith<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>SpringBootTest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span>SpringRunner<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>classes <span class="token operator">=</span> MySpringBootApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserMapper userMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">queryUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中，</p><p>SpringRunner继承自SpringJUnit4ClassRunner，使用哪一个Spring提供的测试测试引擎都可以</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SpringRunner</span> <span class="token keyword">extends</span> <span class="token class-name">SpringJUnit4ClassRunner</span> </code></pre><p>@SpringBootTest的属性指定的是引导类的字节码对象</p><h3 id="5-2-3-控制台打印信息"><a href="#5-2-3-控制台打印信息" class="headerlink" title="5.2.3 控制台打印信息"></a>5.2.3 控制台打印信息</h3><p><img src="/2018/11/25/springboot-ji-chu/img/15.png" alt=""></p><h2 id="5-3-SpringBoot整合Spring-Data-JPA"><a href="#5-3-SpringBoot整合Spring-Data-JPA" class="headerlink" title="5.3 SpringBoot整合Spring Data JPA"></a>5.3 SpringBoot整合Spring Data JPA</h2><h3 id="5-3-1-添加Spring-Data-JPA的起步依赖"><a href="#5-3-1-添加Spring-Data-JPA的起步依赖" class="headerlink" title="5.3.1 添加Spring Data JPA的起步依赖"></a>5.3.1 添加Spring Data JPA的起步依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- springBoot JPA的起步依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-jpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-3-2-添加数据库驱动依赖"><a href="#5-3-2-添加数据库驱动依赖" class="headerlink" title="5.3.2 添加数据库驱动依赖"></a>5.3.2 添加数据库驱动依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- MySQL连接驱动 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-3-3-在application-properties中配置数据库和jpa的相关属性"><a href="#5-3-3-在application-properties中配置数据库和jpa的相关属性" class="headerlink" title="5.3.3 在application.properties中配置数据库和jpa的相关属性"></a>5.3.3 在application.properties中配置数据库和jpa的相关属性</h3><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#DB Configuration:</span><span class="token attr-name">spring.datasource.driverClassName</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token comment" spellcheck="true">#JPA Configuration:</span><span class="token attr-name">spring.jpa.database</span><span class="token punctuation">=</span><span class="token attr-value">MySQL</span><span class="token attr-name">spring.jpa.show-sql</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.jpa.generate-ddl</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.jpa.hibernate.ddl-auto</span><span class="token punctuation">=</span><span class="token attr-value">update</span><span class="token attr-name">spring.jpa.hibernate.naming_strategy</span><span class="token punctuation">=</span><span class="token attr-value">org.hibernate.cfg.ImprovedNamingStrategy</span></code></pre><h3 id="5-3-4-创建实体配置实体"><a href="#5-3-4-创建实体配置实体" class="headerlink" title="5.3.4 创建实体配置实体"></a>5.3.4 创建实体配置实体</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 主键</span>    <span class="token annotation punctuation">@Id</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> GenerationType<span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用户名</span>    <span class="token keyword">private</span> String username<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 密码</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 姓名</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//此处省略setter和getter方法... ...</span><span class="token punctuation">}</span></code></pre><h3 id="5-3-5-编写UserRepository"><a href="#5-3-5-编写UserRepository" class="headerlink" title="5.3.5 编写UserRepository"></a>5.3.5 编写UserRepository</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserRepository</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token operator">&lt;</span>User<span class="token punctuation">,</span>Long<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="5-3-6-编写测试类"><a href="#5-3-6-编写测试类" class="headerlink" title="5.3.6 编写测试类"></a>5.3.6 编写测试类</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>classes<span class="token operator">=</span>MySpringBootApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JpaTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserRepository userRepository<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userRepository<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-3-7-控制台打印信息"><a href="#5-3-7-控制台打印信息" class="headerlink" title="5.3.7 控制台打印信息"></a>5.3.7 控制台打印信息</h3><p><img src="/2018/11/25/springboot-ji-chu/img/16.png" alt=""></p><p>注意：如果是jdk9，执行报错如下：</p><p><img src="/2018/11/25/springboot-ji-chu/img/17.png" alt=""></p><p>原因：jdk缺少相应的jar</p><p>解决方案：手动导入对应的maven坐标，如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--jdk9需要导入如下坐标--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>javax.xml.bind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jaxb-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="5-4-SpringBoot整合Redis"><a href="#5-4-SpringBoot整合Redis" class="headerlink" title="5.4 SpringBoot整合Redis"></a>5.4 SpringBoot整合Redis</h2><h3 id="5-4-1-添加redis的起步依赖"><a href="#5-4-1-添加redis的起步依赖" class="headerlink" title="5.4.1 添加redis的起步依赖"></a>5.4.1 添加redis的起步依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置使用redis启动器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-4-2-配置redis的连接信息"><a href="#5-4-2-配置redis的连接信息" class="headerlink" title="5.4.2 配置redis的连接信息"></a>5.4.2 配置redis的连接信息</h3><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#Redis</span><span class="token attr-name">spring.redis.host</span><span class="token punctuation">=</span><span class="token attr-value">127.0.0.1</span><span class="token attr-name">spring.redis.port</span><span class="token punctuation">=</span><span class="token attr-value">6379</span></code></pre><h3 id="5-4-3-注入RedisTemplate测试redis操作"><a href="#5-4-3-注入RedisTemplate测试redis操作" class="headerlink" title="5.4.3 注入RedisTemplate测试redis操作"></a>5.4.3 注入RedisTemplate测试redis操作</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>classes <span class="token operator">=</span> SpringbootJpaApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserRepository userRepository<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> JsonProcessingException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//从redis缓存中获得指定的数据</span>        String userListData <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"user.findAll"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果redis中没有数据的话</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>null<span class="token operator">==</span>userListData<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//查询数据库获得数据</span>            List<span class="token operator">&lt;</span>User<span class="token operator">></span> all <span class="token operator">=</span> userRepository<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//转换成json格式字符串</span>            ObjectMapper om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            userListData <span class="token operator">=</span> om<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>all<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将数据存储到redis中，下次在查询直接从redis中获得数据，不用在查询数据库</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"user.findAll"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>userListData<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===============从数据库获得数据==============="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===============从redis缓存中获得数据==============="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userListData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Docker环境下的前后端分离部署与运维》课程脚本</title>
      <link href="/2018/08/14/docker-qian-hou-duan-fen-chi/"/>
      <url>/2018/08/14/docker-qian-hou-duan-fen-chi/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker虚拟机常用命令"><a href="#Docker虚拟机常用命令" class="headerlink" title="Docker虚拟机常用命令"></a>Docker虚拟机常用命令</h2><ol><li><p>先更新软件包</p><pre class=" language-shell"><code class="language-shell">yum -y update</code></pre></li><li><p>安装Docker虚拟机</p><pre class=" language-shell"><code class="language-shell">yum install -y docker</code></pre></li><li><p>运行、重启、关闭Docker虚拟机</p><pre class=" language-shell"><code class="language-shell">service docker startservice docker startservice docker stop</code></pre></li><li><p>搜索镜像</p><pre class=" language-shell"><code class="language-shell">docker search 镜像名称</code></pre></li><li><p>下载镜像</p><pre class=" language-shell"><code class="language-shell">docker pull 镜像名称</code></pre></li><li><p>查看镜像</p><pre class=" language-shell"><code class="language-shell">docker images</code></pre></li><li><p>删除镜像</p><pre class=" language-shell"><code class="language-shell">docker rmi 镜像名称</code></pre></li><li><p>运行容器</p><pre class=" language-shell"><code class="language-shell">docker run 启动参数  镜像名称</code></pre></li><li><p>查看容器列表</p><pre class=" language-shell"><code class="language-shell">docker ps -a</code></pre></li><li><p>停止、挂起、恢复容器</p><pre class=" language-shell"><code class="language-shell">docker stop 容器IDdocker pause 容器IDdocker unpase 容器ID</code></pre></li><li><p>查看容器信息</p><pre class=" language-shell"><code class="language-shell">docker inspect 容器ID</code></pre></li><li><p>删除容器</p><pre class=" language-shell"><code class="language-shell">docker rm 容器ID</code></pre></li><li><p>数据卷管理</p><pre class=" language-shell"><code class="language-shell">docker volume create 数据卷名称  #创建数据卷docker volume rm 数据卷名称  #删除数据卷docker volume inspect 数据卷名称  #查看数据卷</code></pre></li><li><p>网络管理</p><pre class=" language-shell"><code class="language-shell">docker network ls 查看网络信息docker network create --subnet=网段 网络名称docker network rm 网络名称</code></pre></li><li><p>避免VM虚拟机挂起恢复之后，Docker虚拟机断网</p><pre class=" language-shell"><code class="language-shell">vi /etc/sysctl.conf</code></pre></li></ol><pre><code>文件中添加`net.ipv4.ip_forward=1`这个配置​```shell#重启网络服务systemctl  restart network​```</code></pre><h2 id="安装PXC集群，负载均衡，双机热备"><a href="#安装PXC集群，负载均衡，双机热备" class="headerlink" title="安装PXC集群，负载均衡，双机热备"></a>安装PXC集群，负载均衡，双机热备</h2><ol><li><p>安装PXC镜像</p><pre class=" language-shell"><code class="language-shell">docker pull percona/percona-xtradb-cluster</code></pre></li><li><p>为PXC镜像改名</p><pre class=" language-shell"><code class="language-shell">docker tag percona/percona-xtradb-cluster pxc</code></pre></li><li><p>创建net1网段</p><pre class=" language-shell"><code class="language-shell">docker network create --subnet=172.18.0.0/16 net1</code></pre></li><li><p>创建5个数据卷</p><pre class=" language-shell"><code class="language-shell">docker volume create --name v1docker volume create --name v2docker volume create --name v3docker volume create --name v4docker volume create --name v5</code></pre></li><li><p>创建备份数据卷（用于热备份数据）</p><pre class=" language-shell"><code class="language-shell">docker volume create --name backup</code></pre></li><li><p>创建5节点的PXC集群</p><p>注意，每个MySQL容器创建之后，因为要执行PXC的初始化和加入集群等工作，耐心等待1分钟左右再用客户端连接MySQL。另外，必须第1个MySQL节点启动成功，用MySQL客户端能连接上之后，再去创建其他MySQL节点。</p><pre class=" language-shell"><code class="language-shell">#创建第1个MySQL节点docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxc#创建第2个MySQL节点docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root -e CLUSTER_JOIN=node1 -v v2:/var/lib/mysql -v backup:/data --privileged --name=node2 --net=net1 --ip 172.18.0.3 pxc#创建第3个MySQL节点docker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root -e CLUSTER_JOIN=node1 -v v3:/var/lib/mysql --privileged --name=node3 --net=net1 --ip 172.18.0.4 pxc#创建第4个MySQL节点docker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root -e CLUSTER_JOIN=node1 -v v4:/var/lib/mysql --privileged --name=node4 --net=net1 --ip 172.18.0.5 pxc#创建第5个MySQL节点docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root -e CLUSTER_JOIN=node1 -v v5:/var/lib/mysql -v backup:/data --privileged --name=node5 --net=net1 --ip 172.18.0.6 pxc</code></pre></li><li><p>安装Haproxy镜像</p><pre class=" language-shell"><code class="language-shell">docker pull haproxy</code></pre></li><li><p>宿主机上编写Haproxy配置文件</p><pre class=" language-shell"><code class="language-shell">vi /home/soft/haproxy.cfg</code></pre><p>配置文件如下：</p><pre class=" language-properties"><code class="language-properties">global<span class="token comment" spellcheck="true">    #工作目录</span><span class="token attr-name">    chroot</span> <span class="token attr-value">/usr/local/etc/haproxy</span><span class="token comment" spellcheck="true">    #日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info</span><span class="token attr-name">    log</span> <span class="token attr-value">127.0.0.1 local5 info</span><span class="token comment" spellcheck="true">    #守护进程运行</span>    daemondefaults<span class="token attr-name">    log</span> <span class="token attr-value">   global</span><span class="token attr-name">    mode</span> <span class="token attr-value">   http</span><span class="token comment" spellcheck="true">    #日志格式</span><span class="token attr-name">    option</span> <span class="token attr-value">   httplog</span><span class="token comment" spellcheck="true">    #日志中不记录负载均衡的心跳检测记录</span><span class="token attr-name">    option</span> <span class="token attr-value">   dontlognull</span><span class="token comment" spellcheck="true">    #连接超时（毫秒）</span><span class="token attr-name">    timeout</span> <span class="token attr-value">connect 5000</span><span class="token comment" spellcheck="true">    #客户端超时（毫秒）</span><span class="token attr-name">    timeout</span> <span class="token attr-value">client  50000</span><span class="token comment" spellcheck="true">    #服务器超时（毫秒）</span><span class="token attr-name">    timeout</span> <span class="token attr-value">server  50000</span><span class="token comment" spellcheck="true">#监控界面    </span><span class="token attr-name">listen</span> <span class="token attr-value"> admin_stats</span><span class="token comment" spellcheck="true">    #监控界面的访问的IP和端口</span><span class="token attr-name">    bind</span> <span class="token attr-value"> 0.0.0.0:8888</span><span class="token comment" spellcheck="true">    #访问协议</span><span class="token attr-name">    mode</span> <span class="token attr-value">       http</span><span class="token comment" spellcheck="true">    #URI相对地址</span><span class="token attr-name">    stats</span> <span class="token attr-value">uri   /dbs</span><span class="token comment" spellcheck="true">    #统计报告格式</span><span class="token attr-name">    stats</span> <span class="token attr-value">realm     Global\ statistics</span><span class="token comment" spellcheck="true">    #登陆帐户信息</span><span class="token attr-name">    stats</span> <span class="token attr-value">auth  admin:abc123456</span><span class="token comment" spellcheck="true">#数据库负载均衡</span><span class="token attr-name">listen</span> <span class="token attr-value"> proxy-mysql</span><span class="token comment" spellcheck="true">    #访问的IP和端口</span><span class="token attr-name">    bind</span> <span class="token attr-value"> 0.0.0.0:3306  </span><span class="token comment" spellcheck="true">    #网络协议</span><span class="token attr-name">    mode</span> <span class="token attr-value"> tcp</span><span class="token comment" spellcheck="true">    #负载均衡算法（轮询算法）</span><span class="token comment" spellcheck="true">    #轮询算法：roundrobin</span><span class="token comment" spellcheck="true">    #权重算法：static-rr</span><span class="token comment" spellcheck="true">    #最少连接算法：leastconn</span><span class="token comment" spellcheck="true">    #请求源IP算法：source </span><span class="token attr-name">    balance</span> <span class="token attr-value"> roundrobin</span><span class="token comment" spellcheck="true">    #日志格式</span><span class="token attr-name">    option</span> <span class="token attr-value"> tcplog</span><span class="token comment" spellcheck="true">    #在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测</span><span class="token attr-name">    option</span> <span class="token attr-value"> mysql-check user haproxy</span><span class="token attr-name">    server</span> <span class="token attr-value"> MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000  </span><span class="token attr-name">    server</span> <span class="token attr-value"> MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000  </span><span class="token attr-name">    server</span> <span class="token attr-value"> MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000 </span><span class="token attr-name">    server</span> <span class="token attr-value"> MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000</span><span class="token attr-name">    server</span> <span class="token attr-value"> MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000</span><span class="token comment" spellcheck="true">    #使用keepalive检测死链</span><span class="token attr-name">    option</span> <span class="token attr-value"> tcpka  </span></code></pre></li><li><p>创建两个Haproxy容器</p><pre class=" language-shell"><code class="language-shell">#创建第1个Haproxy负载均衡服务器docker run -it -d -p 4001:8888 -p 4002:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h1 --privileged --net=net1 --ip 172.18.0.7 haproxy#进入h1容器，启动Haproxydocker exec -it h1 bashhaproxy -f /usr/local/etc/haproxy/haproxy.cfg#创建第2个Haproxy负载均衡服务器docker run -it -d -p 4003:8888 -p 4004:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h2 --privileged --net=net1 --ip 172.18.0.8 haproxy#进入h2容器，启动Haproxydocker exec -it h2 bashhaproxy -f /usr/local/etc/haproxy/haproxy.cfg</code></pre></li><li><p>Haproxy容器内安装Keepalived，设置虚拟IP</p><pre class=" language-shell"><code class="language-shell">#进入h1容器docker exec -it h1 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件（参考下方配置文件）vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start#宿主机执行ping命令ping 172.18.0.201</code></pre><p>配置文件内容如下：</p><pre><code>vrrp_instance  VI_1 {    state  MASTER    interface  eth0    virtual_router_id  51    priority  100    advert_int  1    authentication {        auth_type  PASS        auth_pass  123456    }    virtual_ipaddress {        172.18.0.201    }}</code></pre><pre class=" language-shell"><code class="language-shell">#进入h2容器docker exec -it h2 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start#宿主机执行ping命令ping 172.18.0.201</code></pre><p>配置文件内容如下：</p><pre class=" language-shell"><code class="language-shell">vrrp_instance  VI_1 {    state  MASTER    interface  eth0    virtual_router_id  51    priority  100    advert_int  1    authentication {        auth_type  PASS        auth_pass  123456    }    virtual_ipaddress {        172.18.0.201    }}</code></pre></li><li><p>宿主机安装Keepalived，实现双击热备</p><pre class=" language-shell"><code class="language-shell">#宿主机执行安装Keepalivedyum -y install keepalived#修改Keepalived配置文件vi /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><p>Keepalived配置文件如下：</p><pre class=" language-shell"><code class="language-shell">vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 51    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 1111    }    virtual_ipaddress {           192.168.99.150    }}virtual_server 192.168.99.150 8888 {    delay_loop 3    lb_algo rr     lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 172.18.0.201 8888 {        weight 1    }}virtual_server 192.168.99.150 3306 {    delay_loop 3    lb_algo rr     lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 172.18.0.201 3306 {        weight 1    }}</code></pre></li><li><p>热备份数据</p><pre class=" language-shell"><code class="language-shell">#进入node1容器docker exec -it node1 bash#更新软件包apt-get update#安装热备工具apt-get install percona-xtrabackup-24#全量热备innobackupex --user=root --password=abc123456 /data/backup/full</code></pre></li><li><p>冷还原数据<br>停止其余4个节点，并删除节点</p><pre class=" language-shell"><code class="language-shell">docker stop node2docker stop node3docker stop node4docker stop node5docker rm node2docker rm node3docker rm node4docker rm node5</code></pre><p>node1容器中删除MySQL的数据</p><pre class=" language-shell"><code class="language-shell">#删除数据rm -rf /var/lib/mysql/*#清空事务innobackupex --user=root --password=abc123456 --apply-back /data/backup/full/2018-04-15_05-09-07/#还原数据innobackupex --user=root --password=abc123456 --copy-back  /data/backup/full/2018-04-15_05-09-07/</code></pre><p>重新创建其余4个节点，组件PXC集群</p></li></ol><h2 id="安装Redis，配置RedisCluster集群"><a href="#安装Redis，配置RedisCluster集群" class="headerlink" title="安装Redis，配置RedisCluster集群"></a>安装Redis，配置RedisCluster集群</h2><ol><li><p>安装Redis镜像</p><pre class=" language-shell"><code class="language-shell">docker pull yyyyttttwwww/redis</code></pre></li><li><p>创建net2网段</p><pre class=" language-shell"><code class="language-shell">docker network create --subnet=172.19.0.0/16 net2</code></pre></li><li><p>创建6节点Redis容器</p><pre class=" language-shell"><code class="language-shell">docker run -it -d --name r1 -p 5001:6379 --net=net2 --ip 172.19.0.2 redis bashdocker run -it -d --name r2 -p 5002:6379 --net=net2 --ip 172.19.0.3 redis bashdocker run -it -d --name r3 -p 5003:6379 --net=net2 --ip 172.19.0.4 redis bashdocker run -it -d --name r4 -p 5004:6379 --net=net2 --ip 172.19.0.5 redis bashdocker run -it -d --name r5 -p 5005:6379 --net=net2 --ip 172.19.0.6 redis bash</code></pre></li><li><p>启动6节点Redis服务器</p><pre class=" language-shell"><code class="language-shell">#进入r1节点docker exec -it r1 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r2节点docker exec -it r2 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r3节点docker exec -it r3 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r4节点docker exec -it r4 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r5节点docker exec -it r5 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r6节点docker exec -it r6 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf</code></pre></li><li><p>创建Cluster集群</p><pre class=" language-shell"><code class="language-shell">#在r1节点上执行下面的指令cd /usr/redis/srcmkdir -p ../clustercp redis-trib.rb ../cluster/cd ../cluster#创建Cluster集群./redis-trib.rb create --replicas 1 172.19.0.2:6379 172.19.0.3:6379 172.19.0.4:6379 172.19.0.5:6379 172.19.0.6:6379 172.19.0.7:6379</code></pre></li></ol><h2 id="打包部署后端项目"><a href="#打包部署后端项目" class="headerlink" title="打包部署后端项目"></a>打包部署后端项目</h2><ol><li><p>进入人人开源后端项目，执行打包（修改配置文件，更改端口，打包三次生成三个JAR文件）</p><pre class=" language-shell"><code class="language-shell">mvn clean install -Dmaven.test.skip=true</code></pre></li><li><p>安装Java镜像</p><pre class=" language-shell"><code class="language-shell">docker pull java</code></pre></li><li><p>创建3节点Java容器</p><pre class=" language-shell"><code class="language-shell">#创建数据卷，上传JAR文件docker volume create j1#启动容器docker run -it -d --name j1 -v j1:/home/soft --net=host java#进入j1容器docker exec -it j1 bash#启动Java项目nohup java -jar /home/soft/renren-fast.jar#创建数据卷，上传JAR文件docker volume create j2#启动容器docker run -it -d --name j2 -v j2:/home/soft --net=host java#进入j1容器docker exec -it j2 bash#启动Java项目nohup java -jar /home/soft/renren-fast.jar#创建数据卷，上传JAR文件docker volume create j3#启动容器docker run -it -d --name j3 -v j3:/home/soft --net=host java#进入j1容器docker exec -it j3 bash#启动Java项目nohup java -jar /home/soft/renren-fast.jar</code></pre></li><li><p>安装Nginx镜像</p><pre class=" language-shell"><code class="language-shell">docker pull nginx</code></pre></li><li><p>创建Nginx容器，配置负载均衡</p><p>宿主机上/home/n1/nginx.conf配置文件内容如下：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">user</span> <span class="token attr-value"> nginx;</span><span class="token attr-name">worker_processes</span> <span class="token attr-value"> 1;</span><span class="token attr-name">error_log</span> <span class="token attr-value"> /var/log/nginx/error.log warn;</span><span class="token attr-name">pid</span> <span class="token attr-value">       /var/run/nginx.pid;</span><span class="token attr-name">events</span> <span class="token attr-value">{</span><span class="token attr-name">    worker_connections</span> <span class="token attr-value"> 1024;</span>}<span class="token attr-name">http</span> <span class="token attr-value">{</span><span class="token attr-name">    include</span> <span class="token attr-value">      /etc/nginx/mime.types;</span><span class="token attr-name">    default_type</span> <span class="token attr-value"> application/octet-stream;</span><span class="token attr-name">    log_format</span> <span class="token attr-value"> main  '$remote_addr - $remote_user [$time_local] "$request" '</span><span class="token attr-name">                      '$status</span> <span class="token attr-value">$body_bytes_sent "$http_referer" '</span><span class="token attr-name">                      '"$http_user_agent"</span> <span class="token attr-value">"$http_x_forwarded_for"';</span><span class="token attr-name">    access_log</span> <span class="token attr-value"> /var/log/nginx/access.log  main;</span><span class="token attr-name">    sendfile</span> <span class="token attr-value">       on;</span><span class="token comment" spellcheck="true">    #tcp_nopush     on;</span><span class="token attr-name">    keepalive_timeout</span> <span class="token attr-value"> 65;</span><span class="token comment" spellcheck="true">    #gzip  on;</span><span class="token attr-name">    proxy_redirect</span> <span class="token attr-value">         off;</span><span class="token attr-name">    proxy_set_header</span> <span class="token attr-value">       Host $host;</span><span class="token attr-name">    proxy_set_header</span> <span class="token attr-value">       X-Real-IP $remote_addr;</span><span class="token attr-name">    proxy_set_header</span> <span class="token attr-value">       X-Forwarded-For $proxy_add_x_forwarded_for;</span><span class="token attr-name">    client_max_body_size</span> <span class="token attr-value">   10m;</span><span class="token attr-name">    client_body_buffer_size</span> <span class="token attr-value">  128k;</span><span class="token attr-name">    proxy_connect_timeout</span> <span class="token attr-value">  5s;</span><span class="token attr-name">    proxy_send_timeout</span> <span class="token attr-value">     5s;</span><span class="token attr-name">    proxy_read_timeout</span> <span class="token attr-value">     5s;</span><span class="token attr-name">    proxy_buffer_size</span> <span class="token attr-value">       4k;</span><span class="token attr-name">    proxy_buffers</span> <span class="token attr-value">          4 32k;</span><span class="token attr-name">    proxy_busy_buffers_size</span> <span class="token attr-value"> 64k;</span><span class="token attr-name">    proxy_temp_file_write_size</span> <span class="token attr-value">64k;</span><span class="token attr-name">    upstream</span> <span class="token attr-value">tomcat {</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.99.104:6001;</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.99.104:6002;</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.99.104:6003;</span>    }<span class="token attr-name">    server</span> <span class="token attr-value">{</span><span class="token attr-name">        listen</span> <span class="token attr-value">      6101;</span><span class="token attr-name">        server_name</span> <span class="token attr-value"> 192.168.99.104; </span><span class="token attr-name">        location</span> <span class="token attr-value">/ {  </span><span class="token attr-name">            proxy_pass</span> <span class="token attr-value">  http://tomcat;</span><span class="token attr-name">            index</span> <span class="token attr-value"> index.html index.htm;  </span><span class="token attr-name">        }</span> <span class="token attr-value"> </span>    }}</code></pre><p>创建第1个Nginx节点</p><pre class=" language-shell"><code class="language-shell">docker run -it -d --name n1 -v /home/n1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre><p>宿主机上/home/n2/nginx.conf配置文件内容如下：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">user</span> <span class="token attr-value"> nginx;</span><span class="token attr-name">worker_processes</span> <span class="token attr-value"> 1;</span><span class="token attr-name">error_log</span> <span class="token attr-value"> /var/log/nginx/error.log warn;</span><span class="token attr-name">pid</span> <span class="token attr-value">       /var/run/nginx.pid;</span><span class="token attr-name">events</span> <span class="token attr-value">{</span><span class="token attr-name">    worker_connections</span> <span class="token attr-value"> 1024;</span>}<span class="token attr-name">http</span> <span class="token attr-value">{</span><span class="token attr-name">    include</span> <span class="token attr-value">      /etc/nginx/mime.types;</span><span class="token attr-name">    default_type</span> <span class="token attr-value"> application/octet-stream;</span><span class="token attr-name">    log_format</span> <span class="token attr-value"> main  '$remote_addr - $remote_user [$time_local] "$request" '</span><span class="token attr-name">                      '$status</span> <span class="token attr-value">$body_bytes_sent "$http_referer" '</span><span class="token attr-name">                      '"$http_user_agent"</span> <span class="token attr-value">"$http_x_forwarded_for"';</span><span class="token attr-name">    access_log</span> <span class="token attr-value"> /var/log/nginx/access.log  main;</span><span class="token attr-name">    sendfile</span> <span class="token attr-value">       on;</span><span class="token comment" spellcheck="true">    #tcp_nopush     on;</span><span class="token attr-name">    keepalive_timeout</span> <span class="token attr-value"> 65;</span><span class="token comment" spellcheck="true">    #gzip  on;</span><span class="token attr-name">    proxy_redirect</span> <span class="token attr-value">         off;</span><span class="token attr-name">    proxy_set_header</span> <span class="token attr-value">       Host $host;</span><span class="token attr-name">    proxy_set_header</span> <span class="token attr-value">       X-Real-IP $remote_addr;</span><span class="token attr-name">    proxy_set_header</span> <span class="token attr-value">       X-Forwarded-For $proxy_add_x_forwarded_for;</span><span class="token attr-name">    client_max_body_size</span> <span class="token attr-value">   10m;</span><span class="token attr-name">    client_body_buffer_size</span> <span class="token attr-value">  128k;</span><span class="token attr-name">    proxy_connect_timeout</span> <span class="token attr-value">  5s;</span><span class="token attr-name">    proxy_send_timeout</span> <span class="token attr-value">     5s;</span><span class="token attr-name">    proxy_read_timeout</span> <span class="token attr-value">     5s;</span><span class="token attr-name">    proxy_buffer_size</span> <span class="token attr-value">       4k;</span><span class="token attr-name">    proxy_buffers</span> <span class="token attr-value">          4 32k;</span><span class="token attr-name">    proxy_busy_buffers_size</span> <span class="token attr-value"> 64k;</span><span class="token attr-name">    proxy_temp_file_write_size</span> <span class="token attr-value">64k;</span><span class="token attr-name">    upstream</span> <span class="token attr-value">tomcat {</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.99.104:6001;</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.99.104:6002;</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.99.104:6003;</span>    }<span class="token attr-name">    server</span> <span class="token attr-value">{</span><span class="token attr-name">        listen</span> <span class="token attr-value">      6102;</span><span class="token attr-name">        server_name</span> <span class="token attr-value"> 192.168.99.104; </span><span class="token attr-name">        location</span> <span class="token attr-value">/ {  </span><span class="token attr-name">            proxy_pass</span> <span class="token attr-value">  http://tomcat;</span><span class="token attr-name">            index</span> <span class="token attr-value"> index.html index.htm;  </span><span class="token attr-name">        }</span> <span class="token attr-value"> </span>    }}</code></pre><p>创建第2个Nginx节点</p><pre class=" language-shell"><code class="language-shell">docker run -it -d --name n2 -v /home/n2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre></li><li><p>在Nginx容器安装Keepalived</p><pre class=" language-shell"><code class="language-shell">#进入n1节点docker exec -it n1 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre><code>vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 51    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    virtual_ipaddress {        192.168.99.151    }}virtual_server 192.168.99.151 6201 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6101 {        weight 1    }}</code></pre><pre class=" language-shell"><code class="language-shell">#进入n1节点docker exec -it n2 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre class=" language-shell"><code class="language-shell">vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 51    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    virtual_ipaddress {        192.168.99.151    }}virtual_server 192.168.99.151 6201 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6102 {        weight 1    }}</code></pre></li></ol><h2 id="打包部署后端项目-1"><a href="#打包部署后端项目-1" class="headerlink" title="打包部署后端项目"></a>打包部署后端项目</h2><ol><li><p>在前端项目路径下执行打包指令</p><pre class=" language-shell"><code class="language-shell">npm run build</code></pre></li><li><p>build目录的文件拷贝到宿主机的/home/fn1/renren-vue、/home/fn2/renren-vue、/home/fn3/renren-vue的目录下面</p></li><li><p>创建3节点的Nginx，部署前端项目</p><p>宿主机/home/fn1/nginx.conf的配置文件</p><pre><code>user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    server {        listen 6501;        server_name  192.168.99.104;        location  /  {            root  /home/fn1/renren-vue;            index  index.html;        }    }}</code></pre><pre class=" language-shell"><code class="language-shell">#启动第fn1节点docker run -it -d --name fn1 -v /home/fn1/nginx.conf:/etc/nginx/nginx.conf -v /home/fn1/renren-vue:/home/fn1/renren-vue --privileged --net=host nginx</code></pre><p>宿主机/home/fn2/nginx.conf的配置文件</p><pre class=" language-shell"><code class="language-shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    server {        listen 6502;        server_name  192.168.99.104;        location  /  {            root  /home/fn2/renren-vue;            index  index.html;        }    }}</code></pre><pre class=" language-shell"><code class="language-shell">#启动第fn2节点docker run -it -d --name fn2 -v /home/fn2/nginx.conf:/etc/nginx/nginx.conf -v /home/fn2/renren-vue:/home/fn2/renren-vue --privileged --net=host nginx</code></pre><p>宿主机/home/fn3/nginx.conf的配置文件</p><pre class=" language-shell"><code class="language-shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    server {        listen 6503;        server_name  192.168.99.104;        location  /  {            root  /home/fn3/renren-vue;            index  index.html;        }    }}</code></pre><p>启动fn3节点</p><pre class=" language-shell"><code class="language-shell">#启动第fn3节点docker run -it -d --name fn3 -v /home/fn3/nginx.conf:/etc/nginx/nginx.conf -v /home/fn3/renren-vue:/home/fn3/renren-vue --privileged --net=host nginx</code></pre></li><li><p>配置负载均衡</p><p>宿主机/home/ff1/nginx.conf配置文件</p><pre class=" language-shell"><code class="language-shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    upstream fn {        server 192.168.99.104:6501;        server 192.168.99.104:6502;        server 192.168.99.104:6503;    }    server {        listen       6601;        server_name  192.168.99.104;         location / {              proxy_pass   http://fn;            index  index.html index.htm;          }      }}</code></pre><pre class=" language-shell"><code class="language-shell">#启动ff1节点docker run -it -d --name ff1 -v /home/ff1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre><p>宿主机/home/ff2/nginx.conf配置文件</p><pre class=" language-shell"><code class="language-shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    upstream fn {        server 192.168.99.104:6501;        server 192.168.99.104:6502;        server 192.168.99.104:6503;    }    server {        listen       6602;        server_name  192.168.99.104;         location / {              proxy_pass   http://fn;            index  index.html index.htm;          }      }}</code></pre><pre class=" language-shell"><code class="language-shell">#启动ff2节点docker run -it -d --name ff2 -v /home/ff2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre></li><li><p>配置双机热备</p><pre class=" language-shell"><code class="language-shell">#进入ff1节点docker exec -it ff1 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre class=" language-shell"><code class="language-shell">vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 52    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    virtual_ipaddress {        192.168.99.152    }}virtual_server 192.168.99.151 6701 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6601 {        weight 1    }}</code></pre><pre class=" language-shell"><code class="language-shell">#进入ff1节点docker exec -it ff2 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre class=" language-shell"><code class="language-shell">vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 52    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    virtual_ipaddress {        192.168.99.152    }}virtual_server 192.168.99.151 6701 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6602 {        weight 1    }}</code></pre><p>​</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 前后端分离 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
