<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Android开发相关知识总结</title>
      <link href="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/"/>
      <url>/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Android面试题"><a href="#Android面试题" class="headerlink" title="Android面试题"></a>Android面试题</h1><!-- TOC --><ul><li><a href="#1-android四大组件">1. Android四大组件</a><ul><li><a href="#11-activity">1.1. Activity</a></li><li><a href="#12-服务">1.2. 服务</a></li><li><a href="#13-内容提供程序">1.3. 内容提供程序</a></li><li><a href="#14-广播接收器">1.4. 广播接收器</a></li></ul></li><li><a href="#2-四大组件的启动方式">2. 四大组件的启动方式</a></li><li><a href="#3-画出activity的生命周期图">3. 画出Activity的生命周期图</a></li><li><a href="#4-介绍下不同场景下activity生命周期的变化过程">4. 介绍下不同场景下Activity生命周期的变化过程</a></li><li><a href="#5-当activity-a启动activity-b时生命周期执行过程">5. 当Activity A启动Activity B时，生命周期执行过程？</a></li><li><a href="#6-内存不足时系统会杀掉后台的activity若需要进行一些临时状态的保存在哪个方法进行怎么恢复数据">6. 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？</a></li><li><a href="#7-什么是任务">7. 什么是任务？</a></li><li><a href="#8-activity的启动模式">8. Activity的启动模式？</a></li><li><a href="#9-横竖屏切换时候activity的生命周期">9. 横竖屏切换时候activity的生命周期？</a></li><li><a href="#10-如何将一个activity设置成窗口的样式">10. 如何将一个Activity设置成窗口的样式？</a></li><li><a href="#11-activity之间的数据传递有哪些方式">11. Activity之间的数据传递有哪些方式？</a></li><li><a href="#12-fragment的好处">12. Fragment的好处：</a></li><li><a href="#13-intent的原理作用可以传递哪些类型的参数">13. Intent的原理，作用，可以传递哪些类型的参数？</a></li><li><a href="#14-intent的主要使用方法">14. Intent的主要使用方法</a><ul><li><a href="#141-启动-activity">14.1. 启动 Activity</a></li><li><a href="#142-启动服务">14.2. 启动服务</a></li><li><a href="#143-传递广播">14.3. 传递广播</a></li></ul></li><li><a href="#15-intent包含哪些信息">15. Intent包含哪些信息</a></li><li><a href="#16-什么是intent过滤器">16. 什么是Intent过滤器</a></li><li><a href="#17-service的启动方式">17. Service的启动方式</a></li><li><a href="#18-service的生命周期">18. Service的生命周期</a></li><li><a href="#19-activity怎么和service绑定怎么在activity中启动自己对应的service">19. Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？</a></li><li><a href="#20-允许绑定的已启动服务的生命周期">20. 允许绑定的已启动服务的生命周期</a></li><li><a href="#21-service中可以弹toast吗">21. Service中可以弹Toast吗？</a></li><li><a href="#22-进程的优先级">22. 进程的优先级</a><ul><li><a href="#221-前台进程">22.1. 前台进程</a></li><li><a href="#222-可视进程">22.2. 可视进程</a></li><li><a href="#223-服务进程">22.3. 服务进程</a></li><li><a href="#224-后台进程">22.4. 后台进程</a></li><li><a href="#225-空进程">22.5. 空进程</a></li></ul></li><li><a href="#23-intentservice如何工作">23. IntentService如何工作？</a></li><li><a href="#24-intentservice与service的区别">24. IntentService与Service的区别？</a></li><li><a href="#25-android-service与activity之间的通信方式">25. Android Service与Activity之间的通信方式？</a></li><li><a href="#26-broadcastreceiver简介">26. BroadcastReceiver简介</a><ul><li><a href="#261-用途">26.1. 用途</a></li><li><a href="#262-使用场景">26.2. 使用场景</a></li><li><a href="#263-实现原理">26.3. 实现原理</a></li><li><a href="#264-注册方式">26.4. 注册方式</a></li></ul></li><li><a href="#27-为什么要用contentprovider它和sql的实现上有什么差别">27. 为什么要用ContentProvider？它和SQL的实现上有什么差别？</a></li><li><a href="#28-contentprovider怎么实现数据共享">28. ContentProvider怎么实现数据共享？</a></li><li><a href="#29-android如何访问自定义contentprovider">29. Android如何访问自定义ContentProvider</a></li><li><a href="#30-android中activityintentcontent-providerservice各有什么区别">30. Android中Activity，Intent，Content Provider，Service各有什么区别。</a></li><li><a href="#31-android数据存储方式">31. Android数据存储方式？</a></li><li><a href="#32-android中常用的布局都有哪些">32. Android中常用的布局都有哪些？</a></li><li><a href="#33-androidlayout_gravity和androidgravity的区别">33. <code>android:layout_gravity</code>和<code>android:gravity</code>的区别？</a></li><li><a href="#34-android平台架构">34. Android平台架构</a><ul><li><a href="#341-系统应用">34.1. 系统应用</a></li><li><a href="#342-java-api框架">34.2. Java API框架</a></li><li><a href="#343-原生cc库">34.3. 原生C/C++库</a></li><li><a href="#344-android-runtime">34.4. Android Runtime</a></li><li><a href="#345-硬件抽象层hal">34.5. 硬件抽象层（HAL）</a></li><li><a href="#346-linux-内核">34.6. Linux 内核</a></li></ul></li><li><a href="#35-fragment生命周期">35. Fragment生命周期</a></li><li><a href="#36-activity生命周期对片段生命周期的影响">36. Activity生命周期对片段生命周期的影响</a></li><li><a href="#37-android事件分发">37. Android事件分发</a><ul><li><a href="#371-public-boolean-dispatchtoucheventmotionevent-ev">37.1. <code>public boolean dispatchTouchEvent(MotionEvent ev)</code></a></li><li><a href="#372-public-boolean-onintercepttoucheventmotionevent-ev">37.2. <code>public boolean onInterceptTouchEvent(MotionEvent ev)</code></a></li><li><a href="#373-public-boolean-ontoucheventmotionevent-ev">37.3. <code>public boolean onTouchEvent(MotionEvent ev)</code></a></li></ul></li><li><a href="#38-android系统启动过程">38. Android系统启动过程</a><ul><li><a href="#381-boot-rom">38.1. Boot ROM</a></li><li><a href="#382-boot-loader">38.2. Boot Loader</a></li><li><a href="#383-kernel">38.3. Kernel</a></li><li><a href="#384-init">38.4. init</a><ul><li><a href="#3841-本地服务">38.4.1. 本地服务</a></li><li><a href="#3842-android服务">38.4.2. Android服务</a></li></ul></li><li><a href="#385-zygote-and-dalvikart">38.5. Zygote and Dalvik（ART）</a></li><li><a href="#386-system-server">38.6. System Server</a></li><li><a href="#387-boot-completed">38.7. Boot completed</a></li></ul></li><li><a href="#39-android应用启动过程">39. Android应用启动过程</a></li><li><a href="#40-dpdipdpippi区别">40. dp，dip，dpi，ppi区别</a></li><li><a href="#41-长度和字体的推荐单位">41. 长度和字体的推荐单位</a></li><li><a href="#42-android-view绘制流程">42. Android View绘制流程</a></li><li><a href="#43-listview优化">43. ListView优化</a></li><li><a href="#44-android-binder机制">44. Android Binder机制</a></li><li><a href="#45-binder机制优点">45. Binder机制优点</a></li><li><a href="#46-asynctask简介">46. AsyncTask简介</a></li><li><a href="#47-为什么handler需要声明为static">47. 为什么Handler需要声明为static？</a></li><li><a href="#48-广播注册后不解除注册会有什么问题">48. 广播注册后不解除注册会有什么问题？</a></li><li><a href="#49-自定义view">49. 自定义View</a><ul><li><a href="#491-实现步骤">49.1. 实现步骤</a></li></ul></li><li><a href="#50-需要被重写的方法">50. 需要被重写的方法</a></li><li><a href="#51-parcelable和serializable的区别">51. Parcelable和Serializable的区别</a></li><li><a href="#52-android中的内存泄漏">52. Android中的内存泄漏</a></li><li><a href="#53-mvc和mvp的区别">53. MVC和MVP的区别</a></li><li><a href="#54-内存泄露检测有什么好方法">54. 内存泄露检测有什么好方法？</a></li><li><a href="#55-android里面为什么要设计出bundle而不是直接用map结构">55. Android里面为什么要设计出Bundle而不是直接用Map结构</a></li><li><a href="#56-在android的mvp架构中使用了什么设计模式">56. 在Android的MVP架构中，使用了什么设计模式</a></li><li><a href="#57-android动画类型">57. Android动画类型</a></li><li><a href="#58-anr和fc的区别">58. ANR和FC的区别</a></li><li><a href="#59-android中的菜单">59. Android中的菜单</a><ul><li><a href="#591-选项菜单options-menu">59.1. 选项菜单（Options menu）</a></li><li><a href="#592-上下文菜单contextual-menus">59.2. 上下文菜单（Contextual Menus）</a><ul><li><a href="#5921-浮动上下文菜单floating-context-menu">59.2.1. 浮动上下文菜单（floating context menu）</a></li></ul></li><li><a href="#593-弹出菜单popup-menu">59.3. 弹出菜单（Popup Menu）</a></li></ul></li><li><a href="#60-baseadapter中需要重载的方法">60. BaseAdapter中需要重载的方法</a></li><li><a href="#61-android数字签名要点">61. Android数字签名要点</a></li><li><a href="#62-使用相同数字签名的原因">62. 使用相同数字签名的原因</a></li><li><a href="#63-theme和sytle">63. Theme和Sytle</a><ul><li><a href="#631-style">63.1. Style</a></li><li><a href="#632-theme">63.2. Theme</a></li></ul></li><li><a href="#64-toast的时长设置">64. Toast的时长设置</a></li><li><a href="#65-触发anr的情况">65. 触发ANR的情况</a></li><li><a href="#66-serviceconnection的onserviceconnected触发条件">66. ServiceConnection的<code>onServiceConnected()</code>触发条件</a></li><li><a href="#67-android虚拟设备不支持的功能">67. Android虚拟设备不支持的功能</a></li><li><a href="#68-remoteview的应用">68. RemoteView的应用</a></li><li><a href="#69-android对hashmap做了优化后推出的新的容器类是什么">69. Android对HashMap做了优化后推出的新的容器类是什么？</a><ul><li><a href="#691-sparsearray">69.1. SparseArray</a></li><li><a href="#692-arraymap">69.2. ArrayMap</a></li></ul></li><li><a href="#70-android安全沙盒">70. Android安全沙盒</a></li><li><a href="#71-onstartcommand有哪些返回值">71. <code>onStartCommand()</code>有哪些返回值</a></li><li><a href="#72-如何创建绑定服务">72. 如何创建绑定服务</a><ul><li><a href="#721-扩展binder类">72.1. 扩展Binder类</a></li><li><a href="#722-使用messenger">72.2. 使用Messenger</a></li></ul></li><li><a href="#73-如何绑定到服务">73. 如何绑定到服务</a></li><li><a href="#74-android支持的屏幕密度">74. Android支持的屏幕密度</a></li><li><a href="#75-如何支持多种屏幕">75. 如何支持多种屏幕</a></li><li><a href="#76-什么是资源id">76. 什么是资源ID</a></li><li><a href="#77-如何处理运行时变更">77. 如何处理运行时变更</a><ul><li><a href="#771-在配置变更期间保留对象">77.1. 在配置变更期间保留对象</a></li><li><a href="#772-自行处理配置变更">77.2. 自行处理配置变更</a></li></ul></li><li><a href="#78-androidmanifestxml包括哪些内容">78. AndroidManifest.xml包括哪些内容？</a></li><li><a href="#79-用户界面如何构成">79. 用户界面如何构成？</a></li><li><a href="#80-为什么要回收bitmap的内存">80. 为什么要回收Bitmap的内存</a></li><li><a href="#81-如何优化bitmap">81. 如何优化Bitmap</a></li><li><a href="#82-如何在新进程中创建activity／service">82. 如何在新进程中创建Activity／Service</a></li><li><a href="#83-onactivityresult什么时候会失效">83. <code>onActivityResult()</code>什么时候会失效？</a></li><li><a href="#84-android崩溃捕获">84. Android崩溃捕获</a><ul><li><a href="#841-java崩溃捕获">84.1. Java崩溃捕获</a></li><li><a href="#842-native崩溃捕获">84.2. Native崩溃捕获</a></li></ul></li><li><a href="#85-android-app构建流程">85. Android APP构建流程</a></li><li><a href="#86-class文件与dex文件的区别">86. class文件与.dex文件的区别</a></li><li><a href="#87-65535问题">87. 65535问题</a><ul><li><a href="#871-原因">87.1. 原因</a></li><li><a href="#872-解决方法">87.2. 解决方法</a></li></ul></li><li><a href="#88-dalvik与jvm的区别">88. Dalvik与JVM的区别</a></li><li><a href="#89-art相对dalvik的优化">89. ART相对Dalvik的优化</a></li><li><a href="#90-android中的classloader">90. Android中的ClassLoader</a></li><li><a href="#91-classloader方式实现热修复">91. ClassLoader方式实现热修复</a></li><li><a href="#92-asynctask需要在主线程中实例化吗">92. AsyncTask需要在主线程中实例化吗？</a><ul><li><a href="#921-api-16之前">92.1. API 16之前</a></li><li><a href="#922-api-16及之后api-22之前">92.2. API 16及之后，API 22之前</a></li><li><a href="#923-api-22及之后">92.3. API 22及之后</a></li></ul></li><li><a href="#93-android消息处理机制">93. Android消息处理机制</a><ul><li><a href="#931-looper">93.1. Looper</a></li><li><a href="#932-handler">93.2. Handler</a></li></ul></li><li><a href="#94-startactivity执行流程">94. <code>startActivity()</code>执行流程</a></li></ul><!-- /TOC --><h2 id="1-Android四大组件"><a href="#1-Android四大组件" class="headerlink" title="1. Android四大组件"></a>1. Android四大组件</h2><p>应用组件是Android应用的基本构建基块。每个组件都是一个不同的点，系统可以通过它进入您的应用。并非所有组件都是用户的实际入口点，有些组件相互依赖，但每个组件都以独立实体形式存在，并发挥特定作用—-每个组件都是唯一的构建基块，有助于定义应用的总体行为。</p><p>共有四种不同的应用组件类型。每种类型都服务于不同的目的，并且具有定义组件的创建和销毁方式的不同生命周期。</p><p>以下便是这四种应用组件类型：</p><h3 id="1-1-Activity"><a href="#1-1-Activity" class="headerlink" title="1.1. Activity"></a>1.1. Activity</h3><p>Activity表示具有用户界面的单一屏幕。例如，电子邮件应用可能具有一个显示新电子邮件列表的Activity、一个用于撰写电子邮件的Activity以及一个用于阅读电子邮件的Activity。尽管这些Activity通过协作在电子邮件应用中形成了一种紧密结合的用户体验，但每一个Activity都独立于其他Activity而存在。因此，其他应用可以启动其中任何一个Activity（如果电子邮件应用允许）。例如，相机应用可以启动电子邮件应用内用于撰写新电子邮件的Activity，以便用户共享图片。</p><h3 id="1-2-服务"><a href="#1-2-服务" class="headerlink" title="1.2. 服务"></a>1.2. 服务</h3><p>服务是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。服务不提供用户界面。例如，当用户位于其他应用中时，服务可能在后台播放音乐或者通过网络获取数据，但不会阻断用户与Activity的交互。诸如Activity等其他组件可以启动服务，让其运行或与其绑定以便与其进行交互。</p><h3 id="1-3-内容提供程序"><a href="#1-3-内容提供程序" class="headerlink" title="1.3. 内容提供程序"></a>1.3. 内容提供程序</h3><p>内容提供程序管理一组共享的应用数据。您可以将数据存储在文件系统、SQLite数据库、网络上或您的应用可以访问的任何其他永久性存储位置。其他应用可以通过内容提供程序查询数据，甚至修改数据（如果内容提供程序允许）。例如，Android系统可提供管理用户联系人信息的内容提供程序。因此，任何具有适当权限的应用都可以查询内容提供程序的某一部分（如<code>ContactsContract.Data</code>），以读取和写入有关特定人员的信息。</p><p>内容提供程序也适用于读取和写入您的应用不共享的私有数据。例如，记事本示例应用使用内容提供程序来保存笔记。</p><h3 id="1-4-广播接收器"><a href="#1-4-广播接收器" class="headerlink" title="1.4. 广播接收器"></a>1.4. 广播接收器</h3><p>广播接收器是一种用于响应系统范围广播通知的组件。许多广播都是由系统发起的—-例如，通知屏幕已关闭、电池电量不足或已拍摄照片的广播。应用也可以发起广播—-例如，通知其他应用某些数据已下载至设备，并且可供其使用。尽管广播接收器不会显示用户界面，但它们可以创建状态栏通知，在发生广播事件时提醒用户。但广播接收器更常见的用途只是作为通向其他组件的”通道”，设计用于执行极少量的工作。例如，它可能会基于事件发起一项服务来执行某项工作。</p><h2 id="2-四大组件的启动方式"><a href="#2-四大组件的启动方式" class="headerlink" title="2. 四大组件的启动方式"></a>2. 四大组件的启动方式</h2><ul><li>您可以通过将Intent传递到<code>startActivity()</code>或<code>startActivityForResult()</code>（当您想让Activity返回结果时）来启动Activity（或为其安排新任务）。</li><li>您可以通过将Intent传递到<code>startService()</code>来启动服务（或对执行中的服务下达新指令）。或者，您也可以通过将Intent传递到<code>bindService()</code>来绑定到该服务。</li><li>您可以通过将Intent传递到<code>sendBroadcast()</code>、<code>sendOrderedBroadcast()</code>或<code>sendStickyBroadcast()</code>等方法来发起广播。</li><li>您可以通过在ContentResolver上调用<code>query()</code>来对内容提供程序执行查询。</li></ul><h2 id="3-画出Activity的生命周期图"><a href="#3-画出Activity的生命周期图" class="headerlink" title="3. 画出Activity的生命周期图"></a>3. 画出Activity的生命周期图</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/activity_lifecycle.png" alt="activity lifecycle"></p><h2 id="4-介绍下不同场景下Activity生命周期的变化过程"><a href="#4-介绍下不同场景下Activity生命周期的变化过程" class="headerlink" title="4. 介绍下不同场景下Activity生命周期的变化过程"></a>4. 介绍下不同场景下Activity生命周期的变化过程</h2><ul><li>启动Activity：<code>onCreate()</code> –&gt; <code>onStart()</code> –&gt; <code>onResume()</code>，Activity进入运行状态。</li><li>Activity退居后台：当前Activity转到新的Activity界面或按Home键回到主屏：<code>onPause()</code> –&gt; <code>onStop()</code>，进入停滞状态；这里有一种特殊情况，如果新Activity采用了透明主题，那么当前Activity不会回调<code>onStop()</code>。</li><li>Activity返回前台：<code>onRestart()</code> –&gt; <code>onStart()</code> –&gt; <code>onResume()</code>，再次回到运行状态。</li><li>Activity退居后台，且系统内存不足，系统会杀死这个后台状态的Activity，若再次回到这个Activity，则会走<code>onCreate()</code> –&gt; <code>onStart()</code> –&gt; <code>onResume()</code>。</li><li>锁定屏与解锁屏幕只会调用<code>onPause()</code>，而不会调用<code>onStop()</code>方法，开屏后则调用<code>onResume()</code>。</li></ul><h2 id="5-当Activity-A启动Activity-B时，生命周期执行过程？"><a href="#5-当Activity-A启动Activity-B时，生命周期执行过程？" class="headerlink" title="5. 当Activity A启动Activity B时，生命周期执行过程？"></a>5. 当Activity A启动Activity B时，生命周期执行过程？</h2><p><code>A.onPause()</code> –&gt; <code>B.onCreate()</code>，<code>B.onStart()</code>，<code>B.onResume()</code> –&gt; <code>A.onStop()</code>，如果B是个透明的，或者是对话框的样式，就不会调用<code>A.onStop()</code>。</p><h2 id="6-内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？"><a href="#6-内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？" class="headerlink" title="6. 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？"></a>6. 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？</h2><ul><li>Activity的<code>onSaveInstanceState()</code>和<code>onRestoreInstanceState()</code>并不是生命周期方法，它们不同于<code>onCreate()</code>、<code>onPause()</code>等生命周期方法，它们并不一定会被触发。</li><li>当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity，<code>onSaveInstanceState()</code>会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，<code>onSaveInstanceState()</code>就不会被调用。除非该activity是被用户主动销毁的，通常<code>onSaveInstanceState()</code>只适合用于保存一些临时性的状态，而<code>onPause()</code>适合用于数据的持久化保存。</li><li>重写<code>onSaveInstanceState()</code>方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写<code>onRestoreInstanceState()</code>方法可以从中提取保存好的数据。</li></ul><h2 id="7-什么是任务？"><a href="#7-什么是任务？" class="headerlink" title="7. 什么是任务？"></a>7. 什么是任务？</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/activity_task.png" alt="Activity Task"></p><p>任务是一个有机整体，当用户开始新任务或通过“主页”按钮转到主屏幕时，可以移动到“后台”。尽管在后台时，该任务中的所有Activity全部停止，但是任务的返回栈仍旧不变，也就是说，当另一个任务发生时，该任务仅仅失去焦点而已，如图所示。然后，任务可以返回到“前台”，用户就能够回到离开时的状态。</p><h2 id="8-Activity的启动模式？"><a href="#8-Activity的启动模式？" class="headerlink" title="8. Activity的启动模式？"></a>8. Activity的启动模式？</h2><ul><li>standard（默认模式）：系统在启动Activity的任务中创建Activity的新实例并向其传送Intent。Activity可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。</li><li>singleTop：如果当前任务的顶部已存在Activity的一个实例，则系统会通过调用该实例的onNewIntent()方法向其传送Intent，而不是创建Activity的新实例。Activity可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例（但前提是位于返回栈顶部的Activity并不是Activity的现有实例）。例如，假设任务的返回栈包含根Activity A以及Activity B、C和位于顶部的D（堆栈是A-B-C-D；D位于顶部）。收到针对D类Activity的Intent。如果D具有默认的”standard”启动模式，则会启动该类的新实例，且堆栈会变成A-B-C-D-D。但是，如果D的启动模式是”singleTop”，则D的现有实例会通过onNewIntent()接收Intent，因为它位于堆栈的顶部；而堆栈仍为A-B-C-D。但是，如果收到针对B类Activity的Intent，则会向堆栈添加B的新实例，即便其启动模式为”singleTop”也是如此。</li><li>singleTask：系统创建新任务并实例化位于新任务底部的Activity。但是，如果该Activity的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的onNewIntent()方法向其传送Intent，而不是创建新实例。一次只能存在Activity的一个实例。</li><li>singleInstace：与”singleTask”相同，只是系统不会将任何其他Activity启动到包含实例的任务中。该Activity始终是其任务唯一仅有的成员；由此Activity启动的任何Activity均在单独的任务中打开。</li></ul><h2 id="9-横竖屏切换时候activity的生命周期？"><a href="#9-横竖屏切换时候activity的生命周期？" class="headerlink" title="9. 横竖屏切换时候activity的生命周期？"></a>9. 横竖屏切换时候activity的生命周期？</h2><ul><li>不设置Activity的<code>android：configChanges</code>时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。</li><li>设置Activity的<code>android：configChanges=&quot;orientation&quot;</code>时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。</li><li>设置Activity的<code>android：configChanges=&quot;orientation|keyboardHidden&quot;</code>时，切屏不会重新调用各个生命周期，只会执行<code>onConfigurationChanged()</code>方法。</li></ul><h2 id="10-如何将一个Activity设置成窗口的样式？"><a href="#10-如何将一个Activity设置成窗口的样式？" class="headerlink" title="10. 如何将一个Activity设置成窗口的样式？"></a>10. 如何将一个Activity设置成窗口的样式？</h2><p>只需要给我们的Activity配置如下属性即可<code>android:theme=&quot;@android:style/Theme.Dialog&quot;</code>。</p><h2 id="11-Activity之间的数据传递有哪些方式？"><a href="#11-Activity之间的数据传递有哪些方式？" class="headerlink" title="11. Activity之间的数据传递有哪些方式？"></a>11. Activity之间的数据传递有哪些方式？</h2><ul><li><code>intent.putExtra()</code>方法；</li><li>使用全局变量Application；</li><li>使用静态变量；</li><li>剪切板ClipboardManager传递数据；</li><li>借助Application共享Handler利用消息处理机制；</li><li>使用Broadcast广播；</li><li>使用EventBus。</li></ul><h2 id="12-Fragment的好处："><a href="#12-Fragment的好处：" class="headerlink" title="12. Fragment的好处："></a>12. Fragment的好处：</h2><ul><li>Fragment可以使你能够将activity分离成多个可重用的组件，每个都有它自己的生命周期和UI。</li><li>Fragment可以轻松得创建动态灵活的UI设计，可以适应于不同的屏幕尺寸。从手机到平板电脑。</li><li>Fragment是一个独立的模块，紧紧地与activity绑定在一起。可以运行中动态地移除、加入、交换等。</li><li>Fragment提供一个新的方式让你在不同的安卓设备上统一你的UI。</li><li>Fragment解决Activity间的切换不流畅，轻量切换。</li><li>Fragment替代TabActivity做导航，性能更好。</li><li>Fragment在Android 4.2中新增嵌套fragment使用方法，能够生成更好的界面效果。</li></ul><h2 id="13-Intent的原理，作用，可以传递哪些类型的参数？"><a href="#13-Intent的原理，作用，可以传递哪些类型的参数？" class="headerlink" title="13. Intent的原理，作用，可以传递哪些类型的参数？"></a>13. Intent的原理，作用，可以传递哪些类型的参数？</h2><ul><li>Intent是连接Activity、Service、BroadcastReceiver和ContentProvider四大组件的信使，可以传递八种基本数据类型以及<code>String</code>、<code>Bundle</code>类型，以及实现了<code>Serializable</code>或者<code>Parcelable</code>的类型。</li><li><p>Intent可以划分成显式意图和隐式意图。</p><ul><li>显式意图：调用<code>Intent.setComponent()</code>或<code>Intent.setClass()</code>方法明确指定了组件名的Intent为显式意图，显式意图明确指定了Intent应该传递给哪个组件。</li><li>隐式意图：没有明确指定组件名的Intent为隐式意图。Android系统会根据隐式意图中设置的动作（<code>action</code>）、类别（<code>category</code>）、数据（URI和数据类型）找到最合适的组件来处理这个意图。</li></ul></li></ul><h2 id="14-Intent的主要使用方法"><a href="#14-Intent的主要使用方法" class="headerlink" title="14. Intent的主要使用方法"></a>14. Intent的主要使用方法</h2><h3 id="14-1-启动-Activity"><a href="#14-1-启动-Activity" class="headerlink" title="14.1. 启动 Activity"></a>14.1. 启动 Activity</h3><p>Activity表示应用中的一个屏幕。通过将Intent传递给<code>startActivity()</code>，您可以启动新的 Activity实例。Intent描述了要启动的Activity，并携带了任何必要的数据。</p><p>如果您希望在Activity完成后收到结果，请调用<code>startActivityForResult()</code>。在 Activity的<code>onActivityResult()</code>回调中，您的Activity将结果作为单独的Intent对象接收。</p><h3 id="14-2-启动服务"><a href="#14-2-启动服务" class="headerlink" title="14.2. 启动服务"></a>14.2. 启动服务</h3><p>Service是一个不使用用户界面而在后台执行操作的组件。通过将Intent传递给<code>startService()</code>，您可以启动服务执行一次性操作（例如，下载文件）。Intent描述了要启动的服务，并携带了任何必要的数据。</p><p>如果服务旨在使用客户端——服务器接口，则通过将Intent传递给<code>bindService(</code>)，您可以从其他组件绑定到此服务。</p><h3 id="14-3-传递广播"><a href="#14-3-传递广播" class="headerlink" title="14.3. 传递广播"></a>14.3. 传递广播</h3><p>广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将Intent传递给<code>sendBroadcast()</code>、<code>sendOrderedBroadcast()</code>或<code>sendStickyBroadcast()</code>，您可以将广播传递给其他应用。</p><h2 id="15-Intent包含哪些信息"><a href="#15-Intent包含哪些信息" class="headerlink" title="15. Intent包含哪些信息"></a>15. Intent包含哪些信息</h2><ul><li>组件名称：要启动的组件名称。</li><li>操作：指定要执行的通用操作（例如，“查看”或“选取”）的字符串。</li><li>数据：引用待操作数据和／或该数据MIME类型的URI（Uri对象）。提供的数据类型通常由Intent的操作决定。例如，如果操作是<code>ACTION_EDIT</code>，则数据应包含待编辑文档的URI。</li><li>类别：一个包含应处理Intent组件类型的附加信息的字符串。</li><li>Extra：携带完成请求操作所需的附加信息的键值对。</li><li>标志：在Intent类中定义的、充当Intent元数据的标志。</li></ul><h2 id="16-什么是Intent过滤器"><a href="#16-什么是Intent过滤器" class="headerlink" title="16. 什么是Intent过滤器"></a>16. 什么是Intent过滤器</h2><p>要公布应用可以接收哪些隐式Intent，请在清单文件中使用<code>&lt;intent-filter&gt;</code>元素为每个应用组件声明一个或多个Intent过滤器。每个Intent过滤器均由应用清单文件中的<code>&lt;intent-filter&gt;</code>元素定义，并嵌套在相应的应用组件（例如，<code>&lt;activity&gt;</code>元素）中。在<code>&lt;intent-filter&gt;</code>内部，您可以使用以下三个元素中的一个或多个指定要接受的Intent类型：</p><ul><li><code>&lt;action&gt;</code>：在<code>name</code>属性中，声明接受的Intent操作。该值必须是操作的文本字符串值，而不是类常量。</li><li><code>&lt;data&gt;</code>：使用一个或多个指定数据URI各个方面（scheme、host、port、path等）和MIME类型的属性，声明接受的数据类型。</li><li><code>&lt;category&gt;</code>：在<code>name</code>属性中，声明接受的Intent类别。该值必须是操作的文本字符串值，而不是类常量。</li></ul><h2 id="17-Service的启动方式"><a href="#17-Service的启动方式" class="headerlink" title="17. Service的启动方式"></a>17. Service的启动方式</h2><ul><li><code>startService()</code>：只是启动Service，Activity和Service并没有绑定，只有当Service调用<code>stopService()</code>服务才会终止。</li><li><code>bindService()</code>：这种启动方式Activity和Service进行了绑定，启动Service的组件可以通过回调获取Service的代理对象和Service交互；当启动方销毁时，Service也会自动进行<code>unBind()</code>操作，当发现所有绑定都进行了<code>unBind()</code>时才会销毁Service。</li></ul><h2 id="18-Service的生命周期"><a href="#18-Service的生命周期" class="headerlink" title="18. Service的生命周期"></a>18. Service的生命周期</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/service_lifecycle.png" alt="service lifecycle"></p><h2 id="19-Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？"><a href="#19-Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？" class="headerlink" title="19. Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？"></a>19. Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？</h2><ul><li>Activity通过<code>bindService(Intent service，ServiceConnection conn，int flags)</code>跟Service进行绑定，当绑定成功的时候Service会将代理对象通过回调的形式传给<code>conn</code>，这样我们就拿到了Service提供的服务代理对象。</li><li>在Activity中可以通过<code>startService()</code>和<code>bindService()</code>方法启动Service。一般情况下如果想获取Service的服务对象那么肯定需要通过<code>bindService()</code>方法，比如音乐播放器，第三方支付等。如果仅仅只是为了开启一个后台任务那么可以使用<code>startService()</code>方法。</li></ul><h2 id="20-允许绑定的已启动服务的生命周期"><a href="#20-允许绑定的已启动服务的生命周期" class="headerlink" title="20. 允许绑定的已启动服务的生命周期"></a>20. 允许绑定的已启动服务的生命周期</h2><p>当服务与所有客户端之间的绑定全部取消时，Android系统便会销毁服务。不过，如果您选择实现<code>onStartCommand()</code>回调方法，则您必须显式停止服务，因为系统现在已将服务视为已启动。在此情况下，服务将一直运行到其通过<code>stopSelf()</code>自行停止，或其他组件调用<code>stopService()</code>为止，无论其是否绑定到任何客户端。</p><p>此外，如果您的服务已启动并接受绑定，则当系统调用您的<code>onUnbind()</code>方法时，如果您想在客户端下一次绑定到服务时接收<code>onRebind()</code>调用，则可选择返回true。<code>onRebind()</code>返回空值，但客户端仍在其<code>onServiceConnected()</code>回调中接收IBinder。</p><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/service_binding_tree_lifecycle.png" alt="service binding tree lifecycle"></p><h2 id="21-Service中可以弹Toast吗？"><a href="#21-Service中可以弹Toast吗？" class="headerlink" title="21. Service中可以弹Toast吗？"></a>21. Service中可以弹Toast吗？</h2><ul><li>这个问题其实就是问一下Service是执行在UI线程中吗？类似的问题还有”Service的<code>onCreate()</code>回调函数可以做耗时的操作吗？”，”Service是否在main thread中执行”，”Service和Activity在同一个线程吗？”等；</li><li>我们要牢记一句真理”默认情况下四大组件都是在UI线程中执行的”，Service本身就是Context的子类，我们可以获取到Context对象，所以Service中当然可以弹Toast，同理，Service的<code>onCreate()</code>回调函数不可以做耗时的操作。</li></ul><h2 id="22-进程的优先级"><a href="#22-进程的优先级" class="headerlink" title="22. 进程的优先级"></a>22. 进程的优先级</h2><h3 id="22-1-前台进程"><a href="#22-1-前台进程" class="headerlink" title="22.1. 前台进程"></a>22.1. 前台进程</h3><p>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</p><ul><li>托管用户正在交互的Activity（已调用Activity的<code>onResume()</code>方法）；</li><li>托管某个Service，后者绑定到用户正在交互的Activity；</li><li>托管正在”前台”运行的Service（服务已调用<code>startForeground()</code>）；</li><li>托管正执行一个生命周期回调的Service（<code>onCreate()</code>、<code>onStart()</code>或<code>onDestroy()</code>）；</li><li>托管正执行其<code>onReceive()</code>方法的BroadcastReceiver。</li></ul><p>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</p><h3 id="22-2-可视进程"><a href="#22-2-可视进程" class="headerlink" title="22.2. 可视进程"></a>22.2. 可视进程</h3><p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。如果一个进程满足以下任一条件，即视为可见进程：</p><ul><li>托管不在前台、但仍对用户可见的Activity（已调用其<code>onPause()</code>方法）。例如，如果前台Activity启动了一个对话框，允许在其后显示上一Activity，则有可能会发生这种情况。</li><li>托管绑定到可见（或前台）Activity的Service。</li></ul><p>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p><h3 id="22-3-服务进程"><a href="#22-3-服务进程" class="headerlink" title="22.3. 服务进程"></a>22.3. 服务进程</h3><p>正在运行已使用<code>startService()</code>方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p><h3 id="22-4-后台进程"><a href="#22-4-后台进程" class="headerlink" title="22.4. 后台进程"></a>22.4. 后台进程</h3><p>包含目前对用户不可见的Activity的进程（已调用Activity的<code>onStop()</code>方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。通常会有很多后台进程在运行，因此它们会保存在LRU（最近最少使用）列表中，以确保包含用户最近查看的Activity的进程最后一个被终止。如果某个Activity正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该Activity时，Activity会恢复其所有可见状态。</p><h3 id="22-5-空进程"><a href="#22-5-空进程" class="headerlink" title="22.5. 空进程"></a>22.5. 空进程</h3><p>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p><h2 id="23-IntentService如何工作？"><a href="#23-IntentService如何工作？" class="headerlink" title="23. IntentService如何工作？"></a>23. IntentService如何工作？</h2><ul><li>创建默认的工作线程，用于在应用的主线程外执行传递给<code>onStartCommand()</code>的所有Intent。</li><li>创建工作队列，用于将Intent逐一传递给<code>onHandleIntent()</code>实现，这样您就永远不必担心多线程问题。</li><li>在处理完所有启动请求后停止服务，因此您永远不必调用<code>stopSelf()</code>。</li><li>提供<code>onBind()</code>的默认实现（返回<code>null</code>）。</li><li>提供<code>onStartCommand()</code>的默认实现，可将Intent依次发送到工作队列和<code>onHandleIntent()</code>实现。</li></ul><h2 id="24-IntentService与Service的区别？"><a href="#24-IntentService与Service的区别？" class="headerlink" title="24. IntentService与Service的区别？"></a>24. IntentService与Service的区别？</h2><ul><li>Service也不是专门一条新线程，因此不应该在Service中直接处理耗时的任务；</li><li>Service不会专门启动一条单独的进程，Service与它所在应用位于同一个进程中；</li><li>IntentService是Service的子类，是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题；</li><li>IntentService会创建独立的worker线程来处理所有的Intent请求；</li><li>IntentService不会阻塞UI线程，而普通Serveice会导致ANR异常；</li><li>Intentservice若未执行完成上一次的任务，将不会新开一个线程，是等待之前的任务完成后，再执行新的任务，等任务完成后再次调用<code>stopSelf()</code>；</li><li>正在运行的IntentService的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。</li></ul><h2 id="25-Android-Service与Activity之间的通信方式？"><a href="#25-Android-Service与Activity之间的通信方式？" class="headerlink" title="25. Android Service与Activity之间的通信方式？"></a>25. Android Service与Activity之间的通信方式？</h2><ul><li><p>通过Binder对象：当Activity通过调用<code>bindService(Intent service，ServiceConnection conn，int flags)</code>，得到一个Service的一个对象，通过这个对象我们可以直接访问Service中的方法。</p><ul><li>添加一个继承Binder的内部类，并添加相应的逻辑方法。</li><li>重写Service的<code>onBind()</code>方法，返回我们刚刚定义的那个内部类实。</li><li>Activity中创建一个ServiceConnection的匿名内部类，并且重写里面的<code>onServiceConnected()</code>方法和<code>onServiceDisconnected()</code>方法，这两个方法分别会在活动与服务成功绑定以及解除绑定的时候调用，在<code>onServiceConnected()</code>方法中，我们可以得到一个刚才那个service的binder对象，通过对这个binder对象进行向下转型，得到我们那个自定义的Binder实例，有了这个实例，做可以调用这个实例里面的具体方法进行需要的操作了。</li></ul></li><li><p>通过Broadcast Receiver：当我们的进度发生变化的时候我们发送一条广播，然后在Activity的注册广播接收器，接收到广播之后更新视图</p></li><li><p>EventBus</p></li></ul><h2 id="26-BroadcastReceiver简介"><a href="#26-BroadcastReceiver简介" class="headerlink" title="26. BroadcastReceiver简介"></a>26. BroadcastReceiver简介</h2><p>在Android中，Broadcast是一种广泛运用的在应用程序之间传输信息的机制。</p><h3 id="26-1-用途"><a href="#26-1-用途" class="headerlink" title="26.1. 用途"></a>26.1. 用途</h3><ul><li>实现了不同的程序之间的数据传输与共享，因为只要是和发送广播的<code>action</code>相同的接受者都能接受这个广播。典型的应用就是Android自带的短信，电话等等广播，只要我们实现了他们的<code>action</code>的广播，那么我们就能接收他们的数据了，以便做出一些处理。比如说拦截系统短信，拦截骚扰电话等。</li><li>起到了一个通知的作用，比如在Service中要通知主程序，更新主程序的UI等。因为Service是没有界面的，所以不能直接获得主程序中的控件，这样我们就只能在主程序中实现一个广播接受者专门用来接受Service发过来的数据和通知了。</li></ul><h3 id="26-2-使用场景"><a href="#26-2-使用场景" class="headerlink" title="26.2. 使用场景"></a>26.2. 使用场景</h3><ul><li>同一app内部的同一组件内的消息通信（单个或多个线程之间）；</li><li>同一app内部的不同组件之间的消息通信（单个进程）；</li><li>同一app具有多个进程的不同组件之间的消息通信；</li><li>不同app之间的组件之间消息通信；</li><li>Android系统在特定情况下与App之间的消息通信。</li></ul><h3 id="26-3-实现原理"><a href="#26-3-实现原理" class="headerlink" title="26.3. 实现原理"></a>26.3. 实现原理</h3><p>从实现原理看上，Android中的广播使用了观察者模式，基于消息的发布/订阅事件模型。因此，从实现的角度来看，Android中的广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。具体实现流程要点粗略概括如下：</p><ol><li>广播接收者BroadcastReceiver通过Binder机制向AMS（Activity Manager Service)进行注册；</li><li>广播发送者通过binder机制向AMS发送广播；</li><li>AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；</li><li>消息循环执行拿到此广播，回调BroadcastReceiver中的<code>onReceive()</code>方法。</li></ol><h3 id="26-4-注册方式"><a href="#26-4-注册方式" class="headerlink" title="26.4. 注册方式"></a>26.4. 注册方式</h3><ul><li>静态注册；</li><li>动态注册。</li></ul><h2 id="27-为什么要用ContentProvider？它和SQL的实现上有什么差别？"><a href="#27-为什么要用ContentProvider？它和SQL的实现上有什么差别？" class="headerlink" title="27. 为什么要用ContentProvider？它和SQL的实现上有什么差别？"></a>27. 为什么要用ContentProvider？它和SQL的实现上有什么差别？</h2><ul><li>ContentProvider屏蔽了数据存储的细节，内部实现对用户完全透明，用户只需要关心操作数据的uri就可以了，ContentProvider可以实现不同app之间共享。SQL只能在该工程的内部共享数据，ContentProvider能在工程之间实现数据共享。</li><li>SQL也有增删改查的方法，但是SQL只能查询本应用下的数据库。而ContentProvider还可以去增删改查本地文件.xml文件的读取等。</li></ul><h2 id="28-ContentProvider怎么实现数据共享？"><a href="#28-ContentProvider怎么实现数据共享？" class="headerlink" title="28. ContentProvider怎么实现数据共享？"></a>28. ContentProvider怎么实现数据共享？</h2><p>一个程序可以通过实现一个ContentProvider的抽象接口将自己的数据完全暴露出去，而且ContentProvider是以类似数据库中表的方式将数据暴露。ContentProvider存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的ContentProvider中，前提是有相同数据类型并且有写入ContentProvider的权限。</p><h2 id="29-Android如何访问自定义ContentProvider"><a href="#29-Android如何访问自定义ContentProvider" class="headerlink" title="29. Android如何访问自定义ContentProvider"></a>29. Android如何访问自定义ContentProvider</h2><ol><li>得到ContentResolver类对象：<code>ContentResolver cr = getContentResolver()</code>；</li><li>定义要查询的字段<code>String</code>数组；</li><li>使用<code>cr.query()</code>返回一个<code>Cursor</code>对象；</li><li>使用<code>while</code>循环得到<code>Cursor</code>里面的内容。</li></ol><h2 id="30-Android中Activity，Intent，Content-Provider，Service各有什么区别。"><a href="#30-Android中Activity，Intent，Content-Provider，Service各有什么区别。" class="headerlink" title="30. Android中Activity，Intent，Content Provider，Service各有什么区别。"></a>30. Android中Activity，Intent，Content Provider，Service各有什么区别。</h2><ul><li>Activity：活动，是最基本的Android应用程序组件。一个活动就是一个单独的屏幕，每一个活动都被实现为一个独立的类，并且从活动基类继承而来。</li><li>Intent：意图，描述应用想干什么。最重要的部分是动作和动作对应的数据。</li><li>Content Provider：内容提供器，Android应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当你想将你的应用数据和其他应用共享时，内容提供器就可以发挥作用了。</li><li>Service：服务，具有一段较长生命周期且没有用户界面的程序。</li></ul><h2 id="31-Android数据存储方式？"><a href="#31-Android数据存储方式？" class="headerlink" title="31. Android数据存储方式？"></a>31. Android数据存储方式？</h2><ul><li>SharedPreferences：以键值对的形式保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。</li><li>文件存储数据：Context提供了两个方法来打开数据文件里的文件IO流<code>FileInputStream openFileInput(String name)</code>，<code>FileOutputStream(String name，int mode)</code>，这两个方法第一个参数用于指定文件名，第二个参数指定打开文件的模式；文件默认存储位置：<code>/data/data/包名/files/文件名</code>。</li><li>SQLite存储数据。</li><li>使用ContentProvider存储数据。</li><li>网络存储数据。</li></ul><h2 id="32-Android中常用的布局都有哪些？"><a href="#32-Android中常用的布局都有哪些？" class="headerlink" title="32. Android中常用的布局都有哪些？"></a>32. Android中常用的布局都有哪些？</h2><ul><li>FrameLayout；</li><li>RelativeLayout；</li><li>LinearLayout；</li><li>AbsoluteLayout；</li><li>TableLayout；</li><li>GridLayout。</li></ul><h2 id="33-android-layout-gravity和android-gravity的区别？"><a href="#33-android-layout-gravity和android-gravity的区别？" class="headerlink" title="33. android:layout_gravity和android:gravity的区别？"></a>33. <code>android:layout_gravity</code>和<code>android:gravity</code>的区别？</h2><ul><li><code>android:layout_gravity</code>是让该布局在其父控件中的布局方式。</li><li><code>android:gravity</code>是该布局布置其子对象的布局方式。</li></ul><h2 id="34-Android平台架构"><a href="#34-Android平台架构" class="headerlink" title="34. Android平台架构"></a>34. Android平台架构</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/android_platform.png" alt="android platform"></p><h3 id="34-1-系统应用"><a href="#34-1-系统应用" class="headerlink" title="34.1. 系统应用"></a>34.1. 系统应用</h3><p>Android随附一套用于电子邮件、短信、日历、互联网浏览和联系人等的核心应用。平台随附的应用与用户可以选择安装的应用一样，没有特殊状态。因此第三方应用可成为用户的默认网络浏览器、短信Messenger甚至默认键盘（有一些例外，例如系统的”设置”应用）。</p><p>系统应用可用作用户的应用，以及提供开发者可从其自己的应用访问的主要功能。例如，如果您的应用要发短信，您无需自己构建该功能，可以改为调用已安装的短信应用向您指定的接收者发送消息。</p><h3 id="34-2-Java-API框架"><a href="#34-2-Java-API框架" class="headerlink" title="34.2. Java API框架"></a>34.2. Java API框架</h3><p>您可通过以Java语言编写的API使用Android OS的整个功能集。这些API形成创建Android应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务：</p><ul><li>丰富、可扩展的视图系统，可用以构建应用的UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器；</li><li>资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件；</li><li>通知管理器，可让所有应用在状态栏中显示自定义提醒；</li><li>Activity管理器，用于管理应用的生命周期，提供常见的导航返回栈；</li><li>内容提供程序，可让应用访问其他应用（例如”联系人”应用）中的数据或者共享其自己的数据。</li></ul><p>开发者可以完全访问Android系统应用使用的框架API。</p><h3 id="34-3-原生C-C-库"><a href="#34-3-原生C-C-库" class="headerlink" title="34.3. 原生C/C++库"></a>34.3. 原生C/C++库</h3><p>许多核心Android系统组件和服务（例如ART和HAL）构建自原生代码，需要以C和C++编写的原生库。Android平台提供Java框架API以向应用显示其中部分原生库的功能。例如，您可以通过Android框架的Java OpenGL API访问OpenGL ES，以支持在应用中绘制和操作2D和3D图形。</p><p>如果开发的是需要C或C++代码的应用，可以使用Android NDK直接从原生代码访问某些原生平台库。</p><h3 id="34-4-Android-Runtime"><a href="#34-4-Android-Runtime" class="headerlink" title="34.4. Android Runtime"></a>34.4. Android Runtime</h3><p>对于运行Android 5.0（API级别21）或更高版本的设备，每个应用都在其自己的进程中运行，并且有其自己的Android Runtime(ART)实例。ART编写为通过执行DEX文件在低内存设备上运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如Jack）将Java源代码编译为DEX字节码，使其可在Android平台上运行。</p><p>ART的部分主要功能包括：</p><ul><li>预先（AOT）和即时（JIT）编译；</li><li>优化的垃圾回收（GC）；</li><li>更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置监视点以监控特定字段；</li></ul><p>在Android版本5.0（API级别21）之前，Dalvik是Android Runtime。如果您的应用在ART上运行效果很好，那么它应该也可在Dalvik上运行，但反过来不一定。</p><p>Android还包含一套核心运行时库，可提供Java API框架使用的Java编程语言大部分功能，包括一些Java 8语言功能。</p><h3 id="34-5-硬件抽象层（HAL）"><a href="#34-5-硬件抽象层（HAL）" class="headerlink" title="34.5. 硬件抽象层（HAL）"></a>34.5. 硬件抽象层（HAL）</h3><p>硬件抽象层（HAL）提供标准界面，向更高级别的Java API框架显示设备硬件功能。HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当框架API要求访问设备硬件时，Android系统将为该硬件组件加载库模块。</p><h3 id="34-6-Linux-内核"><a href="#34-6-Linux-内核" class="headerlink" title="34.6. Linux 内核"></a>34.6. Linux 内核</h3><p>Android平台的基础是Linux内核。例如，Android Runtime（ART）依靠Linux内核来执行底层功能，例如线程和低层内存管理。</p><p>使用Linux内核可让Android利用主要安全功能，并且允许设备制造商为著名的内核开发硬件驱动程序。</p><h2 id="35-Fragment生命周期"><a href="#35-Fragment生命周期" class="headerlink" title="35. Fragment生命周期"></a>35. Fragment生命周期</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/fragment_lifecycle.png" alt="fragment lifecycle"></p><ul><li><code>onCreate()</code>：系统会在创建片段时调用此方法。您应该在实现内初始化您想在片段暂停或停止后恢复时保留的必需片段组件。</li><li><code>onCreateView()</code>：系统会在片段首次绘制其用户界面时调用此方法。要想为您的片段绘制UI，您从此方法中返回的View必须是片段布局的根视图。如果片段未提供UI，您可以返回<code>null</code>。</li><li><code>onPause()</code>：系统将此方法作为用户离开片段的第一个信号（但并不总是意味着此片段会被销毁）进行调用。您通常应该在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。</li></ul><h2 id="36-Activity生命周期对片段生命周期的影响"><a href="#36-Activity生命周期对片段生命周期的影响" class="headerlink" title="36. Activity生命周期对片段生命周期的影响"></a>36. Activity生命周期对片段生命周期的影响</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/activity_fragment_lifecycle.png" alt="activity fragment lifecycle"></p><p>片段所在的Activity的生命周期会直接影响片段的生命周期，其表现为，Activity的每次生命周期回调都会引发每个片段的类似回调。例如，当Activity收到<code>onPause()</code>时，Activity中的每个片段也会收到<code>onPause()</code>。</p><p>不过，片段还有几个额外的生命周期回调，用于处理与Activity的唯一交互，以执行构建和销毁片段UI等操作。这些额外的回调方法是：</p><ul><li><code>onAttach()</code>：在片段已与Activity关联时调用（Activity传递到此方法内）；</li><li><code>onCreateView()</code>：调用它可创建与片段关联的视图层次结构；</li><li><code>onActivityCreated()</code>：在Activity的<code>onCreate()</code>方法已返回时调用；</li><li><code>onDestroyView()</code>：在移除与片段关联的视图层次结构时调用；</li><li><code>onDetach()</code>：在取消片段与Activity的关联时调用。</li></ul><h2 id="37-Android事件分发"><a href="#37-Android事件分发" class="headerlink" title="37. Android事件分发"></a>37. Android事件分发</h2><table><thead><tr><th style="text-align:center">事件相关方法</th><th style="text-align:center">方法功能</th><th style="text-align:center">Activity</th><th style="text-align:center">ViewGroup</th><th style="text-align:center">View</th></tr></thead><tbody><tr><td style="text-align:center"><code>dispatchTouchEvent</code></td><td style="text-align:center">事件分发</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:center"><code>onInterceptTouchEvent</code></td><td style="text-align:center">事件拦截</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center"><code>onTouchEvent</code></td><td style="text-align:center">事件消费</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr></tbody></table><h3 id="37-1-public-boolean-dispatchTouchEvent-MotionEvent-ev"><a href="#37-1-public-boolean-dispatchTouchEvent-MotionEvent-ev" class="headerlink" title="37.1. public boolean dispatchTouchEvent(MotionEvent ev)"></a>37.1. <code>public boolean dispatchTouchEvent(MotionEvent ev)</code></h3><p>当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的<code>dispatchTouchEvent(MotionEvent ev)</code>方法，该方法对事件进行分发。</p><ul><li><code>return true</code>：表示该View内部消化掉了所有事件。</li><li><code>return false</code>：事件在本层不再继续进行分发，并交由上层控件的<code>onTouchEvent()</code>方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。</li><li>如果事件分发返回系统默认的<code>super.dispatchTouchEvent(ev)</code>，事件将分发给本层的事件拦截<code>onInterceptTouchEvent()</code>方法进行处理。</li></ul><h3 id="37-2-public-boolean-onInterceptTouchEvent-MotionEvent-ev"><a href="#37-2-public-boolean-onInterceptTouchEvent-MotionEvent-ev" class="headerlink" title="37.2. public boolean onInterceptTouchEvent(MotionEvent ev)"></a>37.2. <code>public boolean onInterceptTouchEvent(MotionEvent ev)</code></h3><ul><li><code>return true</code>：表示将事件进行拦截，并将拦截到的事件交由本层控件的<code>onTouchEvent()</code>进行处理。</li><li><code>return false</code>：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的<code>dispatchTouchEvent()</code>进行处理。</li><li>如果返回<code>super.onInterceptTouchEvent(ev)</code>，默认表示拦截该事件，并将事件传递给当前View的<code>onTouchEvent()</code>方法，和<code>return true</code>一样。</li></ul><h3 id="37-3-public-boolean-onTouchEvent-MotionEvent-ev"><a href="#37-3-public-boolean-onTouchEvent-MotionEvent-ev" class="headerlink" title="37.3. public boolean onTouchEvent(MotionEvent ev)"></a>37.3. <code>public boolean onTouchEvent(MotionEvent ev)</code></h3><p>在<code>dispatchTouchEvent()</code>（事件分发）返回<code>super.dispatchTouchEvent(ev)</code>并且<code>onInterceptTouchEvent()</code>（事件拦截返回<code>true</code>或<code>super.onInterceptTouchEvent(ev)</code>的情况下，那么事件会传递到<code>onTouchEvent()</code>方法，该方法对事件进行响应。</p><ul><li>如果<code>return true</code>，表示<code>onTouchEvent()</code>处理完事件后消费了此次事件。此时事件终结。</li><li>如果<code>return fasle</code>，则表示不响应事件，那么该事件将会不断向上层View的<code>onTouchEvent()</code>方法传递，直到某个View的<code>onTouchEvent()</code>方法返回<code>true</code>，如果到了最顶层View还是返回<code>false</code>，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的<code>onTouchEvent()</code>进行处理。</li><li>如果<code>return super.dispatchTouchEvent(ev)</code>，则表示不响应事件，结果与<code>return false</code>一样。</li></ul><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/touch_eventbus.gif" alt="touch eventbus"></p><ul><li>如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的<code>onTouchEvent()</code>不会被触发。</li><li>可以通过复写<code>onInterceptTouchEvent(ev)</code>方法，拦截子View的事件（即<code>return true</code>），把事件交给自己处理，则会执行自己对应的<code>onTouchEvent()</code>方法。</li><li>子View可以通过调用<code>getParent().requestDisallowInterceptTouchEvent(true)</code>阻止ViewGroup对其<code>MOVE</code>或者<code>UP</code>事件进行拦截。</li><li>一个点击事件产生后，它的传递过程如下：Activity-&gt;Window-&gt;View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的<code>onTouchEvent()</code>方法返回<code>false</code>，那么将会交给父容器的<code>onTouchEvent()</code>方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的<code>onTouchEvent()</code>进行处理。</li><li>如果某一个View开始处理事件，如果他不消耗<code>ACTION_DOWN</code>事件（也就是<code>onTouchEvent()</code>返回<code>false</code>），则同一事件序列比如接下来进行<code>ACTION_MOVE</code>，则不会再交给该View处理。</li><li>ViewGroup默认不拦截任何事件。</li><li>诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用<code>onTouchEvent()</code>方法，它们本身没有<code>onInterceptTouchEvent()</code>方法。正常情况下，它们都会消耗事件（返回<code>true</code>），除非它们是不可点击的（<code>clickable</code>和<code>longClickable</code>都为<code>false</code>），那么就会交由父容器的<code>onTouchEvent()</code>处理。</li><li>点击事件分发过程如下<code>dispatchTouchEvent()</code> —&gt; <code>OnTouchListener</code>的<code>onTouch()</code>方法 —&gt; <code>onTouchEvent()</code> –&gt; <code>OnClickListener</code>的<code>onClick()</code>方法。也就是说，我们平时调用的<code>setOnClickListener()</code>，优先级是最低的，所以，<code>onTouchEvent()</code>或<code>OnTouchListener()</code>的<code>onTouch()</code>方法如果返回<code>true</code>，则不响应<code>onClick()</code>方法。</li></ul><p>参考：<a href="https://github.com/Mr-YangCheng/ForAndroidInterview/blob/master/android/Android%20View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">ForAndroidInterview/Android View事件分发机制源码分析.md at master · Mr-YangCheng/ForAndroidInterview</a></p><p>参考：<a href="https://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html" target="_blank" rel="noopener">Android 编程下 Touch 事件的分发和消费机制 - sunzn - 博客园</a></p><h2 id="38-Android系统启动过程"><a href="#38-Android系统启动过程" class="headerlink" title="38. Android系统启动过程"></a>38. Android系统启动过程</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/android_boot_process.png" alt="android boot process"></p><h3 id="38-1-Boot-ROM"><a href="#38-1-Boot-ROM" class="headerlink" title="38.1. Boot ROM"></a>38.1. Boot ROM</h3><p>Android设备上电后，首先会从处理器片上ROM的启动引导代码开始执行，片上ROM会寻找Bootloader代码，并加载到内存。</p><h3 id="38-2-Boot-Loader"><a href="#38-2-Boot-Loader" class="headerlink" title="38.2. Boot Loader"></a>38.2. Boot Loader</h3><p>BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。</p><h3 id="38-3-Kernel"><a href="#38-3-Kernel" class="headerlink" title="38.3. Kernel"></a>38.3. Kernel</h3><p>Android内核启动时，会设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。</p><h3 id="38-4-init"><a href="#38-4-init" class="headerlink" title="38.4. init"></a>38.4. init</h3><p>init进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。init始终是第一个进程。</p><p>init程序最核心的工作主要有3点：</p><ul><li>创建和挂载一些系统目录/设备节点，设置权限，如：<code>/dev</code>，<code>/proc</code>，和<code>/sys</code>；</li><li>解析init.rc，并启动属性服务，以及一系列的服务和进程；</li><li>显示boot logo，默认是”Android”字样。</li></ul><p>第二步的这些服务包含2部分，一部分是本地服务，另一部分是Android服务，所有的这些服务都会向ServiceManager进程注册，由它统一管理，这些服务的启动过程介绍如下：</p><h4 id="38-4-1-本地服务"><a href="#38-4-1-本地服务" class="headerlink" title="38.4.1. 本地服务"></a>38.4.1. 本地服务</h4><p>本地服务是指运行在C++层的系统守护进程，一部分本地服务是init进程直接启动的，它们定义在init.rc脚本中，如ueventd、servicemanager、debuggerd、rild、mediaserver等。还有一部分本地服务，是由这些本地服务进一步创建的，如mediaserver服务会启动AudioFlinger，MediaPlayerService，以及CameraService等本地服务。</p><p>注意，每一个由init直接启动的本地服务都是一个独立的Linux进程，在系统启动以后，我们通过<code>adb shell</code>命令进入手机后，输入<code>top</code>命令就可以查看到这些本地进程的存在。</p><h4 id="38-4-2-Android服务"><a href="#38-4-2-Android服务" class="headerlink" title="38.4.2. Android服务"></a>38.4.2. Android服务</h4><p>init进程会执行app_process程序，创建Zygote进程，它是Android系统最重要的进程，所有后续的Android应用程序都是由它<code>fork</code>出来的。</p><p>Zygote进程会首先<code>fork</code>出SystemServer进程，SystemServer进程的全部任务就是将所有的Android核心服务启动起来。</p><h3 id="38-5-Zygote-and-Dalvik（ART）"><a href="#38-5-Zygote-and-Dalvik（ART）" class="headerlink" title="38.5. Zygote and Dalvik（ART）"></a>38.5. Zygote and Dalvik（ART）</h3><p>Zygote被init进程启动，开始运行和初始化dalvik虚拟机。</p><h3 id="38-6-System-Server"><a href="#38-6-System-Server" class="headerlink" title="38.6. System Server"></a>38.6. System Server</h3><p>系统服务是在系统中运行的第一个java组件，它会启动所有的Android服务，比如：电话服务，蓝牙服务，每个服务的启动被直接写在<code>SystemServer.java</code>这个类的<code>run()</code>方法里面。</p><h3 id="38-7-Boot-completed"><a href="#38-7-Boot-completed" class="headerlink" title="38.7. Boot completed"></a>38.7. Boot completed</h3><p>一旦系统服务启动并运行，Android系统启动就完成了，同时发出<code>ACTION_BOOT_COMPLETED</code>广播。</p><h2 id="39-Android应用启动过程"><a href="#39-Android应用启动过程" class="headerlink" title="39. Android应用启动过程"></a>39. Android应用启动过程</h2><ol><li>Launcher接收到点击事件，获取应用的信息，向SystemServer（ActivityManagerService简称AMS运行在里面）发起启动应用的请求；</li><li>SystemServer（AMS）请求Launcher Pause（Launcher需要保存状态进入后台）；</li><li>LauncherPause，向SystemServer（AMS）发送Pause完毕；</li><li>SystemServer（AMS）向Zygote请求启动一个新进程（calculator）；</li><li>Zygote fork出新进程（calculator），在新进程中执行ActivityThread类的<code>main()</code>方法；</li><li>calculator向SystemServer（AMS）请求attach到AMS；</li><li>SystemServer（AMS）请求calculator launch；</li><li>calculator调用<code>onCreate()</code>，<code>onResume()</code>回调；</li><li>calculator界面显示自屏幕上（还需细分）。</li></ol><p>参考：<a href="http://androidzhibinw.github.io/android/app/startup/activity/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/%E5%90%AF%E5%8A%A8/%E5%88%86%E6%9E%90/2015/09/21/android-app-startup-process/" target="_blank" rel="noopener">Android 应用程序启动过程分析</a></p><h2 id="40-dp，dip，dpi，ppi区别"><a href="#40-dp，dip，dpi，ppi区别" class="headerlink" title="40. dp，dip，dpi，ppi区别"></a>40. dp，dip，dpi，ppi区别</h2><p>px（Pixels，像素）：屏幕上的点。 in（Inch，英寸）：长度单位。 mm（Millimeter，毫米）：长度单位。 pt（Point，磅）：1/72in。 dpi（Dots Per Inch，每英寸所打印的点数）：1in长度的点数。 ppi（Pixels Per Inch，像素密度）：1in长度的像素点数。 dp/dip（Density-independent Pixels，与密度无关的像素）：一种基于屏幕密度的抽象单位。在160dpi的显示器上，1dp = 1px。 sp（Scale-independent Pixels，与刻度无关的像素）：与dp类似，但是可以根据用户的字体大小首选项进行缩放。</p><p>在屏幕密度为160dpi，1dp = 1px，1pt = 160/72sp，1pt = 1/72in。当屏幕密度为240dpi时，1dp = 1.5px。</p><p>参考：<a href="http://stackoverflow.com/questions/8478882/how-do-dp-dip-dpi-ppi-pixels-and-inches-relate" target="_blank" rel="noopener">mobile - How do dp, dip, dpi, ppi, pixels and inches relate? - Stack Overflow</a></p><h2 id="41-长度和字体的推荐单位"><a href="#41-长度和字体的推荐单位" class="headerlink" title="41. 长度和字体的推荐单位"></a>41. 长度和字体的推荐单位</h2><p>长度推荐dp（Density-independent Pixels），字号大小推荐sp（Scale-independent Pixels）。</p><h2 id="42-Android-View绘制流程"><a href="#42-Android-View绘制流程" class="headerlink" title="42. Android View绘制流程"></a>42. Android View绘制流程</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/android_draw_view_flow.png" alt="android_draw_view_flow"></p><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/android_draw_view_chain.png" alt="android_draw_view_chain"></p><p>参考：<a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tech/viewdrawflow" target="_blank" rel="noopener">android-open-project-analysis/tech/viewdrawflow at master · android-cn/android-open-project-analysis</a></p><p>参考：<a href="http://vincgao.com/2016/02/android-layout/" target="_blank" rel="noopener">Android Layout绘制</a></p><h2 id="43-ListView优化"><a href="#43-ListView优化" class="headerlink" title="43. ListView优化"></a>43. ListView优化</h2><ul><li>复用convertView：用以避免重复创建View，重复创建View代价较大，而且如果重用view不改变宽高，重用View可以减少重新分配缓存造成的内存频繁分配/回收。</li><li>使用View Holder模式：findViewById的实现是遍历，如果你定义的View越复杂代价越大。 Google推荐的做法是用ViewHolder，然后保存在view的tag中。现在RecyclerView也是强制使用ViewHolder了。</li><li>分批加载与分页加载相结合：不需要一次等待好几分钟把数据都加载完再在ListView上显示。</li><li>使用异步线程加载图片</li><li>在快速滑动时不要加载图片</li><li>使用RecyclerView</li></ul><h2 id="44-Android-Binder机制"><a href="#44-Android-Binder机制" class="headerlink" title="44. Android Binder机制"></a>44. Android Binder机制</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/binder_architecture.jpg" alt="binder architecture"></p><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/binder_architecture_2.jpg" alt="binder architecture 2"></p><ol><li>Server进程启动之后，会进入中断等待状态，等待Client的请求。</li><li>当Client需要和Server通信时，会将请求发送给Binder驱动。</li><li>Binder驱动收到请求之后，会唤醒Server进程。</li><li>接着，Binder驱动还会反馈信息给Client，告诉Client：它发送给Binder驱动的请求，Binder驱动已经收到。</li><li>Client将请求发送成功之后，就进入等待状态。等待Server的回复。</li><li>Binder驱动唤醒Server之后，就将请求转发给Server进程。</li><li>Server进程解析出请求内容，并将回复内容发送给Binder驱动。</li><li>Binder驱动收到回复之后，唤醒Client进程。</li><li>接着，Binder驱动还会反馈信息给Server，告诉Server：它发送给Binder驱动的回复，Binder驱动已经收到。</li><li>Server将回复发送成功之后，再次进入等待状态，等待Client的请求。</li><li>最后，Binder驱动将回复转发给Client。</li></ol><h2 id="45-Binder机制优点"><a href="#45-Binder机制优点" class="headerlink" title="45. Binder机制优点"></a>45. Binder机制优点</h2><ul><li>性能：Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。</li><li>稳定性：Binder是基于C/S架构的，Server端与Client端相对独立，稳定性较好。</li><li>安全性：传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份。Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行。</li></ul><h2 id="46-AsyncTask简介"><a href="#46-AsyncTask简介" class="headerlink" title="46. AsyncTask简介"></a>46. AsyncTask简介</h2><p>包含4个方法：</p><ul><li><code>onPreExecute()</code>：UI线程；</li><li><code>doInBackground(Params...)</code>：非UI线程；</li><li><code>onProgressUpdate(Progress...)</code>：UI线程；</li><li><code>onPostExecute(Result)</code>：UI线程。</li></ul><p>原理：</p><ul><li>线程池；</li><li>单例模式；</li><li><code>mainLooper()</code>；</li><li>串行。</li></ul><h2 id="47-为什么Handler需要声明为static？"><a href="#47-为什么Handler需要声明为static？" class="headerlink" title="47. 为什么Handler需要声明为static？"></a>47. 为什么Handler需要声明为static？</h2><p>所有发送到消息队列的消息Message都会拥有一个对Handler的引用，在java里，非静态内部类和匿名类都会潜在的引用它们所属的外部类。但是，静态内部类却不会。当Activity结束（finish）时，里面的延时消息在得到处理前，会一直保存在主线程的消息队列里持续10分钟。这条消息持有对handler的引用，而handler又持有对其外部类（在这里，即SampleActivity）的潜在引用。这条引用关系会一直保持直到消息得到处理，从而，这阻止了SampleActivity被垃圾回收器回收，同时造成应用程序的泄漏。</p><h2 id="48-广播注册后不解除注册会有什么问题？"><a href="#48-广播注册后不解除注册会有什么问题？" class="headerlink" title="48. 广播注册后不解除注册会有什么问题？"></a>48. 广播注册后不解除注册会有什么问题？</h2><p>内存泄漏。系统会保留Receiver的引用。</p><h2 id="49-自定义View"><a href="#49-自定义View" class="headerlink" title="49. 自定义View"></a>49. 自定义View</h2><h3 id="49-1-实现步骤"><a href="#49-1-实现步骤" class="headerlink" title="49.1. 实现步骤"></a>49.1. 实现步骤</h3><ol><li>继承View类或其子类；</li><li>复写view中的一些函数；</li><li>为自定义View类增加属性（两种方式）；</li><li>绘制控件（导入布局）；</li><li>响应用户事件；</li><li>定义回调函数（根据自己需求来选择）。</li></ol><h2 id="50-需要被重写的方法"><a href="#50-需要被重写的方法" class="headerlink" title="50. 需要被重写的方法"></a>50. 需要被重写的方法</h2><ul><li><code>onDraw()</code>：view中<code>onDraw()</code>是个空函数，也就是说具体的视图都要覆写该函数来实现自己的绘制。对于ViewGroup则不需要实现该函数，因为作为容器是”没有内容”的（但必须实现<code>dispatchDraw()</code>函数，告诉子view绘制自己）。</li><li><code>onLayout()</code>：主要是为viewGroup类型布局子视图用的，在View中这个函数为空函数。</li><li><code>onMeasure()</code>：用于计算视图大小（即长和宽）的方式，并通过<code>setMeasuredDimension(width, height)</code>保存计算结果。</li><li><code>onTouchEvent()</code>：定义触屏事件来响应用户操作。</li></ul><h2 id="51-Parcelable和Serializable的区别"><a href="#51-Parcelable和Serializable的区别" class="headerlink" title="51. Parcelable和Serializable的区别"></a>51. Parcelable和Serializable的区别</h2><p>Serializable仅需实现Serializable接口。缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。</p><p>Parcelable需要实现Parcelable接口，但序列化的过程已经提前确定，所以运行速度快。</p><h2 id="52-Android中的内存泄漏"><a href="#52-Android中的内存泄漏" class="headerlink" title="52. Android中的内存泄漏"></a>52. Android中的内存泄漏</h2><ol><li>查询数据库没有关闭游标。</li><li>构造Adapter时，没有使用缓存的convertView。</li><li>Bitmap对象不再使用时调用<code>recycle()</code>释放内存。</li><li>无用时没有释放对象的引用。</li><li>在Activity中使用非静态的内部类，并开启一个长时间运行的线程，因为内部类持有Activity的引用，会导致Activity本来可以被GC时却长期得不到回收。</li><li>使用Handler处理消息前，Activity通过例如<code>finish()</code>退出，导致内存泄漏。</li><li>动态注册广播在Activity销毁前没有<code>unregisterReceiver()</code>。</li></ol><h2 id="53-MVC和MVP的区别"><a href="#53-MVC和MVP的区别" class="headerlink" title="53. MVC和MVP的区别"></a>53. MVC和MVP的区别</h2><p>我们都知道MVP是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter（MVC中的Controller）来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过Controller。</p><h2 id="54-内存泄露检测有什么好方法？"><a href="#54-内存泄露检测有什么好方法？" class="headerlink" title="54. 内存泄露检测有什么好方法？"></a>54. 内存泄露检测有什么好方法？</h2><ol><li>DDMS Heap发现内存泄露dataObject totalSize的大小，是否稳定在一个范围内，如果操作程序，不断增加，说明内存泄露。</li><li>使用Heap Tool进行内存快照前后对比BlankActivity手动触发GC进行前后对比，对象是否被及时回收。</li></ol><h2 id="55-Android里面为什么要设计出Bundle而不是直接用Map结构"><a href="#55-Android里面为什么要设计出Bundle而不是直接用Map结构" class="headerlink" title="55. Android里面为什么要设计出Bundle而不是直接用Map结构"></a>55. Android里面为什么要设计出Bundle而不是直接用Map结构</h2><p>Map里实现了Serializable接口，而在Bundle实现了Parcelable的接口。</p><h2 id="56-在Android的MVP架构中，使用了什么设计模式"><a href="#56-在Android的MVP架构中，使用了什么设计模式" class="headerlink" title="56. 在Android的MVP架构中，使用了什么设计模式"></a>56. 在Android的MVP架构中，使用了什么设计模式</h2><ul><li>Observer模式：通过EventBus实现订阅者，发布者的功能，实现Model与Presenter的交互。</li><li>Proxy模式：View保持对Presenter的引用，通过Presenter代理，进行交互操作。</li></ul><h2 id="57-Android动画类型"><a href="#57-Android动画类型" class="headerlink" title="57. Android动画类型"></a>57. Android动画类型</h2><ul><li>属性动画（Property Animation）：是Android 3.0之后推出的，其机制不再是针对 View 来设计的，也不限于只能实现移动、缩放、旋转和淡入这几种简单的动画操作，同时也不再只是一种视觉上的动画效果。属性动画实际上是一种在一定时间段内不断修改某个对象的某个属性值的机制。</li><li><p>视图动画（View Animation）：</p><ul><li><p>补间动画（Tween animation）：是操作某一个控件让其展现出旋转、渐变、移动、缩放的一种转换过程。是一种视觉上的变化，不是真正位置上的变化。只能运用在 View 对象上，并且功能相对来说较为局限。例如：旋转动画只能够在x、y轴进行，而不能在z轴放心进行旋转。因此，补间动画通常用于执行一些比较简单的动画。</p><ul><li>渐变动画（AlphaAnimation）；</li><li>缩放动画（ScaleAnimation）；</li><li>位移动画（TranslateAnimation）；</li><li>旋转动画（RotateAnimation）。</li></ul></li><li><p>帧动画（Frame animation）：帧动画是一系列图片按照一定的顺序展示的过程，和放电影的机制相似，它的原理是在一定的时间段内切换多张有细微差异的图片从而达到动画的效果。由于是一帧一帧加载，所以需要较多的图片。从而增大 APK 的大小，不过 Frame 动画可以实现一些比较难的效果，例如：等待的环形进度。</p></li></ul></li></ul><h2 id="58-ANR和FC的区别"><a href="#58-ANR和FC的区别" class="headerlink" title="58. ANR和FC的区别"></a>58. ANR和FC的区别</h2><ul><li>ANR（Application Not Responding）：主线程阻塞。</li><li>FC（Forced Close）：内存耗尽，堆栈溢出，运行时错误等。</li></ul><h2 id="59-Android中的菜单"><a href="#59-Android中的菜单" class="headerlink" title="59. Android中的菜单"></a>59. Android中的菜单</h2><h3 id="59-1-选项菜单（Options-menu）"><a href="#59-1-选项菜单（Options-menu）" class="headerlink" title="59.1. 选项菜单（Options menu）"></a>59.1. 选项菜单（Options menu）</h3><p>在选项菜单中，您应当包括与当前Activity上下文相关的操作和其他选项，如”搜索”、”撰写电子邮件”和”设置”。</p><ul><li>要为Activity指定选项菜单，请重写<code>onCreateOptionsMenu()</code>。</li><li>此外，您还可以使用<code>add()</code>添加菜单项，并使用<code>findItem()</code>检索项目，以便使用MenuItem API修改其属性。</li><li>系统将在启动Activity时调用<code>onCreateOptionsMenu()</code>，以便向应用栏显示项目。</li><li>用户从选项菜单中选择项目时，系统将调用Activity的<code>onOptionsItemSelected()</code>方法。此方法将传递所选的MenuItem。您可以通过调用<code>getItemId()</code>方法来识别项目，该方法将返回菜单项的唯一ID。</li><li>系统调用<code>onCreateOptionsMenu()</code>后，将保留您填充的Menu实例。除非菜单由于某些原因而失效，否则不会再次调用<code>onCreateOptionsMenu()</code>。</li><li>如需根据在Activity生命周期中发生的事件修改选项菜单，则可通过<code>onPrepareOptionsMenu()</code>方法执行此操作。此方法向您传递Menu对象（因为该对象目前存在），以便您能够对其进行修改，如添加、移除或禁用项目。</li><li>当菜单项显示在应用栏中时，选项菜单被视为始终处于打开状态。 发生事件时，如果您要执行菜单更新，则必须调用<code>invalidateOptionsMenu()</code>来请求系统调用<code>onPrepareOptionsMenu()</code>。</li></ul><h3 id="59-2-上下文菜单（Contextual-Menus）"><a href="#59-2-上下文菜单（Contextual-Menus）" class="headerlink" title="59.2. 上下文菜单（Contextual Menus）"></a>59.2. 上下文菜单（Contextual Menus）</h3><h4 id="59-2-1-浮动上下文菜单（floating-context-menu）"><a href="#59-2-1-浮动上下文菜单（floating-context-menu）" class="headerlink" title="59.2.1. 浮动上下文菜单（floating context menu）"></a>59.2.1. 浮动上下文菜单（floating context menu）</h4><p>用户长按（按住）一个声明支持上下文菜单的视图时，菜单显示为菜单项的浮动列表（类似于对话框）。</p><ul><li>通过调用<code>registerForContextMenu()</code>，注册应与上下文菜单关联的View并将其传递给View。</li><li>在Activity或Fragment中实现<code>onCreateContextMenu()</code>方法。</li><li><p>实现<code>onContextItemSelected()</code>。</p><h4 id="上下文操作模式（contextual-action-mode）"><a href="#上下文操作模式（contextual-action-mode）" class="headerlink" title="上下文操作模式（contextual action mode）"></a>上下文操作模式（contextual action mode）</h4><p>上下文操作模式是 ActionMode 的一种系统实现，它将用户交互的重点转到执行上下文操作上。用户通过选择项目启用此模式时，屏幕顶部将出现一个”上下文操作栏”，显示用户可对当前所选项执行的操作。 启用此模式后，用户可以选择多个项目（若您允许）、取消选择项目以及继续在 Activity 内导航（在您允许的最大范围内）。</p></li><li><p>实现ActionMode.Callback接口。在其回调方法中，您既可以为上下文操作栏指定操作，又可以响应操作项目的点击事件，还可以处理操作模式的其他生命周期事件。</p></li><li><p>当需要显示操作栏时（例如，用户长按视图），请调用<code>startActionMode()</code>。</p></li></ul><h3 id="59-3-弹出菜单（Popup-Menu）"><a href="#59-3-弹出菜单（Popup-Menu）" class="headerlink" title="59.3. 弹出菜单（Popup Menu）"></a>59.3. 弹出菜单（Popup Menu）</h3><p>PopupMenu 是锚定到 View 的模态菜单。如果空间足够，它将显示在定位视图下方，否则显示在其上方。</p><ul><li>实例化PopupMenu及其构造函数，该函数将提取当前应用的Context以及菜单应锚定到的View。</li><li>使用MenuInflater将菜单资源扩充到<code>PopupMenu.getMenu()</code>返回的Menu对象中。</li><li>调用<code>PopupMenu.show()</code>。</li></ul><h2 id="60-BaseAdapter中需要重载的方法"><a href="#60-BaseAdapter中需要重载的方法" class="headerlink" title="60. BaseAdapter中需要重载的方法"></a>60. BaseAdapter中需要重载的方法</h2><p>最基本的：</p><ul><li><code>int getCount ()</code>：How many items are in the data set represented by this Adapter.</li><li><code>Object getItem (int position)</code>：Get the data item associated with the specified position in the data set.</li><li><code>long getItemId (int position)</code>：Get the row id associated with the specified position in the list.</li><li><code>View getView (int position, View convertView, ViewGroup parent)</code>：Get a View that displays the data at the specified position in the data set.</li></ul><p>如果有多种View：</p><ul><li><code>int getItemViewType (int position)</code>：Get the type of View that will be created by getView(int, View, ViewGroup) for the specified item.</li><li><code>int getViewTypeCount ()</code>：Returns the number of types of Views that will be created by getView(int, View, ViewGroup).</li></ul><h2 id="61-Android数字签名要点"><a href="#61-Android数字签名要点" class="headerlink" title="61. Android数字签名要点"></a>61. Android数字签名要点</h2><ul><li>所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序。</li><li>Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证。</li><li>如果要正式发布一个Android应用，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使调试证书来发布。</li><li>数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。</li></ul><h2 id="62-使用相同数字签名的原因"><a href="#62-使用相同数字签名的原因" class="headerlink" title="62. 使用相同数字签名的原因"></a>62. 使用相同数字签名的原因</h2><ul><li>应用升级：当系统安装应用的更新时，它会比较新版本和现有版本中的证书。如果证书匹配，则系统允许更新。如果您使用不同的证书签署新版本，则必须为应用分配另一个软件包名称—-在此情况下，用户将新版本作为全新应用安装。</li><li>应用模块化：Android允许通过相同证书签署的多个APK在同一个进程中运行（如果应用请求这样），以便系统将它们视为单个应用。通过此方式，您可以在模块中部署您的应用，且用户可以独立更新每个模块。</li><li>通过权限共享代码/数据：Android提供基于签名的权限执行，以便应用可以将功能展示给使用指定证书签署的另一应用。通过使用同一个证书签署多个APK并使用基于签名的权限检查功能，您的应用可采用安全的方式共享代码和数据。</li></ul><h2 id="63-Theme和Sytle"><a href="#63-Theme和Sytle" class="headerlink" title="63. Theme和Sytle"></a>63. Theme和Sytle</h2><h3 id="63-1-Style"><a href="#63-1-Style" class="headerlink" title="63.1. Style"></a>63.1. Style</h3><p>样式是指为View或窗口指定外观和格式的属性集合。样式可以指定高度、填充、字体颜色、字号、背景色等许多属性。 样式是在与指定布局的XML不同的XML资源中进行定义。</p><ul><li>要创建一组样式，请在您的项目的<code>res/values/</code>目录中保存一个XML文件。</li><li>该XML文件的根节点必须是<code>&lt;resources&gt;</code>。</li><li>对于您想创建的每个样式，向该文件添加一个<code>&lt;style&gt;</code>元素，该元素带有对样式进行唯一标识的<code>name</code>属性（该属性为必需属性）。</li><li>然后为该样式的每个属性添加一个<code>&lt;item&gt;</code>元素，该元素带有声明样式属性以及属性值的<code>name</code>（该属性为必需属性）。</li><li>根据样式属性，<code>&lt;item&gt;</code>的值可以是关键字字符串、十六进制颜色值、对另一资源类型的引用或其他值。</li><li>您可以通过<code>&lt;style&gt;</code>元素中的<code>parent</code>属性指定应作为您的样式所继承属性来源的样式。</li><li>当您对布局中的单个View应用样式时，该样式定义的属性只应用于该View。如果对ViewGroup应用样式，子View元素将不会继承样式属性—-只有被您直接应用样式的元素才会应用其属性。</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CodeFont<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:style/TextAppearance.Medium<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">        &lt;item name=<span class="token string">"android:layout_width"</span>>fill_parent&lt;/item>        &lt;item name=<span class="token string">"android:layout_height"</span>>wrap_content&lt;/item>        &lt;item name=<span class="token string">"android:textColor"</span>><span class="token hexcode">#00FF00</span>&lt;/item>        &lt;item name=<span class="token string">"android:typeface"</span>>monospace&lt;/item>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span></code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span><span class="token style-attr language-css"><span class="token attr-name">    <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value">@style/CodeFont</span><span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/hello<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><h3 id="63-2-Theme"><a href="#63-2-Theme" class="headerlink" title="63.2. Theme"></a>63.2. Theme</h3><p>主题是指对整个Activity或应用而不是对单个View（如上例所示）应用的样式。以主题形式应用样式时，Activity或应用中的每个视图都将应用其支持的每个样式属性。例如，您可以Activity主题形式应用同一CodeFont样式，之后该Activity内的所有文本都将具有绿色固定宽度字体。</p><ul><li>在XML中定义您想用作Activity或应用主题的样式与定义视图样式的方法完全相同。</li><li>Activity或应用内的每个View都将应用其支持的每个属性。例如，如果您对某个Activity应用前面示例中的CodeFont样式，则所有支持这些文本样式属性的View元素也会应用这些属性。任何不支持这些属性的View都会忽略这些属性。如果某个View仅支持部分属性，将只应用这些属性。</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span> <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@style/CustomTheme<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span> <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:style/Theme.Dialog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h2 id="64-Toast的时长设置"><a href="#64-Toast的时长设置" class="headerlink" title="64. Toast的时长设置"></a>64. Toast的时长设置</h2><p>Toast的显示时长仅有两种：<code>LENGTH_SHORT</code>和<code>LENGTH_LONG</code>。</p><p><code>Toast makeText (Context context, CharSequence text, int duration)</code>：duration <code>int</code>: How long to display the message. Either <code>LENGTH_SHORT</code> or <code>LENGTH_LONG</code>。</p><h2 id="65-触发ANR的情况"><a href="#65-触发ANR的情况" class="headerlink" title="65. 触发ANR的情况"></a>65. 触发ANR的情况</h2><ul><li>KeyDispatchTimeout(5 seconds)：按键或触摸事件在特定时间内无响应；</li><li>BroadcastTimeout(10 seconds)：BroadcastReceiver在特定时间内无法处理完成；</li><li>ServiceTimeout(20 seconds)：Service在特定的时间内无法处理完成</li></ul><h2 id="66-ServiceConnection的onServiceConnected-触发条件"><a href="#66-ServiceConnection的onServiceConnected-触发条件" class="headerlink" title="66. ServiceConnection的onServiceConnected()触发条件"></a>66. ServiceConnection的<code>onServiceConnected()</code>触发条件</h2><ul><li><code>bindService()</code>方法执行成功；</li><li><code>onBind()</code>方法返回非空IBinder对象。</li></ul><h2 id="67-Android虚拟设备不支持的功能"><a href="#67-Android虚拟设备不支持的功能" class="headerlink" title="67. Android虚拟设备不支持的功能"></a>67. Android虚拟设备不支持的功能</h2><ul><li>WLAN</li><li>蓝牙</li><li>NFC</li><li>SD 卡插入/弹出</li><li>连接到设备的耳机</li><li>USB</li></ul><h2 id="68-RemoteView的应用"><a href="#68-RemoteView的应用" class="headerlink" title="68. RemoteView的应用"></a>68. RemoteView的应用</h2><ul><li>AppWidget</li><li>Notification</li></ul><h2 id="69-Android对HashMap做了优化后推出的新的容器类是什么？"><a href="#69-Android对HashMap做了优化后推出的新的容器类是什么？" class="headerlink" title="69. Android对HashMap做了优化后推出的新的容器类是什么？"></a>69. Android对HashMap做了优化后推出的新的容器类是什么？</h2><h3 id="69-1-SparseArray"><a href="#69-1-SparseArray" class="headerlink" title="69.1. SparseArray"></a>69.1. SparseArray</h3><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间。</p><h3 id="69-2-ArrayMap"><a href="#69-2-ArrayMap" class="headerlink" title="69.2. ArrayMap"></a>69.2. ArrayMap</h3><p>ArrayMap是一个&lt;key,value&gt;映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作。</p><h2 id="70-Android安全沙盒"><a href="#70-Android安全沙盒" class="headerlink" title="70. Android安全沙盒"></a>70. Android安全沙盒</h2><ul><li>Android操作系统是一种多用户Linux系统，其中的每个应用都是一个不同的用户；</li><li>默认情况下，系统会为每个应用分配一个唯一的Linux用户ID（该ID仅由系统使用，应用并不知晓）。系统为应用中的所有文件设置权限，使得只有分配给该应用的用户ID才能访问这些文件；</li><li>每个进程都具有自己的虚拟机 (VM)，因此应用代码是在与其他应用隔离的环境中运行；</li><li>默认情况下，每个应用都在其自己的Linux进程内运行。Android会在需要执行任何应用组件时启动该进程，然后在不再需要该进程或系统必须为其他应用恢复内存时关闭该进程。</li></ul><h2 id="71-onStartCommand-有哪些返回值"><a href="#71-onStartCommand-有哪些返回值" class="headerlink" title="71. onStartCommand()有哪些返回值"></a>71. <code>onStartCommand()</code>有哪些返回值</h2><p><code>onStartCommand()</code>的返回值用于描述系统应该如何在服务终止的情况下继续运行服务。其值可以为</p><ul><li><code>START_NOT_STICKY</code>：如果系统在<code>onStartCommand()</code>返回后终止服务，则除非有挂起Intent要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</li><li><code>START_STICKY</code>：如果系统在<code>onStartCommand()</code>返回后终止服务，则会重建服务并调用<code>onStartCommand()</code>，但不会重新传递最后一个Intent。相反，除非有挂起Intent要启动服务（在这种情况下，将传递这些Intent），否则系统会通过空Intent调用<code>onStartCommand()</code>。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</li><li><code>START_REDELIVER_INTENT</code>：如果系统在<code>onStartCommand()</code>返回后终止服务，则会重建服务，并通过传递给服务的最后一个Intent调用<code>onStartCommand()</code>。任何挂起Intent均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</li></ul><h2 id="72-如何创建绑定服务"><a href="#72-如何创建绑定服务" class="headerlink" title="72. 如何创建绑定服务"></a>72. 如何创建绑定服务</h2><p>建提供绑定的服务时，您必须提供IBinder，用以提供客户端用来与服务进行交互的编程接口。</p><h3 id="72-1-扩展Binder类"><a href="#72-1-扩展Binder类" class="headerlink" title="72.1. 扩展Binder类"></a>72.1. 扩展Binder类</h3><p>如果服务是供您的自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展Binder类并从<code>onBind()</code>返回它的一个实例来创建接口。客户端收到Binder后，可利用它直接访问Binder实现中乃至Service中可用的公共方法。</p><ol><li>在您的服务中，创建一个可满足下列任一要求的Binder实例：</li></ol><ul><li>包含客户端可调用的公共方法</li><li>返回当前Service实例，其中包含客户端可调用的公共方法</li><li>或返回由服务承载的其他类的实例，其中包含客户端可调用的公共方法</li></ul><ol start="2"><li>从<code>onBind()</code>回调方法返回此Binder实例。</li><li>在客户端中，从<code>onServiceConnected()</code>回调方法接收Binder，并使用提供的方法调用绑定服务。</li></ol><h3 id="72-2-使用Messenger"><a href="#72-2-使用Messenger" class="headerlink" title="72.2. 使用Messenger"></a>72.2. 使用Messenger</h3><ol><li>服务实现一个Handler，由其接收来自客户端的每个调用的回调</li><li>Handler用于创建Messenger对象（对Handler的引用）</li><li>Messenger创建一个IBinder，服务通过<code>onBind()</code>使其返回客户端</li><li>客户端使用IBinder将Messenger（引用服务的Handler）实例化，然后使用后者将Message对象发送给服务</li><li>服务在其Handler中（具体地讲，是在<code>handleMessage()</code>方法中）接收每个 Message。</li></ol><p>这样，客户端并没有调用服务的“方法”。而客户端传递的“消息”（Message对象）是服务在其Handler中接收的。</p><h2 id="73-如何绑定到服务"><a href="#73-如何绑定到服务" class="headerlink" title="73. 如何绑定到服务"></a>73. 如何绑定到服务</h2><p>应用组件（客户端）可通过调用<code>bindService()</code>绑定到服务。Android系统随后调用服务的onBind()方法，该方法返回用于与服务交互的IBinder。</p><p>绑定是异步的。<code>bindService()</code>会立即返回，“不会”使IBinder返回客户端。要接收IBinder，客户端必须创建一个ServiceConnection实例，并将其传递给<code>bindService()</code>。ServiceConnection包括一个回调方法，系统通过调用它来传递IBinder。</p><ol><li><p>实现ServiceConnection。您的实现必须重写两个回调方法：<code>onServiceConnected()</code>：系统会调用该方法以传递服务的onBind()方法返回的IBinder。<code>onServiceDisconnected()</code>：Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统“不会”调用该方法。</p></li><li><p>调用<code>bindService()</code>，传递ServiceConnection实现。</p></li><li><p>当系统调用您的<code>onServiceConnected()</code>回调方法时，您可以使用接口定义的方法开始调用服务。</p></li><li><p>要断开与服务的连接，请调用<code>unbindService()</code>。如果应用在客户端仍绑定到服务时销毁客户端，则销毁会导致客户端取消绑定。更好的做法是在客户端与服务交互完成后立即取消绑定客户端。</p></li></ol><h2 id="74-Android支持的屏幕密度"><a href="#74-Android支持的屏幕密度" class="headerlink" title="74. Android支持的屏幕密度"></a>74. Android支持的屏幕密度</h2><ul><li>ldpi（低）：120dpi</li><li>mdpi（中）：160dpi</li><li>hdpi（高）：240dpi</li><li>xhdpi（超高）：320dpi</li><li>xxhdpi（超超高）：480dpi</li><li>xxxhdpi（超超超高）：640dpi</li></ul><h2 id="75-如何支持多种屏幕"><a href="#75-如何支持多种屏幕" class="headerlink" title="75. 如何支持多种屏幕"></a>75. 如何支持多种屏幕</h2><ul><li>在清单中显式声明您的应用支持哪些屏幕尺寸；</li><li>为不同屏幕尺寸提供不同的布局；</li><li>为不同屏幕密度提供不同的位图可绘制对象。</li></ul><h2 id="76-什么是资源ID"><a href="#76-什么是资源ID" class="headerlink" title="76. 什么是资源ID"></a>76. 什么是资源ID</h2><p>所有资源ID都在您项目的R类中定义，后者由aapt工具自动生成。</p><p>编译应用时，aapt会生成R类，其中包含您的res/目录中所有资源的资源ID。每个资源类型都有对应的R子类（例如，R.drawable对应于所有可绘制对象资源），而该类型的每个资源都有对应的静态整型数（例如，R.drawable.icon）。这个整型数就是可用来检索资源的资源ID。</p><p>资源ID始终由以下部分组成：</p><ul><li>资源类型：每个资源都被分到一个“类型”组中，例如string、drawable和layout。</li><li>资源名称：它是不包括扩展名的文件名；或是XML android:name属性中的值，如果资源是简单值的话（例如字符串）。</li></ul><h2 id="77-如何处理运行时变更"><a href="#77-如何处理运行时变更" class="headerlink" title="77. 如何处理运行时变更"></a>77. 如何处理运行时变更</h2><p>有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。发生这种变化时，Android会重启正在运行的Activity（先后调用<code>onDestroy()</code>和<code>onCreate()</code>）。</p><h3 id="77-1-在配置变更期间保留对象"><a href="#77-1-在配置变更期间保留对象" class="headerlink" title="77.1. 在配置变更期间保留对象"></a>77.1. 在配置变更期间保留对象</h3><p>如果Activity因配置变更而重启，则可通过保留Fragment来减轻重新初始化Activity的负担。此片段可能包含对您要保留的有状态对象的引用。</p><ol><li>扩展Fragment类并声明对有状态对象的引用。</li><li>在创建片段后调用<code>setRetainInstance(boolean)</code>。</li><li>将片段添加到Activity。</li><li>重启Activity后，使用FragmentManager检索片段。</li></ol><h3 id="77-2-自行处理配置变更"><a href="#77-2-自行处理配置变更" class="headerlink" title="77.2. 自行处理配置变更"></a>77.2. 自行处理配置变更</h3><p>要声明由Activity处理配置变更，请在清单文件中编辑相应的<code>&lt;activity&gt;</code>元素，以包含<code>android:configChanges</code>属性以及代表要处理的配置的值。<code>android:configChanges</code>属性的文档中列出了该属性的可能值（最常用的值包括”orientation”和”keyboardHidden”，分别用于避免因屏幕方向和可用键盘改变而导致重启）。</p><h2 id="78-AndroidManifest-xml包括哪些内容？"><a href="#78-AndroidManifest-xml包括哪些内容？" class="headerlink" title="78. AndroidManifest.xml包括哪些内容？"></a>78. AndroidManifest.xml包括哪些内容？</h2><ul><li>为应用的Java软件包命名。软件包名称充当应用的唯一标识符。</li><li>描述应用的各个组件，包括构成应用的Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理的Intent消息。这些声明向Android系统告知有关组件以及可以启动这些组件的条件的信息。</li><li>确定托管应用组件的进程。</li><li>声明应用必须具备哪些权限才能访问API中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限。</li><li>声明应用所需的最低Android API级别。</li><li>列出应用必须链接到的库。</li></ul><h2 id="79-用户界面如何构成？"><a href="#79-用户界面如何构成？" class="headerlink" title="79. 用户界面如何构成？"></a>79. 用户界面如何构成？</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/viewgroup.png" alt="View Group"></p><p>Android应用中的所有用户界面元素都是使用View和ViewGroup对象构建而成。View对象用于在屏幕上绘制可供用户交互的内容。ViewGroup对象用于储存其他View（和ViewGroup）对象，以便定义界面的布局。</p><p>每个应用组件的用户界面都是使用View和ViewGroup对象的层次结构定义的。每个视图组都是一个用于组织子视图的不可见容器，而子视图可以是输入控件或其他可绘制某一UI部分的小部件。 </p><h2 id="80-为什么要回收Bitmap的内存"><a href="#80-为什么要回收Bitmap的内存" class="headerlink" title="80. 为什么要回收Bitmap的内存"></a>80. 为什么要回收Bitmap的内存</h2><p>Bitmap的实例化只能通过BitmapFactory，而Bitmap对象的生成则是通过JNI调用，所以Bitmap包含Java和C两部分内存。Java部分内存可以通过虚拟机自动回收，但C部分则需要手动释放，所以需要显式调用<code>recycle()</code>方法来释放。</p><h2 id="81-如何优化Bitmap"><a href="#81-如何优化Bitmap" class="headerlink" title="81. 如何优化Bitmap"></a>81. 如何优化Bitmap</h2><ul><li>加载合适尺寸的图片；</li><li>及时回收Bitmap；</li><li>捕获OOM异常；</li><li>压缩图片；</li><li>使用合适的颜色模式。</li></ul><h2 id="82-如何在新进程中创建Activity／Service"><a href="#82-如何在新进程中创建Activity／Service" class="headerlink" title="82. 如何在新进程中创建Activity／Service"></a>82. 如何在新进程中创建Activity／Service</h2><p>在AndroidManifest中，组件元素条目（activity、service、receiver或provider）中设置<code>android:process</code>属性，此属性可以指定该组件应在哪个进程运行。</p><p>每新建一个进程，Application的<code>onCreate()</code>都将被调用一次。</p><h2 id="83-onActivityResult-什么时候会失效？"><a href="#83-onActivityResult-什么时候会失效？" class="headerlink" title="83. onActivityResult()什么时候会失效？"></a>83. <code>onActivityResult()</code>什么时候会失效？</h2><p>在<code>startActivity()</code>为SingleTask时会失效。</p><blockquote><p>For example, if the activity you are launching uses the singleTask launch mode, it will not run in your task and thus you will immediately receive a cancel result.</p></blockquote><p>如果你正加载的activity使用了singleTask的加载模式，它不会在你的栈中运行，而且这样你会马上收到一个取消的结果。即在<code>onActivityResult()</code>里马上得到一个RESULT_CANCEL。</p><h2 id="84-Android崩溃捕获"><a href="#84-Android崩溃捕获" class="headerlink" title="84. Android崩溃捕获"></a>84. Android崩溃捕获</h2><h3 id="84-1-Java崩溃捕获"><a href="#84-1-Java崩溃捕获" class="headerlink" title="84.1. Java崩溃捕获"></a>84.1. Java崩溃捕获</h3><p>Java提供有UncaughtExceptionHandler接口，该接口含有一个方法：<code>void uncaughtException(Thread t, Throwable e)</code>。</p><p>Uncaught异常发生时会终止线程，此时，系统便会通知UncaughtExceptionHandler，调用<code>uncaughtException()</code>函数。如果该handler没有被显式设置，则会调用对应线程组的默认handler。</p><p>如果要捕获该异常，必须实现UncaughtExceptionHandler，并通过<code>public static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)</code>进行设置。</p><h3 id="84-2-Native崩溃捕获"><a href="#84-2-Native崩溃捕获" class="headerlink" title="84.2. Native崩溃捕获"></a>84.2. Native崩溃捕获</h3><p>对Native代码的崩溃，可以通过调用<code>int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact))</code>注册信号处理函数来完成。</p><h2 id="85-Android-APP构建流程"><a href="#85-Android-APP构建流程" class="headerlink" title="85. Android APP构建流程"></a>85. Android APP构建流程</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/build_process.png" alt="Build Process"></p><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/build_process_2.png" alt="Build Process"></p><p>典型的Android APP构建流程：</p><ol><li>Java编译器对工程本身的java代码进行编译，这些java代码有三个来源：app的源代码，由资源文件生成的R文件（aapt工具），以及有aidl文件生成的java接口文件（aidl工具）。产出为.class文件。</li><li>class文件和依赖的三方库文件通过dex工具生成Delvik虚拟机可执行的.dex文件，可能有一个或多个，包含了所有的class信息，包括项目自身的class和依赖的class。产出为.dex文件。</li><li>apkbuilder工具将.dex文件和编译后的资源文件生成未经签名对齐的apk文件。这里编译后的资源文件包括两部分，一是由aapt编译产生的编译后的资源文件，二是依赖的三方库里的资源文件。产出为未经签名的.apk文件。</li><li>分别由Jarsigner和zipalign对apk文件进行签名和对齐，生成最终的apk文件。</li></ol><h2 id="86-class文件与-dex文件的区别"><a href="#86-class文件与-dex文件的区别" class="headerlink" title="86. class文件与.dex文件的区别"></a>86. class文件与.dex文件的区别</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/class_vs_dex.png" alt="class vs dex"></p><h2 id="87-65535问题"><a href="#87-65535问题" class="headerlink" title="87. 65535问题"></a>87. 65535问题</h2><h3 id="87-1-原因"><a href="#87-1-原因" class="headerlink" title="87.1. 原因"></a>87.1. 原因</h3><p>单个dex文件中，method个数采用使用原生类型short来索引，即2个字节最多65536个method，field、class的个数也均有此限制。</p><h3 id="87-2-解决方法"><a href="#87-2-解决方法" class="headerlink" title="87.2. 解决方法"></a>87.2. 解决方法</h3><p>build.gradle中配置<code>multiDexEnabled true</code>，将dex分包。</p><h2 id="88-Dalvik与JVM的区别"><a href="#88-Dalvik与JVM的区别" class="headerlink" title="88. Dalvik与JVM的区别"></a>88. Dalvik与JVM的区别</h2><ul><li>JVM可以执行的文件是.class结尾的字节码文件，而Dalvik执行的是dex文件（不符合JVM规范）。</li><li>Dalvik基于寄存器，而JVM基于栈。</li><li>Dalvik负责进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。</li></ul><p>除此之外：</p><ul><li>有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，它会完成虚拟机的初始化、库的加载、预制类库和初始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的速度提供给系统。</li></ul><h2 id="89-ART相对Dalvik的优化"><a href="#89-ART相对Dalvik的优化" class="headerlink" title="89. ART相对Dalvik的优化"></a>89. ART相对Dalvik的优化</h2><ul><li>AOT替换JIT：使用AOT直接在安装时用dex2oat将其完全翻译成native代码。</li><li>GC性能提升：并行GC。</li><li>提升内存效率：专门开辟内存存放large object，因为large object移动成本太大；引入moving collector技术，将不连续的物理内存块对齐，解决内存碎片化问题。</li></ul><p>参考：<a href="https://source.android.com/devices/tech/dalvik/" target="_blank" rel="noopener">ART and Dalvik | Android Open Source Project</a></p><h2 id="90-Android中的ClassLoader"><a href="#90-Android中的ClassLoader" class="headerlink" title="90. Android中的ClassLoader"></a>90. Android中的ClassLoader</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/classloader.png" alt="ClassLoader"></p><ul><li>在Android中，App安装到手机后，apk里面的class.dex中的class均是通过PathClassLoader来加载的。</li><li>DexClassLoader可以用来加载SD卡上加载包含class.dex的.jar和.apk文件。</li><li>DexClassLoader和PathClassLoader的基类BaseDexClassLoader查找class是通过其内部的<code>DexPathList pathList</code>来查找的。</li><li>DexPathList内部有一个<code>Element[] dexElements</code>数组，其<code>findClass()</code>方法的实现就是遍历该数组，查找class，一旦找到需要的类，就直接返回，停止遍历。</li></ul><h2 id="91-ClassLoader方式实现热修复"><a href="#91-ClassLoader方式实现热修复" class="headerlink" title="91. ClassLoader方式实现热修复"></a>91. ClassLoader方式实现热修复</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/classloader_hotpatch.jpg" alt="ClassLoader Hot Patch"></p><p>主要步骤：</p><ol><li>假设MainActivity中有一个方法<code>showMsg()</code>需要修复。</li><li>修复<code>showMsg()</code>方法，制作补丁包patch.jar，该patch.jar文件中就包含已经修复了的dex文件。</li><li>在Application的<code>onCreate()</code>方法中检测是否已经下载好补丁包，如果存在补丁包，就通过DexClassLoader加载patch.jar，然后通过反射拿到DexClassLoader中的 DexPathList对象，进而拿到<code>Element[] dexElements</code>数组，这里标记该Element数组为<code>newDexElements</code>。</li><li>还是通过反射，拿到App默认的ClassLoader即PathClassLoader的DexPathList对象，进而拿到Element数组，这里标记下该数组为<code>baseDexElements</code>。</li><li>将<code>newDexElements</code>和<code>baseDexElements</code>合成一个新的数组<code>allDexElements</code>，且保证<code>newDexElements</code>中的值在<code>allDexElements</code>数组的最前面。</li><li>然后还是通过通过反射，将合成的Element数组设置给PathClassLoader的DexPathList对象。</li><li>在Application完成初始化之后，会开始加载MainActivity，加载过程就是通过DexPathList对象的<code>findClass()</code>方法来完成的，会从头开始遍历其Element数组，会优先查找到之前插入的补丁包中的dexFile，而原apk中的则不会查找到，因此就实现了热修复的目的。</li></ol><p>参考：<a href="http://jaeger.itscoder.com/android/2016/09/20/nuva-source-code-analysis.html" target="_blank" rel="noopener">热修复实现：ClassLoader 方式的实现</a></p><h2 id="92-AsyncTask需要在主线程中实例化吗？"><a href="#92-AsyncTask需要在主线程中实例化吗？" class="headerlink" title="92. AsyncTask需要在主线程中实例化吗？"></a>92. AsyncTask需要在主线程中实例化吗？</h2><h3 id="92-1-API-16之前"><a href="#92-1-API-16之前" class="headerlink" title="92.1. API 16之前"></a>92.1. API 16之前</h3><p>AsyncTask的静态Handler创建和初始化时默认采用的是当前现场的Looper。若子线程无Looper，则会出错；若有Looper则会导致处理消息时无法在主线程执行，出错。所以AsyncTask必须在主线程实例化。</p><h3 id="92-2-API-16及之后，API-22之前"><a href="#92-2-API-16及之后，API-22之前" class="headerlink" title="92.2. API 16及之后，API 22之前"></a>92.2. API 16及之后，API 22之前</h3><p>在ActivityThread的<code>main()</code>中直接调用了<code>AsyncTask.init()</code>，保证Handler在主线程实例化。所以AsyncTask不需要在主线程实例化。</p><h3 id="92-3-API-22及之后"><a href="#92-3-API-22及之后" class="headerlink" title="92.3. API 22及之后"></a>92.3. API 22及之后</h3><p>不再在ActivityThread的<code>main()</code>中调用。AsyncTask通过<code>getMainLooper()</code>获得主线程Looper。所以AsyncTask不需要在主线程实例化。</p><h2 id="93-Android消息处理机制"><a href="#93-Android消息处理机制" class="headerlink" title="93. Android消息处理机制"></a>93. Android消息处理机制</h2><p>Android消息处理机制主要涉及4个类：Looper、Handler、MessageQueue和Message。</p><h3 id="93-1-Looper"><a href="#93-1-Looper" class="headerlink" title="93.1. Looper"></a>93.1. Looper</h3><p>Looper的使用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LooperThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Handler mHandler<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Looper<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// process incoming messages here</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        Looper<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Looper概览：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Looper</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>Looper<span class="token operator">></span> sThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> MessageQueue mQueue<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueue</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Only one Looper may be created per thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Looper <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            Message msg <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// might block</span>            msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">dispatchMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            msg<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>prepare()</code>会检查此线程是否已经存在Looper，随后便会实例化一个Looper（创建一个MessageQueue），并将此Looper设置为此线程的ThreadLocal变量，这样完成Looper和线程的绑定。</p><p><code>loop()</code>即进从MessageQueue取消息并处理的死循环。</p><h3 id="93-2-Handler"><a href="#93-2-Handler" class="headerlink" title="93.2. Handler"></a>93.2. Handler</h3><p>Handler概览：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Looper mLooper<span class="token punctuation">;</span>    <span class="token keyword">final</span> MessageQueue mQueue<span class="token punctuation">;</span>    <span class="token keyword">final</span> Handler<span class="token punctuation">.</span>Callback mCallback<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mLooper <span class="token operator">=</span> Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mLooper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>                    <span class="token string">"Can't create handler inside thread that has not called Looper.prepare()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        mQueue <span class="token operator">=</span> mLooper<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispatchMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>callback <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleCallback</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> what<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Message <span class="token function">getPostMessage</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Message m <span class="token operator">=</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m<span class="token punctuation">.</span>callback <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">return</span> m<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">post</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MessageQueue queue <span class="token operator">=</span> mQueue<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>MessageQueue queue<span class="token punctuation">,</span> Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        msg<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">enqueueMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handleCallback</span><span class="token punctuation">(</span>Message message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        message<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>一般的用法是对<code>mHandler</code>调用<code>obtainMessage()</code>获得Message并设置参数后通过<code>sendMessage()</code>发送出去。在<code>obtainMessage()</code>和<code>sendMessage()</code>都会设置Message的Handler为本Handler（Message的<code>target</code>变量），若需向Message传递Runnable对象，则会在Message的<code>callback</code>变量中记录。</p><p><code>sendMessage()</code>最终会调用MessageQueue的<code>enqueueMessage()</code>方法，将此Message绑定到对应Looper对应的MessageQueue上。而Looper中收到Message后，会调用Message的<code>target</code>变量（即Handler）的<code>dispatchMessage()</code>方法。对于普通Message，<code>dispatchMessage()</code>又会去调用<code>handleMessage()</code>方法，而这个方法会被用户重载，所以会执行<code>mHandler</code>中指定的代码。</p><p>参考：<a href="http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html" target="_blank" rel="noopener">android的消息处理机制（图+源码分析）——Looper,Handler,Message - CodingMyWorld - 博客园</a></p><h2 id="94-startActivity-执行流程"><a href="#94-startActivity-执行流程" class="headerlink" title="94. startActivity()执行流程"></a>94. <code>startActivity()</code>执行流程</h2><p><img src="/2018/12/31/android-kai-fa-xiang-guan-zhi-shi-zong-jie/images/start_activity_process.jpg" alt="Start Activity Process"></p><ul><li>当Activity的目标进程不存在时，会首先创建进程。</li><li>Activity Manager Service（AMS）向目标进程的主线程发送<code>LAUNCH_ACTIVITY</code>，目标进程通过反射创建目标Activity，然后进入<code>onCreate()</code>生命周期。</li></ul><p>参考：<a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析 - Gityuan博客 | 袁辉辉博客</a></p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安卓开发项目相关问题总结</title>
      <link href="/2018/12/31/an-zhuo-kai-fa-xiang-mu-xiang-guan-wen-ti-zong-jie/"/>
      <url>/2018/12/31/an-zhuo-kai-fa-xiang-mu-xiang-guan-wen-ti-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h1><!-- TOC --><ul><li><a href="#1-基于android和java的流式二维码数据传输系统">1. 基于Android和Java的流式二维码数据传输系统</a><ul><li><a href="#11-简介">1.1. 简介</a></li><li><a href="#12-应用和优点">1.2. 应用和优点</a></li><li><a href="#13-传输效率">1.3. 传输效率</a></li><li><a href="#14-研究贡献">1.4. 研究贡献</a><ul><li><a href="#141-第一阶段">1.4.1. 第一阶段</a></li><li><a href="#142-第二阶段">1.4.2. 第二阶段</a></li></ul></li><li><a href="#15-开发app遇到的问题">1.5. 开发APP遇到的问题</a><ul><li><a href="#151-不能实时解码">1.5.1. 不能实时解码</a></li><li><a href="#152-代码扩展性差">1.5.2. 代码扩展性差</a></li></ul></li><li><a href="#16-用到了哪些机器学习方法">1.6. 用到了哪些机器学习方法</a></li><li><a href="#17-mediacodec应用在哪里">1.7. <code>MediaCodec</code>应用在哪里？</a></li><li><a href="#18-代码结构">1.8. 代码结构</a><ul><li><a href="#181-发送方">1.8.1. 发送方</a></li><li><a href="#182-接收方">1.8.2. 接收方</a></li></ul></li></ul></li><li><a href="#2-基于androidflask和mysql的用户情绪和隐私收集系统">2. 基于Android、Flask和MySQL的用户情绪和隐私收集系统</a><ul><li><a href="#21-简介">2.1. 简介</a></li><li><a href="#22-收集哪些隐私信息">2.2. 收集哪些隐私信息</a></li><li><a href="#23-如何长驻后台">2.3. 如何长驻后台</a></li><li><a href="#24-如何实现用户登录注册">2.4. 如何实现用户登录注册</a></li><li><a href="#25-问卷内容是什么">2.5. 问卷内容是什么？</a></li><li><a href="#26-调查问卷如何分发和收集">2.6. 调查问卷如何分发和收集</a></li><li><a href="#27-app如何定时抓取用户信息">2.7. APP如何定时抓取用户信息</a></li><li><a href="#28-如何上传用户数据">2.8. 如何上传用户数据</a></li><li><a href="#29-app崩溃如何分析恢复">2.9. APP崩溃如何分析恢复</a></li><li><a href="#210-后台提供哪些统计和管理">2.10. 后台提供哪些统计和管理</a></li><li><a href="#211-用到哪些第三方库">2.11. 用到哪些第三方库</a></li><li><a href="#212-后台是如何搭建的">2.12. 后台是如何搭建的</a></li><li><a href="#213-遇到过哪些问题">2.13. 遇到过哪些问题</a></li></ul></li></ul><!-- /TOC --><h2 id="1-基于Android和Java的流式二维码数据传输系统"><a href="#1-基于Android和Java的流式二维码数据传输系统" class="headerlink" title="1. 基于Android和Java的流式二维码数据传输系统"></a>1. 基于Android和Java的流式二维码数据传输系统</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1. 简介"></a>1.1. 简介</h3><p>流式二维码数据传输系统，以动态二维码的形式在手机／电脑之间传送文件。发送端可以是手机、电脑等任意有屏幕的设备，接收端是带有摄像头的手机。发送端将文件数据编码后嵌入到多个二维码中，二维码动态显式于电脑／手机屏幕上。接收端APP通过摄像头连续捕捉发送的二维码，识别并解码还原出数据，完成文件传输过程。</p><h3 id="1-2-应用和优点"><a href="#1-2-应用和优点" class="headerlink" title="1.2. 应用和优点"></a>1.2. 应用和优点</h3><ul><li>目前手机之间需要传送小文件（如照片）需要蓝牙或wifi进行配对连接，然后传输文件，这样有两个弊端：需要设备硬件支持，需要提前配对连接。而这种基于二维码的传输不需要硬件支持（手机几乎全都有摄像头），运行于软件层面上；且不需要提前建立连接，即用即传。</li><li>目前将文件从台式电脑传送到手机需要通过USB有线连接，或手机加入与台式机在同一局域网的wifi网络，这样很不方便。而通过基于二维码的传输只需要将二维码在电脑屏幕上显示，手机打开摄像头拍摄即可完成文件传输。</li><li>一些如企业等有保密需求的环境下，手机不能连接wifi加入同一局域网，通过基于二维码的传输则可方便解决。</li></ul><h3 id="1-3-传输效率"><a href="#1-3-传输效率" class="headerlink" title="1.3. 传输效率"></a>1.3. 传输效率</h3><p>在发送方最高为30fps的环境下，我们设计的黑白二维码可以达到200kbps，彩色（4色）二维码可以达到300kbps，应用机器学习后可以达到380kbps。</p><p>1080P每帧的处理时间在20ms左右。边界检测6ms，小方块采样8ms，识别2ms，纠错2ms。</p><h3 id="1-4-研究贡献"><a href="#1-4-研究贡献" class="headerlink" title="1.4. 研究贡献"></a>1.4. 研究贡献</h3><p>两个阶段</p><h4 id="1-4-1-第一阶段"><a href="#1-4-1-第一阶段" class="headerlink" title="1.4.1. 第一阶段"></a>1.4.1. 第一阶段</h4><ul><li>新的二维码布局：不同于一个小方块一种颜色，ShiftCode可以在小方块内部嵌套了一个更小的方块，以小方块的移动方向来嵌入数据。优点：嵌入数据更多，可扩展，为解决帧重叠问题提供可能。</li><li>解决帧重叠问题：对于30fps的接收方，当发送方帧速率超过15fps时就会出现帧重叠的问题。采用前后两帧相同位置小方块前景色和后景色相反的设计，可以在小方块发生帧重叠时正确区分前后帧小方块的移动方向，从而将重叠帧分离开。</li><li>可靠性解决方案：对于每一帧的数据，使用Reed-Solomon纠错编码，其优点是可以对连续出错有较好的纠错能力。对所有发送的帧数据使用RaptorQ冗余编码，因为这种传输是单向传输，并没有丢帧重传机制，RaptorQ可以将原始的N帧数据计算生成(N + K)帧数据，只要接收到任意的N帧即可还原出原数据。</li></ul><h4 id="1-4-2-第二阶段"><a href="#1-4-2-第二阶段" class="headerlink" title="1.4.2. 第二阶段"></a>1.4.2. 第二阶段</h4><ul><li>基于机器学习的通用动态二维码识别方案：对于任何现有的基于规则的动态二维码方案，都可以将其识别步骤替换为机器学习方案，识别效率和准确度上都有很大提升。</li><li>统一的识别框架：只需要将小方块采样点颜色和其对应的真实数据交给机器学习训练，得到机器学习模型，后续真正传输时只需要采样小方块，交给模型即可得到真实数据。</li><li>解决帧重叠问题：以黑白为例，重叠帧中小方块可能有4个状态：【黑+黑】、【黑+白】、【白+黑】和【白+白】，通过人为制造【黑+黑】、【黑+白】、【白+黑】和【白+白】这4个状态，接下就只需要确定小方块属于其中哪个状态。这实际是一个分类问题，只需要提前训练好状态的分类，即可判断出小方块的重叠情况。更细节的需要涉及到rolling shutter现象。</li></ul><h3 id="1-5-开发APP遇到的问题"><a href="#1-5-开发APP遇到的问题" class="headerlink" title="1.5. 开发APP遇到的问题"></a>1.5. 开发APP遇到的问题</h3><h4 id="1-5-1-不能实时解码"><a href="#1-5-1-不能实时解码" class="headerlink" title="1.5.1. 不能实时解码"></a>1.5.1. 不能实时解码</h4><p>问题：接收端为30fps，即一秒钟要处理30张图片，每一张图片总的（边界检测、采样、识别、纠错）处理时间要在33ms内。前期没有专门优化导致每帧处理时间需要1秒以上。</p><p>解决方法：</p><ul><li>使用Android Device Monitor的TraceView工具分析每一帧的处理耗时分布，找到耗时最长的函数进行优化，如此循环。</li><li>因Android提供的帧数据是NV21格式，最初是将图片由NV21转换为RGB，非常耗时。最初尝试将转换函数的浮点运算转换为整数运算，效果不好；之后尝试使用OpenGL ES的shader，即GPU来进行转换运算，有一定效果但耗时仍长；再尝试使用JNI即C++来运算，仍未达到预期。再后来转变思路，因为不会用到图片中所有像素点，所以可以在需要时再当场对单个像素点转换，这样暂时解决了问题。但后来发现因为采样点还是比较多，总体来看转换函数耗时还是很大，最后项目整体由RGB转到YUV，不再需要颜色转换，问题顺利解决。</li><li>二维码边界检测是使用一个小矩形逐渐放大直到框住二维码，这个过程需要逐像素行检查和扩展，很耗时。考虑到传输过程中摄像头不会大幅度移动，即二维码相对图片中的位置较为稳定，那么框住的矩形也会较为稳定，这样在确定一个矩形后，对于下一帧，只需要将矩形缩小1/3或1/5即可，节约了很多计算。</li><li>边界检测的结果是定位到二维码的四个顶点，最初是根据这四个顶点通过反透视变换生成一个标准的二维码，需要将原二维码中每个像素计算映射到标准二维码中，很耗时。后来考虑到反透视变换实际上只是计算出一个变换矩阵，而对于拍到二维码，只需要获得采样点的像素值即可，不需要将整个二维码中全部像素点都映射；所以只在需要某个采样点像素值时，将其标准化坐标通过透视变换矩阵转换为真实坐标，再获得像素值即可。</li><li>其他主要是Java语法层面优化，比如变量复用，减少<code>new</code>之类的。</li></ul><h4 id="1-5-2-代码扩展性差"><a href="#1-5-2-代码扩展性差" class="headerlink" title="1.5.2. 代码扩展性差"></a>1.5.2. 代码扩展性差</h4><p>问题：如有新的处理方法或新的二维码加入，需要修改代码时就有种牵一发而动全身的感觉，代码扩展性差。</p><p>解决方法：</p><ul><li>恶补面向对象编程思想，设计模式。</li><li>充分利用继承和抽象复用代码，如不同形状二维码，不同颜色二维码。</li><li>使用工厂方法管理不同二维码的实例化，复用同一套处理框架。</li><li>使用策略模式根据不同需求调整使用不同的二维码定位算法。</li><li>将各种不同二维码的构造生成方法抽象为统一的平台，将二维码分割成border、padding、数据区等块，对于每一块独立指定二维码形状和数据等即可生成二维码。这样避免了为每种二维码写一个大同小异的生成方法，也避免了需要计算各种偏移量等。</li></ul><h3 id="1-6-用到了哪些机器学习方法"><a href="#1-6-用到了哪些机器学习方法" class="headerlink" title="1.6. 用到了哪些机器学习方法"></a>1.6. 用到了哪些机器学习方法</h3><ul><li>实际是一个分类问题，features是小方块采样点颜色和对应参考颜色，class是小方块的真实数据。</li><li>最基本的是使用决策树（Decision Tree），分类效果较好。</li><li>为解决决策树学习时间长的问题，使用随机森林（Random Forest），学习速度有明显提高。</li><li>为解决每次传输需要当场学习出一个模型的问题，使用混合专家模型（Mixture of Experts），对不同场景进行几次传输得到多个模型，使用混合专家模型时只需要在最开始放上少量的学习帧，即可得到各模型的权重，形成一个新的模型。</li></ul><h3 id="1-7-MediaCodec应用在哪里？"><a href="#1-7-MediaCodec应用在哪里？" class="headerlink" title="1.7. MediaCodec应用在哪里？"></a>1.7. <code>MediaCodec</code>应用在哪里？</h3><ul><li><code>MediaCodec</code>用来快速将视频文件解码为图片帧。</li><li>项目支持的输入包括摄像头预览、图片和视频。</li><li>视频的解码最初使用<code>MediaMetadataRetriever</code>，这样有两个主要缺点：软件解码，耗时长；只能使用<code>getFrameAtTime()</code>获取帧，不精确。</li><li><code>MediaCodec</code>是Android提供的硬件解码API，可以快速将视频文件解码为图片帧。</li><li>但<code>MediaCodec</code>存在一个问题：其仅支持处理器芯片支持的帧格式（YUV420中的众多格式），且没有通用支持的格式，即没有设备通用性。</li><li>利用Android API 21的新特性：<code>COLOR_FormatYUV420Flexible</code>的支持，和新的<code>Image</code>类。</li><li>在解码时指定解码格式为<code>COLOR_FormatYUV420Flexible</code>（这个所有设备都支持），解码生成的帧指定为Image类，其可以单独获取YUV各个分量的数据。拼接这些数据即可得到指定YUV420格式的图片帧。实现了设备通用性。</li><li>对1080P的视频，每个图片帧可以在30ms内得到。</li></ul><h3 id="1-8-代码结构"><a href="#1-8-代码结构" class="headerlink" title="1.8. 代码结构"></a>1.8. 代码结构</h3><h4 id="1-8-1-发送方"><a href="#1-8-1-发送方" class="headerlink" title="1.8.1. 发送方"></a>1.8.1. 发送方</h4><ul><li>二维码由Districts、District、Zone组成，其将二维码划分为不同区域（Zone）。每个区域指定其Block的类型，以及二进制数据。由底层处理数据向二维码图片的转换，包括位置、偏移、大小等。</li><li>不同的二维码可能有类似的边框样式或数据内容，通过继承关系组织不同的二维码，如BlackWhiteCode是最基础的二维码，其上可以衍生出ColorCode、ShiftCode等。</li></ul><h4 id="1-8-2-接收方"><a href="#1-8-2-接收方" class="headerlink" title="1.8.2. 接收方"></a>1.8.2. 接收方</h4><ul><li>使用两个线程一个队列，一个线程用来从摄像头／视频文件获取图片帧，并放入队列；另一个线程从队列中取出图片帧，处理图片帧，直到再无图片帧或数据传输完成。</li><li>将图片帧数据封装为RawImage，提供像素值获取、二维码定位等功能。</li><li>RawImage由MediatBarcode封装，MediatBarcode同时提供反透视变换功能，将二维码分割为Districts、District、Zone区域，提供获取区域像素值数据等功能。</li><li>MediateBarcode供不同的二维码使用，这些二维码同样有继承关系，最基本的BlackWhiteCode提供有通用的Zone处理方法，如获取帧编号等。</li><li>StreamDecode提供处理队列中二维码的骨架，其管理二维码间的关联关系，如二维码定位矩阵的保存、帧间冗余算法的纪录。</li></ul><h2 id="2-基于Android、Flask和MySQL的用户情绪和隐私收集系统"><a href="#2-基于Android、Flask和MySQL的用户情绪和隐私收集系统" class="headerlink" title="2. 基于Android、Flask和MySQL的用户情绪和隐私收集系统"></a>2. 基于Android、Flask和MySQL的用户情绪和隐私收集系统</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1. 简介"></a>2.1. 简介</h3><p>APP主要包括两部分，一部分是填写调查问卷，另一部分是在后台持续收集用户隐私信息。调查问卷由用户向服务器请求得到，填写完成后提交给服务器；收集隐私是APP长驻后台，定时抓取用户数据并保存到本地数据库，定时将数据库发送给服务器。</p><h3 id="2-2-收集哪些隐私信息"><a href="#2-2-收集哪些隐私信息" class="headerlink" title="2.2. 收集哪些隐私信息"></a>2.2. 收集哪些隐私信息</h3><p>收集的隐私信息包括录音（持续5秒）、通话记录、短信、联系人信息、地理位置（高德地图API）、手机信息、传感器信息（磁力计、陀螺仪等）、周围wifi、屏幕亮灭、前台运行APP、后台运行APP等。</p><h3 id="2-3-如何长驻后台"><a href="#2-3-如何长驻后台" class="headerlink" title="2.3. 如何长驻后台"></a>2.3. 如何长驻后台</h3><ul><li>服务启动时即拿到PARTIAL_WAKE_LOCK，且不放弃。PARTIAL_WAKE_LOCK在屏幕熄灭的情况下仍保持CPU运行。</li><li>使用第三方云巴推送平台，定时向所有用户推送消息，用来唤醒APP。</li><li>用户配合关闭手机厂商的省电设置等。</li></ul><h3 id="2-4-如何实现用户登录注册"><a href="#2-4-如何实现用户登录注册" class="headerlink" title="2.4. 如何实现用户登录注册"></a>2.4. 如何实现用户登录注册</h3><p>因为是科研项目，并没有实现完整的登录注册功能。只需要填写学号、手机号，服务器后台查询不冲突即注册成功；只需要填写学号，服务器能够查询到相关信息即可登录。</p><h3 id="2-5-问卷内容是什么？"><a href="#2-5-问卷内容是什么？" class="headerlink" title="2.5. 问卷内容是什么？"></a>2.5. 问卷内容是什么？</h3><p>问卷内容我不关系。主要是询问用户是否开心、沮丧等，及其程度。</p><h3 id="2-6-调查问卷如何分发和收集"><a href="#2-6-调查问卷如何分发和收集" class="headerlink" title="2.6. 调查问卷如何分发和收集"></a>2.6. 调查问卷如何分发和收集</h3><ul><li>用户收到APP推送或主动打开APP，点击“填写调查问卷”即向服务器发送请求，服务器判断距离用户上次提交问卷时间间隔有没有达到6小时，若未达到则返回错误提示；若达到则进入分发问卷流程。</li><li>分发问卷时，服务器从数据库中读取题目，并拼装为json格式，同时针对每次分发生成一个唯一的id，用来记录问卷的提交。</li><li>用户填写完问卷点击提交时，同步提交问卷的唯一id；服务器首先验证唯一id是否有效，然后读取客户端发送的json格式回答，解析后保存到数据库中。</li></ul><h3 id="2-7-APP如何定时抓取用户信息"><a href="#2-7-APP如何定时抓取用户信息" class="headerlink" title="2.7. APP如何定时抓取用户信息"></a>2.7. APP如何定时抓取用户信息</h3><p>APP启动同步创建一个Service，Service启动时即实例化一个<code>SingleThreadScheduledExecutor</code>，并设定定时执行周期为一分钟。</p><p>本地数据库中新建一个表，每行纪录需要运行的任务（抓取哪些信息、心跳、上传数据库、清理数据库、切换新数据库）、执行间隔时间、下次运行时间。每当定时周期达到时，就查询数据库，一旦某个任务的下次运行时间小于当前时间，则执行任务，并根据执行间隔时间确定下次运行时间。</p><h3 id="2-8-如何上传用户数据"><a href="#2-8-如何上传用户数据" class="headerlink" title="2.8. 如何上传用户数据"></a>2.8. 如何上传用户数据</h3><p>当执行上传用户数据任务时，则从数据库中读取还未上传的数据库的名字，并逐个通过HTTP POST请求发送本地压缩后的数据库，并在本地数据库中标记此数据库已上传。</p><h3 id="2-9-APP崩溃如何分析恢复"><a href="#2-9-APP崩溃如何分析恢复" class="headerlink" title="2.9. APP崩溃如何分析恢复"></a>2.9. APP崩溃如何分析恢复</h3><p>使用第三方库ACRA进行崩溃信息的收集和上报。</p><p>当APP崩溃后，下次运行时对于不完整或异常的任务在撤销后重新执行并写数据库，保证数据库数据的一致性。</p><h3 id="2-10-后台提供哪些统计和管理"><a href="#2-10-后台提供哪些统计和管理" class="headerlink" title="2.10. 后台提供哪些统计和管理"></a>2.10. 后台提供哪些统计和管理</h3><ul><li>后台展示每个用户的心跳历史、问卷填写历史、上传用户数据时间等。</li><li>可以从后台向特定用户发送推送通知，可以针对不同用户指定不同的APP版本。</li></ul><h3 id="2-11-用到哪些第三方库"><a href="#2-11-用到哪些第三方库" class="headerlink" title="2.11. 用到哪些第三方库"></a>2.11. 用到哪些第三方库</h3><p>Android上的HTTP通信部分使用了okhttp。</p><h3 id="2-12-后台是如何搭建的"><a href="#2-12-后台是如何搭建的" class="headerlink" title="2.12. 后台是如何搭建的"></a>2.12. 后台是如何搭建的</h3><p>后台是基于Python和flask的，flask提供了一套http的处理框架，只需要注册对应的url即可。对于数据的持久存储等则是利用到了MySQL。</p><h3 id="2-13-遇到过哪些问题"><a href="#2-13-遇到过哪些问题" class="headerlink" title="2.13. 遇到过哪些问题"></a>2.13. 遇到过哪些问题</h3><ul><li>APP经常退出前台即被杀死。最初考虑一般的保活方法，如使用AlarmManager，发现用处不大。后来才发现是国内厂商动了手脚，非白名单的APP一律不允许后台运行。所以后来除在技术上尽可能保证APP不被杀死外，还建议用户在手机的设置中将APP加入到白名单。</li><li>经常在抓取用户数据时crash。最初以为是本身代码有问题，一番排查后才发现国内厂商在权限管理上动了手脚。按照官方文档，如果执行某些代码时用户未授权则会返回null值或抛出异常，但国内厂商直接在framework层进行了修改，不知道在哪会去检查权限，一旦未授权则直接抛出异常，导致APP crash。最后不得已对一些敏感信息收集时使用大段的try catch，避免未知的crash。</li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android开发相关知识总结</title>
      <link href="/2018/12/31/11/"/>
      <url>/2018/12/31/11/</url>
      
        <content type="html"><![CDATA[<h1 id="Android面试题"><a href="#Android面试题" class="headerlink" title="Android面试题"></a>Android面试题</h1><!-- TOC --><ul><li><a href="#1-android四大组件">1. Android四大组件</a><ul><li><a href="#11-activity">1.1. Activity</a></li><li><a href="#12-服务">1.2. 服务</a></li><li><a href="#13-内容提供程序">1.3. 内容提供程序</a></li><li><a href="#14-广播接收器">1.4. 广播接收器</a></li></ul></li><li><a href="#2-四大组件的启动方式">2. 四大组件的启动方式</a></li><li><a href="#3-画出activity的生命周期图">3. 画出Activity的生命周期图</a></li><li><a href="#4-介绍下不同场景下activity生命周期的变化过程">4. 介绍下不同场景下Activity生命周期的变化过程</a></li><li><a href="#5-当activity-a启动activity-b时生命周期执行过程">5. 当Activity A启动Activity B时，生命周期执行过程？</a></li><li><a href="#6-内存不足时系统会杀掉后台的activity若需要进行一些临时状态的保存在哪个方法进行怎么恢复数据">6. 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？</a></li><li><a href="#7-什么是任务">7. 什么是任务？</a></li><li><a href="#8-activity的启动模式">8. Activity的启动模式？</a></li><li><a href="#9-横竖屏切换时候activity的生命周期">9. 横竖屏切换时候activity的生命周期？</a></li><li><a href="#10-如何将一个activity设置成窗口的样式">10. 如何将一个Activity设置成窗口的样式？</a></li><li><a href="#11-activity之间的数据传递有哪些方式">11. Activity之间的数据传递有哪些方式？</a></li><li><a href="#12-fragment的好处">12. Fragment的好处：</a></li><li><a href="#13-intent的原理作用可以传递哪些类型的参数">13. Intent的原理，作用，可以传递哪些类型的参数？</a></li><li><a href="#14-intent的主要使用方法">14. Intent的主要使用方法</a><ul><li><a href="#141-启动-activity">14.1. 启动 Activity</a></li><li><a href="#142-启动服务">14.2. 启动服务</a></li><li><a href="#143-传递广播">14.3. 传递广播</a></li></ul></li><li><a href="#15-intent包含哪些信息">15. Intent包含哪些信息</a></li><li><a href="#16-什么是intent过滤器">16. 什么是Intent过滤器</a></li><li><a href="#17-service的启动方式">17. Service的启动方式</a></li><li><a href="#18-service的生命周期">18. Service的生命周期</a></li><li><a href="#19-activity怎么和service绑定怎么在activity中启动自己对应的service">19. Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？</a></li><li><a href="#20-允许绑定的已启动服务的生命周期">20. 允许绑定的已启动服务的生命周期</a></li><li><a href="#21-service中可以弹toast吗">21. Service中可以弹Toast吗？</a></li><li><a href="#22-进程的优先级">22. 进程的优先级</a><ul><li><a href="#221-前台进程">22.1. 前台进程</a></li><li><a href="#222-可视进程">22.2. 可视进程</a></li><li><a href="#223-服务进程">22.3. 服务进程</a></li><li><a href="#224-后台进程">22.4. 后台进程</a></li><li><a href="#225-空进程">22.5. 空进程</a></li></ul></li><li><a href="#23-intentservice如何工作">23. IntentService如何工作？</a></li><li><a href="#24-intentservice与service的区别">24. IntentService与Service的区别？</a></li><li><a href="#25-android-service与activity之间的通信方式">25. Android Service与Activity之间的通信方式？</a></li><li><a href="#26-broadcastreceiver简介">26. BroadcastReceiver简介</a><ul><li><a href="#261-用途">26.1. 用途</a></li><li><a href="#262-使用场景">26.2. 使用场景</a></li><li><a href="#263-实现原理">26.3. 实现原理</a></li><li><a href="#264-注册方式">26.4. 注册方式</a></li></ul></li><li><a href="#27-为什么要用contentprovider它和sql的实现上有什么差别">27. 为什么要用ContentProvider？它和SQL的实现上有什么差别？</a></li><li><a href="#28-contentprovider怎么实现数据共享">28. ContentProvider怎么实现数据共享？</a></li><li><a href="#29-android如何访问自定义contentprovider">29. Android如何访问自定义ContentProvider</a></li><li><a href="#30-android中activityintentcontent-providerservice各有什么区别">30. Android中Activity，Intent，Content Provider，Service各有什么区别。</a></li><li><a href="#31-android数据存储方式">31. Android数据存储方式？</a></li><li><a href="#32-android中常用的布局都有哪些">32. Android中常用的布局都有哪些？</a></li><li><a href="#33-androidlayout_gravity和androidgravity的区别">33. <code>android:layout_gravity</code>和<code>android:gravity</code>的区别？</a></li><li><a href="#34-android平台架构">34. Android平台架构</a><ul><li><a href="#341-系统应用">34.1. 系统应用</a></li><li><a href="#342-java-api框架">34.2. Java API框架</a></li><li><a href="#343-原生cc库">34.3. 原生C/C++库</a></li><li><a href="#344-android-runtime">34.4. Android Runtime</a></li><li><a href="#345-硬件抽象层hal">34.5. 硬件抽象层（HAL）</a></li><li><a href="#346-linux-内核">34.6. Linux 内核</a></li></ul></li><li><a href="#35-fragment生命周期">35. Fragment生命周期</a></li><li><a href="#36-activity生命周期对片段生命周期的影响">36. Activity生命周期对片段生命周期的影响</a></li><li><a href="#37-android事件分发">37. Android事件分发</a><ul><li><a href="#371-public-boolean-dispatchtoucheventmotionevent-ev">37.1. <code>public boolean dispatchTouchEvent(MotionEvent ev)</code></a></li><li><a href="#372-public-boolean-onintercepttoucheventmotionevent-ev">37.2. <code>public boolean onInterceptTouchEvent(MotionEvent ev)</code></a></li><li><a href="#373-public-boolean-ontoucheventmotionevent-ev">37.3. <code>public boolean onTouchEvent(MotionEvent ev)</code></a></li></ul></li><li><a href="#38-android系统启动过程">38. Android系统启动过程</a><ul><li><a href="#381-boot-rom">38.1. Boot ROM</a></li><li><a href="#382-boot-loader">38.2. Boot Loader</a></li><li><a href="#383-kernel">38.3. Kernel</a></li><li><a href="#384-init">38.4. init</a><ul><li><a href="#3841-本地服务">38.4.1. 本地服务</a></li><li><a href="#3842-android服务">38.4.2. Android服务</a></li></ul></li><li><a href="#385-zygote-and-dalvikart">38.5. Zygote and Dalvik（ART）</a></li><li><a href="#386-system-server">38.6. System Server</a></li><li><a href="#387-boot-completed">38.7. Boot completed</a></li></ul></li><li><a href="#39-android应用启动过程">39. Android应用启动过程</a></li><li><a href="#40-dpdipdpippi区别">40. dp，dip，dpi，ppi区别</a></li><li><a href="#41-长度和字体的推荐单位">41. 长度和字体的推荐单位</a></li><li><a href="#42-android-view绘制流程">42. Android View绘制流程</a></li><li><a href="#43-listview优化">43. ListView优化</a></li><li><a href="#44-android-binder机制">44. Android Binder机制</a></li><li><a href="#45-binder机制优点">45. Binder机制优点</a></li><li><a href="#46-asynctask简介">46. AsyncTask简介</a></li><li><a href="#47-为什么handler需要声明为static">47. 为什么Handler需要声明为static？</a></li><li><a href="#48-广播注册后不解除注册会有什么问题">48. 广播注册后不解除注册会有什么问题？</a></li><li><a href="#49-自定义view">49. 自定义View</a><ul><li><a href="#491-实现步骤">49.1. 实现步骤</a></li></ul></li><li><a href="#50-需要被重写的方法">50. 需要被重写的方法</a></li><li><a href="#51-parcelable和serializable的区别">51. Parcelable和Serializable的区别</a></li><li><a href="#52-android中的内存泄漏">52. Android中的内存泄漏</a></li><li><a href="#53-mvc和mvp的区别">53. MVC和MVP的区别</a></li><li><a href="#54-内存泄露检测有什么好方法">54. 内存泄露检测有什么好方法？</a></li><li><a href="#55-android里面为什么要设计出bundle而不是直接用map结构">55. Android里面为什么要设计出Bundle而不是直接用Map结构</a></li><li><a href="#56-在android的mvp架构中使用了什么设计模式">56. 在Android的MVP架构中，使用了什么设计模式</a></li><li><a href="#57-android动画类型">57. Android动画类型</a></li><li><a href="#58-anr和fc的区别">58. ANR和FC的区别</a></li><li><a href="#59-android中的菜单">59. Android中的菜单</a><ul><li><a href="#591-选项菜单options-menu">59.1. 选项菜单（Options menu）</a></li><li><a href="#592-上下文菜单contextual-menus">59.2. 上下文菜单（Contextual Menus）</a><ul><li><a href="#5921-浮动上下文菜单floating-context-menu">59.2.1. 浮动上下文菜单（floating context menu）</a></li></ul></li><li><a href="#593-弹出菜单popup-menu">59.3. 弹出菜单（Popup Menu）</a></li></ul></li><li><a href="#60-baseadapter中需要重载的方法">60. BaseAdapter中需要重载的方法</a></li><li><a href="#61-android数字签名要点">61. Android数字签名要点</a></li><li><a href="#62-使用相同数字签名的原因">62. 使用相同数字签名的原因</a></li><li><a href="#63-theme和sytle">63. Theme和Sytle</a><ul><li><a href="#631-style">63.1. Style</a></li><li><a href="#632-theme">63.2. Theme</a></li></ul></li><li><a href="#64-toast的时长设置">64. Toast的时长设置</a></li><li><a href="#65-触发anr的情况">65. 触发ANR的情况</a></li><li><a href="#66-serviceconnection的onserviceconnected触发条件">66. ServiceConnection的<code>onServiceConnected()</code>触发条件</a></li><li><a href="#67-android虚拟设备不支持的功能">67. Android虚拟设备不支持的功能</a></li><li><a href="#68-remoteview的应用">68. RemoteView的应用</a></li><li><a href="#69-android对hashmap做了优化后推出的新的容器类是什么">69. Android对HashMap做了优化后推出的新的容器类是什么？</a><ul><li><a href="#691-sparsearray">69.1. SparseArray</a></li><li><a href="#692-arraymap">69.2. ArrayMap</a></li></ul></li><li><a href="#70-android安全沙盒">70. Android安全沙盒</a></li><li><a href="#71-onstartcommand有哪些返回值">71. <code>onStartCommand()</code>有哪些返回值</a></li><li><a href="#72-如何创建绑定服务">72. 如何创建绑定服务</a><ul><li><a href="#721-扩展binder类">72.1. 扩展Binder类</a></li><li><a href="#722-使用messenger">72.2. 使用Messenger</a></li></ul></li><li><a href="#73-如何绑定到服务">73. 如何绑定到服务</a></li><li><a href="#74-android支持的屏幕密度">74. Android支持的屏幕密度</a></li><li><a href="#75-如何支持多种屏幕">75. 如何支持多种屏幕</a></li><li><a href="#76-什么是资源id">76. 什么是资源ID</a></li><li><a href="#77-如何处理运行时变更">77. 如何处理运行时变更</a><ul><li><a href="#771-在配置变更期间保留对象">77.1. 在配置变更期间保留对象</a></li><li><a href="#772-自行处理配置变更">77.2. 自行处理配置变更</a></li></ul></li><li><a href="#78-androidmanifestxml包括哪些内容">78. AndroidManifest.xml包括哪些内容？</a></li><li><a href="#79-用户界面如何构成">79. 用户界面如何构成？</a></li><li><a href="#80-为什么要回收bitmap的内存">80. 为什么要回收Bitmap的内存</a></li><li><a href="#81-如何优化bitmap">81. 如何优化Bitmap</a></li><li><a href="#82-如何在新进程中创建activity／service">82. 如何在新进程中创建Activity／Service</a></li><li><a href="#83-onactivityresult什么时候会失效">83. <code>onActivityResult()</code>什么时候会失效？</a></li><li><a href="#84-android崩溃捕获">84. Android崩溃捕获</a><ul><li><a href="#841-java崩溃捕获">84.1. Java崩溃捕获</a></li><li><a href="#842-native崩溃捕获">84.2. Native崩溃捕获</a></li></ul></li><li><a href="#85-android-app构建流程">85. Android APP构建流程</a></li><li><a href="#86-class文件与dex文件的区别">86. class文件与.dex文件的区别</a></li><li><a href="#87-65535问题">87. 65535问题</a><ul><li><a href="#871-原因">87.1. 原因</a></li><li><a href="#872-解决方法">87.2. 解决方法</a></li></ul></li><li><a href="#88-dalvik与jvm的区别">88. Dalvik与JVM的区别</a></li><li><a href="#89-art相对dalvik的优化">89. ART相对Dalvik的优化</a></li><li><a href="#90-android中的classloader">90. Android中的ClassLoader</a></li><li><a href="#91-classloader方式实现热修复">91. ClassLoader方式实现热修复</a></li><li><a href="#92-asynctask需要在主线程中实例化吗">92. AsyncTask需要在主线程中实例化吗？</a><ul><li><a href="#921-api-16之前">92.1. API 16之前</a></li><li><a href="#922-api-16及之后api-22之前">92.2. API 16及之后，API 22之前</a></li><li><a href="#923-api-22及之后">92.3. API 22及之后</a></li></ul></li><li><a href="#93-android消息处理机制">93. Android消息处理机制</a><ul><li><a href="#931-looper">93.1. Looper</a></li><li><a href="#932-handler">93.2. Handler</a></li></ul></li><li><a href="#94-startactivity执行流程">94. <code>startActivity()</code>执行流程</a></li></ul><!-- /TOC --><h2 id="1-Android四大组件"><a href="#1-Android四大组件" class="headerlink" title="1. Android四大组件"></a>1. Android四大组件</h2><p>应用组件是Android应用的基本构建基块。每个组件都是一个不同的点，系统可以通过它进入您的应用。并非所有组件都是用户的实际入口点，有些组件相互依赖，但每个组件都以独立实体形式存在，并发挥特定作用—-每个组件都是唯一的构建基块，有助于定义应用的总体行为。</p><p>共有四种不同的应用组件类型。每种类型都服务于不同的目的，并且具有定义组件的创建和销毁方式的不同生命周期。</p><p>以下便是这四种应用组件类型：</p><h3 id="1-1-Activity"><a href="#1-1-Activity" class="headerlink" title="1.1. Activity"></a>1.1. Activity</h3><p>Activity表示具有用户界面的单一屏幕。例如，电子邮件应用可能具有一个显示新电子邮件列表的Activity、一个用于撰写电子邮件的Activity以及一个用于阅读电子邮件的Activity。尽管这些Activity通过协作在电子邮件应用中形成了一种紧密结合的用户体验，但每一个Activity都独立于其他Activity而存在。因此，其他应用可以启动其中任何一个Activity（如果电子邮件应用允许）。例如，相机应用可以启动电子邮件应用内用于撰写新电子邮件的Activity，以便用户共享图片。</p><h3 id="1-2-服务"><a href="#1-2-服务" class="headerlink" title="1.2. 服务"></a>1.2. 服务</h3><p>服务是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。服务不提供用户界面。例如，当用户位于其他应用中时，服务可能在后台播放音乐或者通过网络获取数据，但不会阻断用户与Activity的交互。诸如Activity等其他组件可以启动服务，让其运行或与其绑定以便与其进行交互。</p><h3 id="1-3-内容提供程序"><a href="#1-3-内容提供程序" class="headerlink" title="1.3. 内容提供程序"></a>1.3. 内容提供程序</h3><p>内容提供程序管理一组共享的应用数据。您可以将数据存储在文件系统、SQLite数据库、网络上或您的应用可以访问的任何其他永久性存储位置。其他应用可以通过内容提供程序查询数据，甚至修改数据（如果内容提供程序允许）。例如，Android系统可提供管理用户联系人信息的内容提供程序。因此，任何具有适当权限的应用都可以查询内容提供程序的某一部分（如<code>ContactsContract.Data</code>），以读取和写入有关特定人员的信息。</p><p>内容提供程序也适用于读取和写入您的应用不共享的私有数据。例如，记事本示例应用使用内容提供程序来保存笔记。</p><h3 id="1-4-广播接收器"><a href="#1-4-广播接收器" class="headerlink" title="1.4. 广播接收器"></a>1.4. 广播接收器</h3><p>广播接收器是一种用于响应系统范围广播通知的组件。许多广播都是由系统发起的—-例如，通知屏幕已关闭、电池电量不足或已拍摄照片的广播。应用也可以发起广播—-例如，通知其他应用某些数据已下载至设备，并且可供其使用。尽管广播接收器不会显示用户界面，但它们可以创建状态栏通知，在发生广播事件时提醒用户。但广播接收器更常见的用途只是作为通向其他组件的”通道”，设计用于执行极少量的工作。例如，它可能会基于事件发起一项服务来执行某项工作。</p><h2 id="2-四大组件的启动方式"><a href="#2-四大组件的启动方式" class="headerlink" title="2. 四大组件的启动方式"></a>2. 四大组件的启动方式</h2><ul><li>您可以通过将Intent传递到<code>startActivity()</code>或<code>startActivityForResult()</code>（当您想让Activity返回结果时）来启动Activity（或为其安排新任务）。</li><li>您可以通过将Intent传递到<code>startService()</code>来启动服务（或对执行中的服务下达新指令）。或者，您也可以通过将Intent传递到<code>bindService()</code>来绑定到该服务。</li><li>您可以通过将Intent传递到<code>sendBroadcast()</code>、<code>sendOrderedBroadcast()</code>或<code>sendStickyBroadcast()</code>等方法来发起广播。</li><li>您可以通过在ContentResolver上调用<code>query()</code>来对内容提供程序执行查询。</li></ul><h2 id="3-画出Activity的生命周期图"><a href="#3-画出Activity的生命周期图" class="headerlink" title="3. 画出Activity的生命周期图"></a>3. 画出Activity的生命周期图</h2><p><img src="/2018/12/31/11/images/activity_lifecycle.png" alt="activity lifecycle"></p><h2 id="4-介绍下不同场景下Activity生命周期的变化过程"><a href="#4-介绍下不同场景下Activity生命周期的变化过程" class="headerlink" title="4. 介绍下不同场景下Activity生命周期的变化过程"></a>4. 介绍下不同场景下Activity生命周期的变化过程</h2><ul><li>启动Activity：<code>onCreate()</code> –&gt; <code>onStart()</code> –&gt; <code>onResume()</code>，Activity进入运行状态。</li><li>Activity退居后台：当前Activity转到新的Activity界面或按Home键回到主屏：<code>onPause()</code> –&gt; <code>onStop()</code>，进入停滞状态；这里有一种特殊情况，如果新Activity采用了透明主题，那么当前Activity不会回调<code>onStop()</code>。</li><li>Activity返回前台：<code>onRestart()</code> –&gt; <code>onStart()</code> –&gt; <code>onResume()</code>，再次回到运行状态。</li><li>Activity退居后台，且系统内存不足，系统会杀死这个后台状态的Activity，若再次回到这个Activity，则会走<code>onCreate()</code> –&gt; <code>onStart()</code> –&gt; <code>onResume()</code>。</li><li>锁定屏与解锁屏幕只会调用<code>onPause()</code>，而不会调用<code>onStop()</code>方法，开屏后则调用<code>onResume()</code>。</li></ul><h2 id="5-当Activity-A启动Activity-B时，生命周期执行过程？"><a href="#5-当Activity-A启动Activity-B时，生命周期执行过程？" class="headerlink" title="5. 当Activity A启动Activity B时，生命周期执行过程？"></a>5. 当Activity A启动Activity B时，生命周期执行过程？</h2><p><code>A.onPause()</code> –&gt; <code>B.onCreate()</code>，<code>B.onStart()</code>，<code>B.onResume()</code> –&gt; <code>A.onStop()</code>，如果B是个透明的，或者是对话框的样式，就不会调用<code>A.onStop()</code>。</p><h2 id="6-内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？"><a href="#6-内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？" class="headerlink" title="6. 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？"></a>6. 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？怎么恢复数据？</h2><ul><li>Activity的<code>onSaveInstanceState()</code>和<code>onRestoreInstanceState()</code>并不是生命周期方法，它们不同于<code>onCreate()</code>、<code>onPause()</code>等生命周期方法，它们并不一定会被触发。</li><li>当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity，<code>onSaveInstanceState()</code>会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，<code>onSaveInstanceState()</code>就不会被调用。除非该activity是被用户主动销毁的，通常<code>onSaveInstanceState()</code>只适合用于保存一些临时性的状态，而<code>onPause()</code>适合用于数据的持久化保存。</li><li>重写<code>onSaveInstanceState()</code>方法，在此方法中保存需要保存的数据，该方法将会在activity被回收之前调用。通过重写<code>onRestoreInstanceState()</code>方法可以从中提取保存好的数据。</li></ul><h2 id="7-什么是任务？"><a href="#7-什么是任务？" class="headerlink" title="7. 什么是任务？"></a>7. 什么是任务？</h2><p><img src="/2018/12/31/11/images/activity_task.png" alt="Activity Task"></p><p>任务是一个有机整体，当用户开始新任务或通过“主页”按钮转到主屏幕时，可以移动到“后台”。尽管在后台时，该任务中的所有Activity全部停止，但是任务的返回栈仍旧不变，也就是说，当另一个任务发生时，该任务仅仅失去焦点而已，如图所示。然后，任务可以返回到“前台”，用户就能够回到离开时的状态。</p><h2 id="8-Activity的启动模式？"><a href="#8-Activity的启动模式？" class="headerlink" title="8. Activity的启动模式？"></a>8. Activity的启动模式？</h2><ul><li>standard（默认模式）：系统在启动Activity的任务中创建Activity的新实例并向其传送Intent。Activity可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。</li><li>singleTop：如果当前任务的顶部已存在Activity的一个实例，则系统会通过调用该实例的onNewIntent()方法向其传送Intent，而不是创建Activity的新实例。Activity可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例（但前提是位于返回栈顶部的Activity并不是Activity的现有实例）。例如，假设任务的返回栈包含根Activity A以及Activity B、C和位于顶部的D（堆栈是A-B-C-D；D位于顶部）。收到针对D类Activity的Intent。如果D具有默认的”standard”启动模式，则会启动该类的新实例，且堆栈会变成A-B-C-D-D。但是，如果D的启动模式是”singleTop”，则D的现有实例会通过onNewIntent()接收Intent，因为它位于堆栈的顶部；而堆栈仍为A-B-C-D。但是，如果收到针对B类Activity的Intent，则会向堆栈添加B的新实例，即便其启动模式为”singleTop”也是如此。</li><li>singleTask：系统创建新任务并实例化位于新任务底部的Activity。但是，如果该Activity的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的onNewIntent()方法向其传送Intent，而不是创建新实例。一次只能存在Activity的一个实例。</li><li>singleInstace：与”singleTask”相同，只是系统不会将任何其他Activity启动到包含实例的任务中。该Activity始终是其任务唯一仅有的成员；由此Activity启动的任何Activity均在单独的任务中打开。</li></ul><h2 id="9-横竖屏切换时候activity的生命周期？"><a href="#9-横竖屏切换时候activity的生命周期？" class="headerlink" title="9. 横竖屏切换时候activity的生命周期？"></a>9. 横竖屏切换时候activity的生命周期？</h2><ul><li>不设置Activity的<code>android：configChanges</code>时，切屏会重新调用各个生命周期，切横屏时会执行一次，切竖屏时会执行两次。</li><li>设置Activity的<code>android：configChanges=&quot;orientation&quot;</code>时，切屏还是会重新调用各个生命周期，切横、竖屏时只会执行一次。</li><li>设置Activity的<code>android：configChanges=&quot;orientation|keyboardHidden&quot;</code>时，切屏不会重新调用各个生命周期，只会执行<code>onConfigurationChanged()</code>方法。</li></ul><h2 id="10-如何将一个Activity设置成窗口的样式？"><a href="#10-如何将一个Activity设置成窗口的样式？" class="headerlink" title="10. 如何将一个Activity设置成窗口的样式？"></a>10. 如何将一个Activity设置成窗口的样式？</h2><p>只需要给我们的Activity配置如下属性即可<code>android:theme=&quot;@android:style/Theme.Dialog&quot;</code>。</p><h2 id="11-Activity之间的数据传递有哪些方式？"><a href="#11-Activity之间的数据传递有哪些方式？" class="headerlink" title="11. Activity之间的数据传递有哪些方式？"></a>11. Activity之间的数据传递有哪些方式？</h2><ul><li><code>intent.putExtra()</code>方法；</li><li>使用全局变量Application；</li><li>使用静态变量；</li><li>剪切板ClipboardManager传递数据；</li><li>借助Application共享Handler利用消息处理机制；</li><li>使用Broadcast广播；</li><li>使用EventBus。</li></ul><h2 id="12-Fragment的好处："><a href="#12-Fragment的好处：" class="headerlink" title="12. Fragment的好处："></a>12. Fragment的好处：</h2><ul><li>Fragment可以使你能够将activity分离成多个可重用的组件，每个都有它自己的生命周期和UI。</li><li>Fragment可以轻松得创建动态灵活的UI设计，可以适应于不同的屏幕尺寸。从手机到平板电脑。</li><li>Fragment是一个独立的模块，紧紧地与activity绑定在一起。可以运行中动态地移除、加入、交换等。</li><li>Fragment提供一个新的方式让你在不同的安卓设备上统一你的UI。</li><li>Fragment解决Activity间的切换不流畅，轻量切换。</li><li>Fragment替代TabActivity做导航，性能更好。</li><li>Fragment在Android 4.2中新增嵌套fragment使用方法，能够生成更好的界面效果。</li></ul><h2 id="13-Intent的原理，作用，可以传递哪些类型的参数？"><a href="#13-Intent的原理，作用，可以传递哪些类型的参数？" class="headerlink" title="13. Intent的原理，作用，可以传递哪些类型的参数？"></a>13. Intent的原理，作用，可以传递哪些类型的参数？</h2><ul><li>Intent是连接Activity、Service、BroadcastReceiver和ContentProvider四大组件的信使，可以传递八种基本数据类型以及<code>String</code>、<code>Bundle</code>类型，以及实现了<code>Serializable</code>或者<code>Parcelable</code>的类型。</li><li><p>Intent可以划分成显式意图和隐式意图。</p><ul><li>显式意图：调用<code>Intent.setComponent()</code>或<code>Intent.setClass()</code>方法明确指定了组件名的Intent为显式意图，显式意图明确指定了Intent应该传递给哪个组件。</li><li>隐式意图：没有明确指定组件名的Intent为隐式意图。Android系统会根据隐式意图中设置的动作（<code>action</code>）、类别（<code>category</code>）、数据（URI和数据类型）找到最合适的组件来处理这个意图。</li></ul></li></ul><h2 id="14-Intent的主要使用方法"><a href="#14-Intent的主要使用方法" class="headerlink" title="14. Intent的主要使用方法"></a>14. Intent的主要使用方法</h2><h3 id="14-1-启动-Activity"><a href="#14-1-启动-Activity" class="headerlink" title="14.1. 启动 Activity"></a>14.1. 启动 Activity</h3><p>Activity表示应用中的一个屏幕。通过将Intent传递给<code>startActivity()</code>，您可以启动新的 Activity实例。Intent描述了要启动的Activity，并携带了任何必要的数据。</p><p>如果您希望在Activity完成后收到结果，请调用<code>startActivityForResult()</code>。在 Activity的<code>onActivityResult()</code>回调中，您的Activity将结果作为单独的Intent对象接收。</p><h3 id="14-2-启动服务"><a href="#14-2-启动服务" class="headerlink" title="14.2. 启动服务"></a>14.2. 启动服务</h3><p>Service是一个不使用用户界面而在后台执行操作的组件。通过将Intent传递给<code>startService()</code>，您可以启动服务执行一次性操作（例如，下载文件）。Intent描述了要启动的服务，并携带了任何必要的数据。</p><p>如果服务旨在使用客户端——服务器接口，则通过将Intent传递给<code>bindService(</code>)，您可以从其他组件绑定到此服务。</p><h3 id="14-3-传递广播"><a href="#14-3-传递广播" class="headerlink" title="14.3. 传递广播"></a>14.3. 传递广播</h3><p>广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将Intent传递给<code>sendBroadcast()</code>、<code>sendOrderedBroadcast()</code>或<code>sendStickyBroadcast()</code>，您可以将广播传递给其他应用。</p><h2 id="15-Intent包含哪些信息"><a href="#15-Intent包含哪些信息" class="headerlink" title="15. Intent包含哪些信息"></a>15. Intent包含哪些信息</h2><ul><li>组件名称：要启动的组件名称。</li><li>操作：指定要执行的通用操作（例如，“查看”或“选取”）的字符串。</li><li>数据：引用待操作数据和／或该数据MIME类型的URI（Uri对象）。提供的数据类型通常由Intent的操作决定。例如，如果操作是<code>ACTION_EDIT</code>，则数据应包含待编辑文档的URI。</li><li>类别：一个包含应处理Intent组件类型的附加信息的字符串。</li><li>Extra：携带完成请求操作所需的附加信息的键值对。</li><li>标志：在Intent类中定义的、充当Intent元数据的标志。</li></ul><h2 id="16-什么是Intent过滤器"><a href="#16-什么是Intent过滤器" class="headerlink" title="16. 什么是Intent过滤器"></a>16. 什么是Intent过滤器</h2><p>要公布应用可以接收哪些隐式Intent，请在清单文件中使用<code>&lt;intent-filter&gt;</code>元素为每个应用组件声明一个或多个Intent过滤器。每个Intent过滤器均由应用清单文件中的<code>&lt;intent-filter&gt;</code>元素定义，并嵌套在相应的应用组件（例如，<code>&lt;activity&gt;</code>元素）中。在<code>&lt;intent-filter&gt;</code>内部，您可以使用以下三个元素中的一个或多个指定要接受的Intent类型：</p><ul><li><code>&lt;action&gt;</code>：在<code>name</code>属性中，声明接受的Intent操作。该值必须是操作的文本字符串值，而不是类常量。</li><li><code>&lt;data&gt;</code>：使用一个或多个指定数据URI各个方面（scheme、host、port、path等）和MIME类型的属性，声明接受的数据类型。</li><li><code>&lt;category&gt;</code>：在<code>name</code>属性中，声明接受的Intent类别。该值必须是操作的文本字符串值，而不是类常量。</li></ul><h2 id="17-Service的启动方式"><a href="#17-Service的启动方式" class="headerlink" title="17. Service的启动方式"></a>17. Service的启动方式</h2><ul><li><code>startService()</code>：只是启动Service，Activity和Service并没有绑定，只有当Service调用<code>stopService()</code>服务才会终止。</li><li><code>bindService()</code>：这种启动方式Activity和Service进行了绑定，启动Service的组件可以通过回调获取Service的代理对象和Service交互；当启动方销毁时，Service也会自动进行<code>unBind()</code>操作，当发现所有绑定都进行了<code>unBind()</code>时才会销毁Service。</li></ul><h2 id="18-Service的生命周期"><a href="#18-Service的生命周期" class="headerlink" title="18. Service的生命周期"></a>18. Service的生命周期</h2><p><img src="/2018/12/31/11/images/service_lifecycle.png" alt="service lifecycle"></p><h2 id="19-Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？"><a href="#19-Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？" class="headerlink" title="19. Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？"></a>19. Activity怎么和Service绑定，怎么在Activity中启动自己对应的Service？</h2><ul><li>Activity通过<code>bindService(Intent service，ServiceConnection conn，int flags)</code>跟Service进行绑定，当绑定成功的时候Service会将代理对象通过回调的形式传给<code>conn</code>，这样我们就拿到了Service提供的服务代理对象。</li><li>在Activity中可以通过<code>startService()</code>和<code>bindService()</code>方法启动Service。一般情况下如果想获取Service的服务对象那么肯定需要通过<code>bindService()</code>方法，比如音乐播放器，第三方支付等。如果仅仅只是为了开启一个后台任务那么可以使用<code>startService()</code>方法。</li></ul><h2 id="20-允许绑定的已启动服务的生命周期"><a href="#20-允许绑定的已启动服务的生命周期" class="headerlink" title="20. 允许绑定的已启动服务的生命周期"></a>20. 允许绑定的已启动服务的生命周期</h2><p>当服务与所有客户端之间的绑定全部取消时，Android系统便会销毁服务。不过，如果您选择实现<code>onStartCommand()</code>回调方法，则您必须显式停止服务，因为系统现在已将服务视为已启动。在此情况下，服务将一直运行到其通过<code>stopSelf()</code>自行停止，或其他组件调用<code>stopService()</code>为止，无论其是否绑定到任何客户端。</p><p>此外，如果您的服务已启动并接受绑定，则当系统调用您的<code>onUnbind()</code>方法时，如果您想在客户端下一次绑定到服务时接收<code>onRebind()</code>调用，则可选择返回true。<code>onRebind()</code>返回空值，但客户端仍在其<code>onServiceConnected()</code>回调中接收IBinder。</p><p><img src="/2018/12/31/11/images/service_binding_tree_lifecycle.png" alt="service binding tree lifecycle"></p><h2 id="21-Service中可以弹Toast吗？"><a href="#21-Service中可以弹Toast吗？" class="headerlink" title="21. Service中可以弹Toast吗？"></a>21. Service中可以弹Toast吗？</h2><ul><li>这个问题其实就是问一下Service是执行在UI线程中吗？类似的问题还有”Service的<code>onCreate()</code>回调函数可以做耗时的操作吗？”，”Service是否在main thread中执行”，”Service和Activity在同一个线程吗？”等；</li><li>我们要牢记一句真理”默认情况下四大组件都是在UI线程中执行的”，Service本身就是Context的子类，我们可以获取到Context对象，所以Service中当然可以弹Toast，同理，Service的<code>onCreate()</code>回调函数不可以做耗时的操作。</li></ul><h2 id="22-进程的优先级"><a href="#22-进程的优先级" class="headerlink" title="22. 进程的优先级"></a>22. 进程的优先级</h2><h3 id="22-1-前台进程"><a href="#22-1-前台进程" class="headerlink" title="22.1. 前台进程"></a>22.1. 前台进程</h3><p>用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</p><ul><li>托管用户正在交互的Activity（已调用Activity的<code>onResume()</code>方法）；</li><li>托管某个Service，后者绑定到用户正在交互的Activity；</li><li>托管正在”前台”运行的Service（服务已调用<code>startForeground()</code>）；</li><li>托管正执行一个生命周期回调的Service（<code>onCreate()</code>、<code>onStart()</code>或<code>onDestroy()</code>）；</li><li>托管正执行其<code>onReceive()</code>方法的BroadcastReceiver。</li></ul><p>通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</p><h3 id="22-2-可视进程"><a href="#22-2-可视进程" class="headerlink" title="22.2. 可视进程"></a>22.2. 可视进程</h3><p>没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。如果一个进程满足以下任一条件，即视为可见进程：</p><ul><li>托管不在前台、但仍对用户可见的Activity（已调用其<code>onPause()</code>方法）。例如，如果前台Activity启动了一个对话框，允许在其后显示上一Activity，则有可能会发生这种情况。</li><li>托管绑定到可见（或前台）Activity的Service。</li></ul><p>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p><h3 id="22-3-服务进程"><a href="#22-3-服务进程" class="headerlink" title="22.3. 服务进程"></a>22.3. 服务进程</h3><p>正在运行已使用<code>startService()</code>方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p><h3 id="22-4-后台进程"><a href="#22-4-后台进程" class="headerlink" title="22.4. 后台进程"></a>22.4. 后台进程</h3><p>包含目前对用户不可见的Activity的进程（已调用Activity的<code>onStop()</code>方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。通常会有很多后台进程在运行，因此它们会保存在LRU（最近最少使用）列表中，以确保包含用户最近查看的Activity的进程最后一个被终止。如果某个Activity正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该Activity时，Activity会恢复其所有可见状态。</p><h3 id="22-5-空进程"><a href="#22-5-空进程" class="headerlink" title="22.5. 空进程"></a>22.5. 空进程</h3><p>不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p><h2 id="23-IntentService如何工作？"><a href="#23-IntentService如何工作？" class="headerlink" title="23. IntentService如何工作？"></a>23. IntentService如何工作？</h2><ul><li>创建默认的工作线程，用于在应用的主线程外执行传递给<code>onStartCommand()</code>的所有Intent。</li><li>创建工作队列，用于将Intent逐一传递给<code>onHandleIntent()</code>实现，这样您就永远不必担心多线程问题。</li><li>在处理完所有启动请求后停止服务，因此您永远不必调用<code>stopSelf()</code>。</li><li>提供<code>onBind()</code>的默认实现（返回<code>null</code>）。</li><li>提供<code>onStartCommand()</code>的默认实现，可将Intent依次发送到工作队列和<code>onHandleIntent()</code>实现。</li></ul><h2 id="24-IntentService与Service的区别？"><a href="#24-IntentService与Service的区别？" class="headerlink" title="24. IntentService与Service的区别？"></a>24. IntentService与Service的区别？</h2><ul><li>Service也不是专门一条新线程，因此不应该在Service中直接处理耗时的任务；</li><li>Service不会专门启动一条单独的进程，Service与它所在应用位于同一个进程中；</li><li>IntentService是Service的子类，是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题；</li><li>IntentService会创建独立的worker线程来处理所有的Intent请求；</li><li>IntentService不会阻塞UI线程，而普通Serveice会导致ANR异常；</li><li>Intentservice若未执行完成上一次的任务，将不会新开一个线程，是等待之前的任务完成后，再执行新的任务，等任务完成后再次调用<code>stopSelf()</code>；</li><li>正在运行的IntentService的程序相比起纯粹的后台程序更不容易被系统杀死，该程序的优先级是介于前台程序与纯后台程序之间的。</li></ul><h2 id="25-Android-Service与Activity之间的通信方式？"><a href="#25-Android-Service与Activity之间的通信方式？" class="headerlink" title="25. Android Service与Activity之间的通信方式？"></a>25. Android Service与Activity之间的通信方式？</h2><ul><li><p>通过Binder对象：当Activity通过调用<code>bindService(Intent service，ServiceConnection conn，int flags)</code>，得到一个Service的一个对象，通过这个对象我们可以直接访问Service中的方法。</p><ul><li>添加一个继承Binder的内部类，并添加相应的逻辑方法。</li><li>重写Service的<code>onBind()</code>方法，返回我们刚刚定义的那个内部类实。</li><li>Activity中创建一个ServiceConnection的匿名内部类，并且重写里面的<code>onServiceConnected()</code>方法和<code>onServiceDisconnected()</code>方法，这两个方法分别会在活动与服务成功绑定以及解除绑定的时候调用，在<code>onServiceConnected()</code>方法中，我们可以得到一个刚才那个service的binder对象，通过对这个binder对象进行向下转型，得到我们那个自定义的Binder实例，有了这个实例，做可以调用这个实例里面的具体方法进行需要的操作了。</li></ul></li><li><p>通过Broadcast Receiver：当我们的进度发生变化的时候我们发送一条广播，然后在Activity的注册广播接收器，接收到广播之后更新视图</p></li><li><p>EventBus</p></li></ul><h2 id="26-BroadcastReceiver简介"><a href="#26-BroadcastReceiver简介" class="headerlink" title="26. BroadcastReceiver简介"></a>26. BroadcastReceiver简介</h2><p>在Android中，Broadcast是一种广泛运用的在应用程序之间传输信息的机制。</p><h3 id="26-1-用途"><a href="#26-1-用途" class="headerlink" title="26.1. 用途"></a>26.1. 用途</h3><ul><li>实现了不同的程序之间的数据传输与共享，因为只要是和发送广播的<code>action</code>相同的接受者都能接受这个广播。典型的应用就是Android自带的短信，电话等等广播，只要我们实现了他们的<code>action</code>的广播，那么我们就能接收他们的数据了，以便做出一些处理。比如说拦截系统短信，拦截骚扰电话等。</li><li>起到了一个通知的作用，比如在Service中要通知主程序，更新主程序的UI等。因为Service是没有界面的，所以不能直接获得主程序中的控件，这样我们就只能在主程序中实现一个广播接受者专门用来接受Service发过来的数据和通知了。</li></ul><h3 id="26-2-使用场景"><a href="#26-2-使用场景" class="headerlink" title="26.2. 使用场景"></a>26.2. 使用场景</h3><ul><li>同一app内部的同一组件内的消息通信（单个或多个线程之间）；</li><li>同一app内部的不同组件之间的消息通信（单个进程）；</li><li>同一app具有多个进程的不同组件之间的消息通信；</li><li>不同app之间的组件之间消息通信；</li><li>Android系统在特定情况下与App之间的消息通信。</li></ul><h3 id="26-3-实现原理"><a href="#26-3-实现原理" class="headerlink" title="26.3. 实现原理"></a>26.3. 实现原理</h3><p>从实现原理看上，Android中的广播使用了观察者模式，基于消息的发布/订阅事件模型。因此，从实现的角度来看，Android中的广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。具体实现流程要点粗略概括如下：</p><ol><li>广播接收者BroadcastReceiver通过Binder机制向AMS（Activity Manager Service)进行注册；</li><li>广播发送者通过binder机制向AMS发送广播；</li><li>AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；</li><li>消息循环执行拿到此广播，回调BroadcastReceiver中的<code>onReceive()</code>方法。</li></ol><h3 id="26-4-注册方式"><a href="#26-4-注册方式" class="headerlink" title="26.4. 注册方式"></a>26.4. 注册方式</h3><ul><li>静态注册；</li><li>动态注册。</li></ul><h2 id="27-为什么要用ContentProvider？它和SQL的实现上有什么差别？"><a href="#27-为什么要用ContentProvider？它和SQL的实现上有什么差别？" class="headerlink" title="27. 为什么要用ContentProvider？它和SQL的实现上有什么差别？"></a>27. 为什么要用ContentProvider？它和SQL的实现上有什么差别？</h2><ul><li>ContentProvider屏蔽了数据存储的细节，内部实现对用户完全透明，用户只需要关心操作数据的uri就可以了，ContentProvider可以实现不同app之间共享。SQL只能在该工程的内部共享数据，ContentProvider能在工程之间实现数据共享。</li><li>SQL也有增删改查的方法，但是SQL只能查询本应用下的数据库。而ContentProvider还可以去增删改查本地文件.xml文件的读取等。</li></ul><h2 id="28-ContentProvider怎么实现数据共享？"><a href="#28-ContentProvider怎么实现数据共享？" class="headerlink" title="28. ContentProvider怎么实现数据共享？"></a>28. ContentProvider怎么实现数据共享？</h2><p>一个程序可以通过实现一个ContentProvider的抽象接口将自己的数据完全暴露出去，而且ContentProvider是以类似数据库中表的方式将数据暴露。ContentProvider存储和检索数据，通过它可以让所有的应用程序访问到，这也是应用程序之间唯一共享数据的方法。要想使应用程序的数据公开化，可通过2种方法：创建一个属于你自己的Content provider或者将你的数据添加到一个已经存在的ContentProvider中，前提是有相同数据类型并且有写入ContentProvider的权限。</p><h2 id="29-Android如何访问自定义ContentProvider"><a href="#29-Android如何访问自定义ContentProvider" class="headerlink" title="29. Android如何访问自定义ContentProvider"></a>29. Android如何访问自定义ContentProvider</h2><ol><li>得到ContentResolver类对象：<code>ContentResolver cr = getContentResolver()</code>；</li><li>定义要查询的字段<code>String</code>数组；</li><li>使用<code>cr.query()</code>返回一个<code>Cursor</code>对象；</li><li>使用<code>while</code>循环得到<code>Cursor</code>里面的内容。</li></ol><h2 id="30-Android中Activity，Intent，Content-Provider，Service各有什么区别。"><a href="#30-Android中Activity，Intent，Content-Provider，Service各有什么区别。" class="headerlink" title="30. Android中Activity，Intent，Content Provider，Service各有什么区别。"></a>30. Android中Activity，Intent，Content Provider，Service各有什么区别。</h2><ul><li>Activity：活动，是最基本的Android应用程序组件。一个活动就是一个单独的屏幕，每一个活动都被实现为一个独立的类，并且从活动基类继承而来。</li><li>Intent：意图，描述应用想干什么。最重要的部分是动作和动作对应的数据。</li><li>Content Provider：内容提供器，Android应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当你想将你的应用数据和其他应用共享时，内容提供器就可以发挥作用了。</li><li>Service：服务，具有一段较长生命周期且没有用户界面的程序。</li></ul><h2 id="31-Android数据存储方式？"><a href="#31-Android数据存储方式？" class="headerlink" title="31. Android数据存储方式？"></a>31. Android数据存储方式？</h2><ul><li>SharedPreferences：以键值对的形式保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。</li><li>文件存储数据：Context提供了两个方法来打开数据文件里的文件IO流<code>FileInputStream openFileInput(String name)</code>，<code>FileOutputStream(String name，int mode)</code>，这两个方法第一个参数用于指定文件名，第二个参数指定打开文件的模式；文件默认存储位置：<code>/data/data/包名/files/文件名</code>。</li><li>SQLite存储数据。</li><li>使用ContentProvider存储数据。</li><li>网络存储数据。</li></ul><h2 id="32-Android中常用的布局都有哪些？"><a href="#32-Android中常用的布局都有哪些？" class="headerlink" title="32. Android中常用的布局都有哪些？"></a>32. Android中常用的布局都有哪些？</h2><ul><li>FrameLayout；</li><li>RelativeLayout；</li><li>LinearLayout；</li><li>AbsoluteLayout；</li><li>TableLayout；</li><li>GridLayout。</li></ul><h2 id="33-android-layout-gravity和android-gravity的区别？"><a href="#33-android-layout-gravity和android-gravity的区别？" class="headerlink" title="33. android:layout_gravity和android:gravity的区别？"></a>33. <code>android:layout_gravity</code>和<code>android:gravity</code>的区别？</h2><ul><li><code>android:layout_gravity</code>是让该布局在其父控件中的布局方式。</li><li><code>android:gravity</code>是该布局布置其子对象的布局方式。</li></ul><h2 id="34-Android平台架构"><a href="#34-Android平台架构" class="headerlink" title="34. Android平台架构"></a>34. Android平台架构</h2><p><img src="/2018/12/31/11/images/android_platform.png" alt="android platform"></p><h3 id="34-1-系统应用"><a href="#34-1-系统应用" class="headerlink" title="34.1. 系统应用"></a>34.1. 系统应用</h3><p>Android随附一套用于电子邮件、短信、日历、互联网浏览和联系人等的核心应用。平台随附的应用与用户可以选择安装的应用一样，没有特殊状态。因此第三方应用可成为用户的默认网络浏览器、短信Messenger甚至默认键盘（有一些例外，例如系统的”设置”应用）。</p><p>系统应用可用作用户的应用，以及提供开发者可从其自己的应用访问的主要功能。例如，如果您的应用要发短信，您无需自己构建该功能，可以改为调用已安装的短信应用向您指定的接收者发送消息。</p><h3 id="34-2-Java-API框架"><a href="#34-2-Java-API框架" class="headerlink" title="34.2. Java API框架"></a>34.2. Java API框架</h3><p>您可通过以Java语言编写的API使用Android OS的整个功能集。这些API形成创建Android应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务：</p><ul><li>丰富、可扩展的视图系统，可用以构建应用的UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器；</li><li>资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件；</li><li>通知管理器，可让所有应用在状态栏中显示自定义提醒；</li><li>Activity管理器，用于管理应用的生命周期，提供常见的导航返回栈；</li><li>内容提供程序，可让应用访问其他应用（例如”联系人”应用）中的数据或者共享其自己的数据。</li></ul><p>开发者可以完全访问Android系统应用使用的框架API。</p><h3 id="34-3-原生C-C-库"><a href="#34-3-原生C-C-库" class="headerlink" title="34.3. 原生C/C++库"></a>34.3. 原生C/C++库</h3><p>许多核心Android系统组件和服务（例如ART和HAL）构建自原生代码，需要以C和C++编写的原生库。Android平台提供Java框架API以向应用显示其中部分原生库的功能。例如，您可以通过Android框架的Java OpenGL API访问OpenGL ES，以支持在应用中绘制和操作2D和3D图形。</p><p>如果开发的是需要C或C++代码的应用，可以使用Android NDK直接从原生代码访问某些原生平台库。</p><h3 id="34-4-Android-Runtime"><a href="#34-4-Android-Runtime" class="headerlink" title="34.4. Android Runtime"></a>34.4. Android Runtime</h3><p>对于运行Android 5.0（API级别21）或更高版本的设备，每个应用都在其自己的进程中运行，并且有其自己的Android Runtime(ART)实例。ART编写为通过执行DEX文件在低内存设备上运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如Jack）将Java源代码编译为DEX字节码，使其可在Android平台上运行。</p><p>ART的部分主要功能包括：</p><ul><li>预先（AOT）和即时（JIT）编译；</li><li>优化的垃圾回收（GC）；</li><li>更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置监视点以监控特定字段；</li></ul><p>在Android版本5.0（API级别21）之前，Dalvik是Android Runtime。如果您的应用在ART上运行效果很好，那么它应该也可在Dalvik上运行，但反过来不一定。</p><p>Android还包含一套核心运行时库，可提供Java API框架使用的Java编程语言大部分功能，包括一些Java 8语言功能。</p><h3 id="34-5-硬件抽象层（HAL）"><a href="#34-5-硬件抽象层（HAL）" class="headerlink" title="34.5. 硬件抽象层（HAL）"></a>34.5. 硬件抽象层（HAL）</h3><p>硬件抽象层（HAL）提供标准界面，向更高级别的Java API框架显示设备硬件功能。HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当框架API要求访问设备硬件时，Android系统将为该硬件组件加载库模块。</p><h3 id="34-6-Linux-内核"><a href="#34-6-Linux-内核" class="headerlink" title="34.6. Linux 内核"></a>34.6. Linux 内核</h3><p>Android平台的基础是Linux内核。例如，Android Runtime（ART）依靠Linux内核来执行底层功能，例如线程和低层内存管理。</p><p>使用Linux内核可让Android利用主要安全功能，并且允许设备制造商为著名的内核开发硬件驱动程序。</p><h2 id="35-Fragment生命周期"><a href="#35-Fragment生命周期" class="headerlink" title="35. Fragment生命周期"></a>35. Fragment生命周期</h2><p><img src="/2018/12/31/11/images/fragment_lifecycle.png" alt="fragment lifecycle"></p><ul><li><code>onCreate()</code>：系统会在创建片段时调用此方法。您应该在实现内初始化您想在片段暂停或停止后恢复时保留的必需片段组件。</li><li><code>onCreateView()</code>：系统会在片段首次绘制其用户界面时调用此方法。要想为您的片段绘制UI，您从此方法中返回的View必须是片段布局的根视图。如果片段未提供UI，您可以返回<code>null</code>。</li><li><code>onPause()</code>：系统将此方法作为用户离开片段的第一个信号（但并不总是意味着此片段会被销毁）进行调用。您通常应该在此方法内确认在当前用户会话结束后仍然有效的任何更改（因为用户可能不会返回）。</li></ul><h2 id="36-Activity生命周期对片段生命周期的影响"><a href="#36-Activity生命周期对片段生命周期的影响" class="headerlink" title="36. Activity生命周期对片段生命周期的影响"></a>36. Activity生命周期对片段生命周期的影响</h2><p><img src="/2018/12/31/11/images/activity_fragment_lifecycle.png" alt="activity fragment lifecycle"></p><p>片段所在的Activity的生命周期会直接影响片段的生命周期，其表现为，Activity的每次生命周期回调都会引发每个片段的类似回调。例如，当Activity收到<code>onPause()</code>时，Activity中的每个片段也会收到<code>onPause()</code>。</p><p>不过，片段还有几个额外的生命周期回调，用于处理与Activity的唯一交互，以执行构建和销毁片段UI等操作。这些额外的回调方法是：</p><ul><li><code>onAttach()</code>：在片段已与Activity关联时调用（Activity传递到此方法内）；</li><li><code>onCreateView()</code>：调用它可创建与片段关联的视图层次结构；</li><li><code>onActivityCreated()</code>：在Activity的<code>onCreate()</code>方法已返回时调用；</li><li><code>onDestroyView()</code>：在移除与片段关联的视图层次结构时调用；</li><li><code>onDetach()</code>：在取消片段与Activity的关联时调用。</li></ul><h2 id="37-Android事件分发"><a href="#37-Android事件分发" class="headerlink" title="37. Android事件分发"></a>37. Android事件分发</h2><table><thead><tr><th style="text-align:center">事件相关方法</th><th style="text-align:center">方法功能</th><th style="text-align:center">Activity</th><th style="text-align:center">ViewGroup</th><th style="text-align:center">View</th></tr></thead><tbody><tr><td style="text-align:center"><code>dispatchTouchEvent</code></td><td style="text-align:center">事件分发</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr><tr><td style="text-align:center"><code>onInterceptTouchEvent</code></td><td style="text-align:center">事件拦截</td><td style="text-align:center">No</td><td style="text-align:center">Yes</td><td style="text-align:center">No</td></tr><tr><td style="text-align:center"><code>onTouchEvent</code></td><td style="text-align:center">事件消费</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td><td style="text-align:center">Yes</td></tr></tbody></table><h3 id="37-1-public-boolean-dispatchTouchEvent-MotionEvent-ev"><a href="#37-1-public-boolean-dispatchTouchEvent-MotionEvent-ev" class="headerlink" title="37.1. public boolean dispatchTouchEvent(MotionEvent ev)"></a>37.1. <code>public boolean dispatchTouchEvent(MotionEvent ev)</code></h3><p>当有监听到事件时，首先由Activity进行捕获，进入事件分发处理流程。（因为activity没有事件拦截，View和ViewGroup有）会将事件传递给最外层View的<code>dispatchTouchEvent(MotionEvent ev)</code>方法，该方法对事件进行分发。</p><ul><li><code>return true</code>：表示该View内部消化掉了所有事件。</li><li><code>return false</code>：事件在本层不再继续进行分发，并交由上层控件的<code>onTouchEvent()</code>方法进行消费（如果本层控件已经是Activity，那么事件将被系统消费或处理）。</li><li>如果事件分发返回系统默认的<code>super.dispatchTouchEvent(ev)</code>，事件将分发给本层的事件拦截<code>onInterceptTouchEvent()</code>方法进行处理。</li></ul><h3 id="37-2-public-boolean-onInterceptTouchEvent-MotionEvent-ev"><a href="#37-2-public-boolean-onInterceptTouchEvent-MotionEvent-ev" class="headerlink" title="37.2. public boolean onInterceptTouchEvent(MotionEvent ev)"></a>37.2. <code>public boolean onInterceptTouchEvent(MotionEvent ev)</code></h3><ul><li><code>return true</code>：表示将事件进行拦截，并将拦截到的事件交由本层控件的<code>onTouchEvent()</code>进行处理。</li><li><code>return false</code>：则表示不对事件进行拦截，事件得以成功分发到子View。并由子View的<code>dispatchTouchEvent()</code>进行处理。</li><li>如果返回<code>super.onInterceptTouchEvent(ev)</code>，默认表示拦截该事件，并将事件传递给当前View的<code>onTouchEvent()</code>方法，和<code>return true</code>一样。</li></ul><h3 id="37-3-public-boolean-onTouchEvent-MotionEvent-ev"><a href="#37-3-public-boolean-onTouchEvent-MotionEvent-ev" class="headerlink" title="37.3. public boolean onTouchEvent(MotionEvent ev)"></a>37.3. <code>public boolean onTouchEvent(MotionEvent ev)</code></h3><p>在<code>dispatchTouchEvent()</code>（事件分发）返回<code>super.dispatchTouchEvent(ev)</code>并且<code>onInterceptTouchEvent()</code>（事件拦截返回<code>true</code>或<code>super.onInterceptTouchEvent(ev)</code>的情况下，那么事件会传递到<code>onTouchEvent()</code>方法，该方法对事件进行响应。</p><ul><li>如果<code>return true</code>，表示<code>onTouchEvent()</code>处理完事件后消费了此次事件。此时事件终结。</li><li>如果<code>return fasle</code>，则表示不响应事件，那么该事件将会不断向上层View的<code>onTouchEvent()</code>方法传递，直到某个View的<code>onTouchEvent()</code>方法返回<code>true</code>，如果到了最顶层View还是返回<code>false</code>，那么认为该事件不消耗，则在同一个事件系列中，当前View无法再次接收到事件，该事件会交由Activity的<code>onTouchEvent()</code>进行处理。</li><li>如果<code>return super.dispatchTouchEvent(ev)</code>，则表示不响应事件，结果与<code>return false</code>一样。</li></ul><p><img src="/2018/12/31/11/images/touch_eventbus.gif" alt="touch eventbus"></p><ul><li>如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的<code>onTouchEvent()</code>不会被触发。</li><li>可以通过复写<code>onInterceptTouchEvent(ev)</code>方法，拦截子View的事件（即<code>return true</code>），把事件交给自己处理，则会执行自己对应的<code>onTouchEvent()</code>方法。</li><li>子View可以通过调用<code>getParent().requestDisallowInterceptTouchEvent(true)</code>阻止ViewGroup对其<code>MOVE</code>或者<code>UP</code>事件进行拦截。</li><li>一个点击事件产生后，它的传递过程如下：Activity-&gt;Window-&gt;View。顶级View接收到事件之后，就会按相应规则去分发事件。如果一个View的<code>onTouchEvent()</code>方法返回<code>false</code>，那么将会交给父容器的<code>onTouchEvent()</code>方法进行处理，逐级往上，如果所有的View都不处理该事件，则交由Activity的<code>onTouchEvent()</code>进行处理。</li><li>如果某一个View开始处理事件，如果他不消耗<code>ACTION_DOWN</code>事件（也就是<code>onTouchEvent()</code>返回<code>false</code>），则同一事件序列比如接下来进行<code>ACTION_MOVE</code>，则不会再交给该View处理。</li><li>ViewGroup默认不拦截任何事件。</li><li>诸如TextView、ImageView这些不作为容器的View，一旦接受到事件，就调用<code>onTouchEvent()</code>方法，它们本身没有<code>onInterceptTouchEvent()</code>方法。正常情况下，它们都会消耗事件（返回<code>true</code>），除非它们是不可点击的（<code>clickable</code>和<code>longClickable</code>都为<code>false</code>），那么就会交由父容器的<code>onTouchEvent()</code>处理。</li><li>点击事件分发过程如下<code>dispatchTouchEvent()</code> —&gt; <code>OnTouchListener</code>的<code>onTouch()</code>方法 —&gt; <code>onTouchEvent()</code> –&gt; <code>OnClickListener</code>的<code>onClick()</code>方法。也就是说，我们平时调用的<code>setOnClickListener()</code>，优先级是最低的，所以，<code>onTouchEvent()</code>或<code>OnTouchListener()</code>的<code>onTouch()</code>方法如果返回<code>true</code>，则不响应<code>onClick()</code>方法。</li></ul><p>参考：<a href="https://github.com/Mr-YangCheng/ForAndroidInterview/blob/master/android/Android%20View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">ForAndroidInterview/Android View事件分发机制源码分析.md at master · Mr-YangCheng/ForAndroidInterview</a></p><p>参考：<a href="https://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html" target="_blank" rel="noopener">Android 编程下 Touch 事件的分发和消费机制 - sunzn - 博客园</a></p><h2 id="38-Android系统启动过程"><a href="#38-Android系统启动过程" class="headerlink" title="38. Android系统启动过程"></a>38. Android系统启动过程</h2><p><img src="/2018/12/31/11/images/android_boot_process.png" alt="android boot process"></p><h3 id="38-1-Boot-ROM"><a href="#38-1-Boot-ROM" class="headerlink" title="38.1. Boot ROM"></a>38.1. Boot ROM</h3><p>Android设备上电后，首先会从处理器片上ROM的启动引导代码开始执行，片上ROM会寻找Bootloader代码，并加载到内存。</p><h3 id="38-2-Boot-Loader"><a href="#38-2-Boot-Loader" class="headerlink" title="38.2. Boot Loader"></a>38.2. Boot Loader</h3><p>BootLoader是在操作系统内核运行之前运行。可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。</p><h3 id="38-3-Kernel"><a href="#38-3-Kernel" class="headerlink" title="38.3. Kernel"></a>38.3. Kernel</h3><p>Android内核启动时，会设置缓存、被保护存储器、计划列表，加载驱动。当内核完成系统设置，它首先在系统文件中寻找”init”文件，然后启动root进程或者系统的第一个进程。</p><h3 id="38-4-init"><a href="#38-4-init" class="headerlink" title="38.4. init"></a>38.4. init</h3><p>init进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。init始终是第一个进程。</p><p>init程序最核心的工作主要有3点：</p><ul><li>创建和挂载一些系统目录/设备节点，设置权限，如：<code>/dev</code>，<code>/proc</code>，和<code>/sys</code>；</li><li>解析init.rc，并启动属性服务，以及一系列的服务和进程；</li><li>显示boot logo，默认是”Android”字样。</li></ul><p>第二步的这些服务包含2部分，一部分是本地服务，另一部分是Android服务，所有的这些服务都会向ServiceManager进程注册，由它统一管理，这些服务的启动过程介绍如下：</p><h4 id="38-4-1-本地服务"><a href="#38-4-1-本地服务" class="headerlink" title="38.4.1. 本地服务"></a>38.4.1. 本地服务</h4><p>本地服务是指运行在C++层的系统守护进程，一部分本地服务是init进程直接启动的，它们定义在init.rc脚本中，如ueventd、servicemanager、debuggerd、rild、mediaserver等。还有一部分本地服务，是由这些本地服务进一步创建的，如mediaserver服务会启动AudioFlinger，MediaPlayerService，以及CameraService等本地服务。</p><p>注意，每一个由init直接启动的本地服务都是一个独立的Linux进程，在系统启动以后，我们通过<code>adb shell</code>命令进入手机后，输入<code>top</code>命令就可以查看到这些本地进程的存在。</p><h4 id="38-4-2-Android服务"><a href="#38-4-2-Android服务" class="headerlink" title="38.4.2. Android服务"></a>38.4.2. Android服务</h4><p>init进程会执行app_process程序，创建Zygote进程，它是Android系统最重要的进程，所有后续的Android应用程序都是由它<code>fork</code>出来的。</p><p>Zygote进程会首先<code>fork</code>出SystemServer进程，SystemServer进程的全部任务就是将所有的Android核心服务启动起来。</p><h3 id="38-5-Zygote-and-Dalvik（ART）"><a href="#38-5-Zygote-and-Dalvik（ART）" class="headerlink" title="38.5. Zygote and Dalvik（ART）"></a>38.5. Zygote and Dalvik（ART）</h3><p>Zygote被init进程启动，开始运行和初始化dalvik虚拟机。</p><h3 id="38-6-System-Server"><a href="#38-6-System-Server" class="headerlink" title="38.6. System Server"></a>38.6. System Server</h3><p>系统服务是在系统中运行的第一个java组件，它会启动所有的Android服务，比如：电话服务，蓝牙服务，每个服务的启动被直接写在<code>SystemServer.java</code>这个类的<code>run()</code>方法里面。</p><h3 id="38-7-Boot-completed"><a href="#38-7-Boot-completed" class="headerlink" title="38.7. Boot completed"></a>38.7. Boot completed</h3><p>一旦系统服务启动并运行，Android系统启动就完成了，同时发出<code>ACTION_BOOT_COMPLETED</code>广播。</p><h2 id="39-Android应用启动过程"><a href="#39-Android应用启动过程" class="headerlink" title="39. Android应用启动过程"></a>39. Android应用启动过程</h2><ol><li>Launcher接收到点击事件，获取应用的信息，向SystemServer（ActivityManagerService简称AMS运行在里面）发起启动应用的请求；</li><li>SystemServer（AMS）请求Launcher Pause（Launcher需要保存状态进入后台）；</li><li>LauncherPause，向SystemServer（AMS）发送Pause完毕；</li><li>SystemServer（AMS）向Zygote请求启动一个新进程（calculator）；</li><li>Zygote fork出新进程（calculator），在新进程中执行ActivityThread类的<code>main()</code>方法；</li><li>calculator向SystemServer（AMS）请求attach到AMS；</li><li>SystemServer（AMS）请求calculator launch；</li><li>calculator调用<code>onCreate()</code>，<code>onResume()</code>回调；</li><li>calculator界面显示自屏幕上（还需细分）。</li></ol><p>参考：<a href="http://androidzhibinw.github.io/android/app/startup/activity/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/%E5%90%AF%E5%8A%A8/%E5%88%86%E6%9E%90/2015/09/21/android-app-startup-process/" target="_blank" rel="noopener">Android 应用程序启动过程分析</a></p><h2 id="40-dp，dip，dpi，ppi区别"><a href="#40-dp，dip，dpi，ppi区别" class="headerlink" title="40. dp，dip，dpi，ppi区别"></a>40. dp，dip，dpi，ppi区别</h2><p>px（Pixels，像素）：屏幕上的点。 in（Inch，英寸）：长度单位。 mm（Millimeter，毫米）：长度单位。 pt（Point，磅）：1/72in。 dpi（Dots Per Inch，每英寸所打印的点数）：1in长度的点数。 ppi（Pixels Per Inch，像素密度）：1in长度的像素点数。 dp/dip（Density-independent Pixels，与密度无关的像素）：一种基于屏幕密度的抽象单位。在160dpi的显示器上，1dp = 1px。 sp（Scale-independent Pixels，与刻度无关的像素）：与dp类似，但是可以根据用户的字体大小首选项进行缩放。</p><p>在屏幕密度为160dpi，1dp = 1px，1pt = 160/72sp，1pt = 1/72in。当屏幕密度为240dpi时，1dp = 1.5px。</p><p>参考：<a href="http://stackoverflow.com/questions/8478882/how-do-dp-dip-dpi-ppi-pixels-and-inches-relate" target="_blank" rel="noopener">mobile - How do dp, dip, dpi, ppi, pixels and inches relate? - Stack Overflow</a></p><h2 id="41-长度和字体的推荐单位"><a href="#41-长度和字体的推荐单位" class="headerlink" title="41. 长度和字体的推荐单位"></a>41. 长度和字体的推荐单位</h2><p>长度推荐dp（Density-independent Pixels），字号大小推荐sp（Scale-independent Pixels）。</p><h2 id="42-Android-View绘制流程"><a href="#42-Android-View绘制流程" class="headerlink" title="42. Android View绘制流程"></a>42. Android View绘制流程</h2><p><img src="/2018/12/31/11/images/android_draw_view_flow.png" alt="android_draw_view_flow"></p><p><img src="/2018/12/31/11/images/android_draw_view_chain.png" alt="android_draw_view_chain"></p><p>参考：<a href="https://github.com/android-cn/android-open-project-analysis/tree/master/tech/viewdrawflow" target="_blank" rel="noopener">android-open-project-analysis/tech/viewdrawflow at master · android-cn/android-open-project-analysis</a></p><p>参考：<a href="http://vincgao.com/2016/02/android-layout/" target="_blank" rel="noopener">Android Layout绘制</a></p><h2 id="43-ListView优化"><a href="#43-ListView优化" class="headerlink" title="43. ListView优化"></a>43. ListView优化</h2><ul><li>复用convertView：用以避免重复创建View，重复创建View代价较大，而且如果重用view不改变宽高，重用View可以减少重新分配缓存造成的内存频繁分配/回收。</li><li>使用View Holder模式：findViewById的实现是遍历，如果你定义的View越复杂代价越大。 Google推荐的做法是用ViewHolder，然后保存在view的tag中。现在RecyclerView也是强制使用ViewHolder了。</li><li>分批加载与分页加载相结合：不需要一次等待好几分钟把数据都加载完再在ListView上显示。</li><li>使用异步线程加载图片</li><li>在快速滑动时不要加载图片</li><li>使用RecyclerView</li></ul><h2 id="44-Android-Binder机制"><a href="#44-Android-Binder机制" class="headerlink" title="44. Android Binder机制"></a>44. Android Binder机制</h2><p><img src="/2018/12/31/11/images/binder_architecture.jpg" alt="binder architecture"></p><p><img src="/2018/12/31/11/images/binder_architecture_2.jpg" alt="binder architecture 2"></p><ol><li>Server进程启动之后，会进入中断等待状态，等待Client的请求。</li><li>当Client需要和Server通信时，会将请求发送给Binder驱动。</li><li>Binder驱动收到请求之后，会唤醒Server进程。</li><li>接着，Binder驱动还会反馈信息给Client，告诉Client：它发送给Binder驱动的请求，Binder驱动已经收到。</li><li>Client将请求发送成功之后，就进入等待状态。等待Server的回复。</li><li>Binder驱动唤醒Server之后，就将请求转发给Server进程。</li><li>Server进程解析出请求内容，并将回复内容发送给Binder驱动。</li><li>Binder驱动收到回复之后，唤醒Client进程。</li><li>接着，Binder驱动还会反馈信息给Server，告诉Server：它发送给Binder驱动的回复，Binder驱动已经收到。</li><li>Server将回复发送成功之后，再次进入等待状态，等待Client的请求。</li><li>最后，Binder驱动将回复转发给Client。</li></ol><h2 id="45-Binder机制优点"><a href="#45-Binder机制优点" class="headerlink" title="45. Binder机制优点"></a>45. Binder机制优点</h2><ul><li>性能：Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。</li><li>稳定性：Binder是基于C/S架构的，Server端与Client端相对独立，稳定性较好。</li><li>安全性：传统Linux IPC的接收方无法获得对方进程可靠的UID/PID，从而无法鉴别对方身份。Android系统中对外只暴露Client端，Client端将任务发送给Server端，Server端会根据权限控制策略，判断UID/PID是否满足访问权限，目前权限控制很多时候是通过弹出权限询问对话框，让用户选择是否运行。</li></ul><h2 id="46-AsyncTask简介"><a href="#46-AsyncTask简介" class="headerlink" title="46. AsyncTask简介"></a>46. AsyncTask简介</h2><p>包含4个方法：</p><ul><li><code>onPreExecute()</code>：UI线程；</li><li><code>doInBackground(Params...)</code>：非UI线程；</li><li><code>onProgressUpdate(Progress...)</code>：UI线程；</li><li><code>onPostExecute(Result)</code>：UI线程。</li></ul><p>原理：</p><ul><li>线程池；</li><li>单例模式；</li><li><code>mainLooper()</code>；</li><li>串行。</li></ul><h2 id="47-为什么Handler需要声明为static？"><a href="#47-为什么Handler需要声明为static？" class="headerlink" title="47. 为什么Handler需要声明为static？"></a>47. 为什么Handler需要声明为static？</h2><p>所有发送到消息队列的消息Message都会拥有一个对Handler的引用，在java里，非静态内部类和匿名类都会潜在的引用它们所属的外部类。但是，静态内部类却不会。当Activity结束（finish）时，里面的延时消息在得到处理前，会一直保存在主线程的消息队列里持续10分钟。这条消息持有对handler的引用，而handler又持有对其外部类（在这里，即SampleActivity）的潜在引用。这条引用关系会一直保持直到消息得到处理，从而，这阻止了SampleActivity被垃圾回收器回收，同时造成应用程序的泄漏。</p><h2 id="48-广播注册后不解除注册会有什么问题？"><a href="#48-广播注册后不解除注册会有什么问题？" class="headerlink" title="48. 广播注册后不解除注册会有什么问题？"></a>48. 广播注册后不解除注册会有什么问题？</h2><p>内存泄漏。系统会保留Receiver的引用。</p><h2 id="49-自定义View"><a href="#49-自定义View" class="headerlink" title="49. 自定义View"></a>49. 自定义View</h2><h3 id="49-1-实现步骤"><a href="#49-1-实现步骤" class="headerlink" title="49.1. 实现步骤"></a>49.1. 实现步骤</h3><ol><li>继承View类或其子类；</li><li>复写view中的一些函数；</li><li>为自定义View类增加属性（两种方式）；</li><li>绘制控件（导入布局）；</li><li>响应用户事件；</li><li>定义回调函数（根据自己需求来选择）。</li></ol><h2 id="50-需要被重写的方法"><a href="#50-需要被重写的方法" class="headerlink" title="50. 需要被重写的方法"></a>50. 需要被重写的方法</h2><ul><li><code>onDraw()</code>：view中<code>onDraw()</code>是个空函数，也就是说具体的视图都要覆写该函数来实现自己的绘制。对于ViewGroup则不需要实现该函数，因为作为容器是”没有内容”的（但必须实现<code>dispatchDraw()</code>函数，告诉子view绘制自己）。</li><li><code>onLayout()</code>：主要是为viewGroup类型布局子视图用的，在View中这个函数为空函数。</li><li><code>onMeasure()</code>：用于计算视图大小（即长和宽）的方式，并通过<code>setMeasuredDimension(width, height)</code>保存计算结果。</li><li><code>onTouchEvent()</code>：定义触屏事件来响应用户操作。</li></ul><h2 id="51-Parcelable和Serializable的区别"><a href="#51-Parcelable和Serializable的区别" class="headerlink" title="51. Parcelable和Serializable的区别"></a>51. Parcelable和Serializable的区别</h2><p>Serializable仅需实现Serializable接口。缺点是使用了反射，序列化的过程较慢。这种机制会在序列化的时候创建许多的临时对象，容易触发垃圾回收。</p><p>Parcelable需要实现Parcelable接口，但序列化的过程已经提前确定，所以运行速度快。</p><h2 id="52-Android中的内存泄漏"><a href="#52-Android中的内存泄漏" class="headerlink" title="52. Android中的内存泄漏"></a>52. Android中的内存泄漏</h2><ol><li>查询数据库没有关闭游标。</li><li>构造Adapter时，没有使用缓存的convertView。</li><li>Bitmap对象不再使用时调用<code>recycle()</code>释放内存。</li><li>无用时没有释放对象的引用。</li><li>在Activity中使用非静态的内部类，并开启一个长时间运行的线程，因为内部类持有Activity的引用，会导致Activity本来可以被GC时却长期得不到回收。</li><li>使用Handler处理消息前，Activity通过例如<code>finish()</code>退出，导致内存泄漏。</li><li>动态注册广播在Activity销毁前没有<code>unregisterReceiver()</code>。</li></ol><h2 id="53-MVC和MVP的区别"><a href="#53-MVC和MVP的区别" class="headerlink" title="53. MVC和MVP的区别"></a>53. MVC和MVP的区别</h2><p>我们都知道MVP是从经典的模式MVC演变而来，它们的基本思想有相通的地方：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter（MVC中的Controller）来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过Controller。</p><h2 id="54-内存泄露检测有什么好方法？"><a href="#54-内存泄露检测有什么好方法？" class="headerlink" title="54. 内存泄露检测有什么好方法？"></a>54. 内存泄露检测有什么好方法？</h2><ol><li>DDMS Heap发现内存泄露dataObject totalSize的大小，是否稳定在一个范围内，如果操作程序，不断增加，说明内存泄露。</li><li>使用Heap Tool进行内存快照前后对比BlankActivity手动触发GC进行前后对比，对象是否被及时回收。</li></ol><h2 id="55-Android里面为什么要设计出Bundle而不是直接用Map结构"><a href="#55-Android里面为什么要设计出Bundle而不是直接用Map结构" class="headerlink" title="55. Android里面为什么要设计出Bundle而不是直接用Map结构"></a>55. Android里面为什么要设计出Bundle而不是直接用Map结构</h2><p>Map里实现了Serializable接口，而在Bundle实现了Parcelable的接口。</p><h2 id="56-在Android的MVP架构中，使用了什么设计模式"><a href="#56-在Android的MVP架构中，使用了什么设计模式" class="headerlink" title="56. 在Android的MVP架构中，使用了什么设计模式"></a>56. 在Android的MVP架构中，使用了什么设计模式</h2><ul><li>Observer模式：通过EventBus实现订阅者，发布者的功能，实现Model与Presenter的交互。</li><li>Proxy模式：View保持对Presenter的引用，通过Presenter代理，进行交互操作。</li></ul><h2 id="57-Android动画类型"><a href="#57-Android动画类型" class="headerlink" title="57. Android动画类型"></a>57. Android动画类型</h2><ul><li>属性动画（Property Animation）：是Android 3.0之后推出的，其机制不再是针对 View 来设计的，也不限于只能实现移动、缩放、旋转和淡入这几种简单的动画操作，同时也不再只是一种视觉上的动画效果。属性动画实际上是一种在一定时间段内不断修改某个对象的某个属性值的机制。</li><li><p>视图动画（View Animation）：</p><ul><li><p>补间动画（Tween animation）：是操作某一个控件让其展现出旋转、渐变、移动、缩放的一种转换过程。是一种视觉上的变化，不是真正位置上的变化。只能运用在 View 对象上，并且功能相对来说较为局限。例如：旋转动画只能够在x、y轴进行，而不能在z轴放心进行旋转。因此，补间动画通常用于执行一些比较简单的动画。</p><ul><li>渐变动画（AlphaAnimation）；</li><li>缩放动画（ScaleAnimation）；</li><li>位移动画（TranslateAnimation）；</li><li>旋转动画（RotateAnimation）。</li></ul></li><li><p>帧动画（Frame animation）：帧动画是一系列图片按照一定的顺序展示的过程，和放电影的机制相似，它的原理是在一定的时间段内切换多张有细微差异的图片从而达到动画的效果。由于是一帧一帧加载，所以需要较多的图片。从而增大 APK 的大小，不过 Frame 动画可以实现一些比较难的效果，例如：等待的环形进度。</p></li></ul></li></ul><h2 id="58-ANR和FC的区别"><a href="#58-ANR和FC的区别" class="headerlink" title="58. ANR和FC的区别"></a>58. ANR和FC的区别</h2><ul><li>ANR（Application Not Responding）：主线程阻塞。</li><li>FC（Forced Close）：内存耗尽，堆栈溢出，运行时错误等。</li></ul><h2 id="59-Android中的菜单"><a href="#59-Android中的菜单" class="headerlink" title="59. Android中的菜单"></a>59. Android中的菜单</h2><h3 id="59-1-选项菜单（Options-menu）"><a href="#59-1-选项菜单（Options-menu）" class="headerlink" title="59.1. 选项菜单（Options menu）"></a>59.1. 选项菜单（Options menu）</h3><p>在选项菜单中，您应当包括与当前Activity上下文相关的操作和其他选项，如”搜索”、”撰写电子邮件”和”设置”。</p><ul><li>要为Activity指定选项菜单，请重写<code>onCreateOptionsMenu()</code>。</li><li>此外，您还可以使用<code>add()</code>添加菜单项，并使用<code>findItem()</code>检索项目，以便使用MenuItem API修改其属性。</li><li>系统将在启动Activity时调用<code>onCreateOptionsMenu()</code>，以便向应用栏显示项目。</li><li>用户从选项菜单中选择项目时，系统将调用Activity的<code>onOptionsItemSelected()</code>方法。此方法将传递所选的MenuItem。您可以通过调用<code>getItemId()</code>方法来识别项目，该方法将返回菜单项的唯一ID。</li><li>系统调用<code>onCreateOptionsMenu()</code>后，将保留您填充的Menu实例。除非菜单由于某些原因而失效，否则不会再次调用<code>onCreateOptionsMenu()</code>。</li><li>如需根据在Activity生命周期中发生的事件修改选项菜单，则可通过<code>onPrepareOptionsMenu()</code>方法执行此操作。此方法向您传递Menu对象（因为该对象目前存在），以便您能够对其进行修改，如添加、移除或禁用项目。</li><li>当菜单项显示在应用栏中时，选项菜单被视为始终处于打开状态。 发生事件时，如果您要执行菜单更新，则必须调用<code>invalidateOptionsMenu()</code>来请求系统调用<code>onPrepareOptionsMenu()</code>。</li></ul><h3 id="59-2-上下文菜单（Contextual-Menus）"><a href="#59-2-上下文菜单（Contextual-Menus）" class="headerlink" title="59.2. 上下文菜单（Contextual Menus）"></a>59.2. 上下文菜单（Contextual Menus）</h3><h4 id="59-2-1-浮动上下文菜单（floating-context-menu）"><a href="#59-2-1-浮动上下文菜单（floating-context-menu）" class="headerlink" title="59.2.1. 浮动上下文菜单（floating context menu）"></a>59.2.1. 浮动上下文菜单（floating context menu）</h4><p>用户长按（按住）一个声明支持上下文菜单的视图时，菜单显示为菜单项的浮动列表（类似于对话框）。</p><ul><li>通过调用<code>registerForContextMenu()</code>，注册应与上下文菜单关联的View并将其传递给View。</li><li>在Activity或Fragment中实现<code>onCreateContextMenu()</code>方法。</li><li><p>实现<code>onContextItemSelected()</code>。</p><h4 id="上下文操作模式（contextual-action-mode）"><a href="#上下文操作模式（contextual-action-mode）" class="headerlink" title="上下文操作模式（contextual action mode）"></a>上下文操作模式（contextual action mode）</h4><p>上下文操作模式是 ActionMode 的一种系统实现，它将用户交互的重点转到执行上下文操作上。用户通过选择项目启用此模式时，屏幕顶部将出现一个”上下文操作栏”，显示用户可对当前所选项执行的操作。 启用此模式后，用户可以选择多个项目（若您允许）、取消选择项目以及继续在 Activity 内导航（在您允许的最大范围内）。</p></li><li><p>实现ActionMode.Callback接口。在其回调方法中，您既可以为上下文操作栏指定操作，又可以响应操作项目的点击事件，还可以处理操作模式的其他生命周期事件。</p></li><li><p>当需要显示操作栏时（例如，用户长按视图），请调用<code>startActionMode()</code>。</p></li></ul><h3 id="59-3-弹出菜单（Popup-Menu）"><a href="#59-3-弹出菜单（Popup-Menu）" class="headerlink" title="59.3. 弹出菜单（Popup Menu）"></a>59.3. 弹出菜单（Popup Menu）</h3><p>PopupMenu 是锚定到 View 的模态菜单。如果空间足够，它将显示在定位视图下方，否则显示在其上方。</p><ul><li>实例化PopupMenu及其构造函数，该函数将提取当前应用的Context以及菜单应锚定到的View。</li><li>使用MenuInflater将菜单资源扩充到<code>PopupMenu.getMenu()</code>返回的Menu对象中。</li><li>调用<code>PopupMenu.show()</code>。</li></ul><h2 id="60-BaseAdapter中需要重载的方法"><a href="#60-BaseAdapter中需要重载的方法" class="headerlink" title="60. BaseAdapter中需要重载的方法"></a>60. BaseAdapter中需要重载的方法</h2><p>最基本的：</p><ul><li><code>int getCount ()</code>：How many items are in the data set represented by this Adapter.</li><li><code>Object getItem (int position)</code>：Get the data item associated with the specified position in the data set.</li><li><code>long getItemId (int position)</code>：Get the row id associated with the specified position in the list.</li><li><code>View getView (int position, View convertView, ViewGroup parent)</code>：Get a View that displays the data at the specified position in the data set.</li></ul><p>如果有多种View：</p><ul><li><code>int getItemViewType (int position)</code>：Get the type of View that will be created by getView(int, View, ViewGroup) for the specified item.</li><li><code>int getViewTypeCount ()</code>：Returns the number of types of Views that will be created by getView(int, View, ViewGroup).</li></ul><h2 id="61-Android数字签名要点"><a href="#61-Android数字签名要点" class="headerlink" title="61. Android数字签名要点"></a>61. Android数字签名要点</h2><ul><li>所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序。</li><li>Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证。</li><li>如果要正式发布一个Android应用，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使调试证书来发布。</li><li>数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。</li></ul><h2 id="62-使用相同数字签名的原因"><a href="#62-使用相同数字签名的原因" class="headerlink" title="62. 使用相同数字签名的原因"></a>62. 使用相同数字签名的原因</h2><ul><li>应用升级：当系统安装应用的更新时，它会比较新版本和现有版本中的证书。如果证书匹配，则系统允许更新。如果您使用不同的证书签署新版本，则必须为应用分配另一个软件包名称—-在此情况下，用户将新版本作为全新应用安装。</li><li>应用模块化：Android允许通过相同证书签署的多个APK在同一个进程中运行（如果应用请求这样），以便系统将它们视为单个应用。通过此方式，您可以在模块中部署您的应用，且用户可以独立更新每个模块。</li><li>通过权限共享代码/数据：Android提供基于签名的权限执行，以便应用可以将功能展示给使用指定证书签署的另一应用。通过使用同一个证书签署多个APK并使用基于签名的权限检查功能，您的应用可采用安全的方式共享代码和数据。</li></ul><h2 id="63-Theme和Sytle"><a href="#63-Theme和Sytle" class="headerlink" title="63. Theme和Sytle"></a>63. Theme和Sytle</h2><h3 id="63-1-Style"><a href="#63-1-Style" class="headerlink" title="63.1. Style"></a>63.1. Style</h3><p>样式是指为View或窗口指定外观和格式的属性集合。样式可以指定高度、填充、字体颜色、字号、背景色等许多属性。 样式是在与指定布局的XML不同的XML资源中进行定义。</p><ul><li>要创建一组样式，请在您的项目的<code>res/values/</code>目录中保存一个XML文件。</li><li>该XML文件的根节点必须是<code>&lt;resources&gt;</code>。</li><li>对于您想创建的每个样式，向该文件添加一个<code>&lt;style&gt;</code>元素，该元素带有对样式进行唯一标识的<code>name</code>属性（该属性为必需属性）。</li><li>然后为该样式的每个属性添加一个<code>&lt;item&gt;</code>元素，该元素带有声明样式属性以及属性值的<code>name</code>（该属性为必需属性）。</li><li>根据样式属性，<code>&lt;item&gt;</code>的值可以是关键字字符串、十六进制颜色值、对另一资源类型的引用或其他值。</li><li>您可以通过<code>&lt;style&gt;</code>元素中的<code>parent</code>属性指定应作为您的样式所继承属性来源的样式。</li><li>当您对布局中的单个View应用样式时，该样式定义的属性只应用于该View。如果对ViewGroup应用样式，子View元素将不会继承样式属性—-只有被您直接应用样式的元素才会应用其属性。</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>CodeFont<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:style/TextAppearance.Medium<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">        &lt;item name=<span class="token string">"android:layout_width"</span>>fill_parent&lt;/item>        &lt;item name=<span class="token string">"android:layout_height"</span>>wrap_content&lt;/item>        &lt;item name=<span class="token string">"android:textColor"</span>><span class="token hexcode">#00FF00</span>&lt;/item>        &lt;item name=<span class="token string">"android:typeface"</span>>monospace&lt;/item>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span></code></pre><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span><span class="token style-attr language-css"><span class="token attr-name">    <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value">@style/CodeFont</span><span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/hello<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><h3 id="63-2-Theme"><a href="#63-2-Theme" class="headerlink" title="63.2. Theme"></a>63.2. Theme</h3><p>主题是指对整个Activity或应用而不是对单个View（如上例所示）应用的样式。以主题形式应用样式时，Activity或应用中的每个视图都将应用其支持的每个样式属性。例如，您可以Activity主题形式应用同一CodeFont样式，之后该Activity内的所有文本都将具有绿色固定宽度字体。</p><ul><li>在XML中定义您想用作Activity或应用主题的样式与定义视图样式的方法完全相同。</li><li>Activity或应用内的每个View都将应用其支持的每个属性。例如，如果您对某个Activity应用前面示例中的CodeFont样式，则所有支持这些文本样式属性的View元素也会应用这些属性。任何不支持这些属性的View都会忽略这些属性。如果某个View仅支持部分属性，将只应用这些属性。</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span> <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@style/CustomTheme<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span> <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:style/Theme.Dialog<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h2 id="64-Toast的时长设置"><a href="#64-Toast的时长设置" class="headerlink" title="64. Toast的时长设置"></a>64. Toast的时长设置</h2><p>Toast的显示时长仅有两种：<code>LENGTH_SHORT</code>和<code>LENGTH_LONG</code>。</p><p><code>Toast makeText (Context context, CharSequence text, int duration)</code>：duration <code>int</code>: How long to display the message. Either <code>LENGTH_SHORT</code> or <code>LENGTH_LONG</code>。</p><h2 id="65-触发ANR的情况"><a href="#65-触发ANR的情况" class="headerlink" title="65. 触发ANR的情况"></a>65. 触发ANR的情况</h2><ul><li>KeyDispatchTimeout(5 seconds)：按键或触摸事件在特定时间内无响应；</li><li>BroadcastTimeout(10 seconds)：BroadcastReceiver在特定时间内无法处理完成；</li><li>ServiceTimeout(20 seconds)：Service在特定的时间内无法处理完成</li></ul><h2 id="66-ServiceConnection的onServiceConnected-触发条件"><a href="#66-ServiceConnection的onServiceConnected-触发条件" class="headerlink" title="66. ServiceConnection的onServiceConnected()触发条件"></a>66. ServiceConnection的<code>onServiceConnected()</code>触发条件</h2><ul><li><code>bindService()</code>方法执行成功；</li><li><code>onBind()</code>方法返回非空IBinder对象。</li></ul><h2 id="67-Android虚拟设备不支持的功能"><a href="#67-Android虚拟设备不支持的功能" class="headerlink" title="67. Android虚拟设备不支持的功能"></a>67. Android虚拟设备不支持的功能</h2><ul><li>WLAN</li><li>蓝牙</li><li>NFC</li><li>SD 卡插入/弹出</li><li>连接到设备的耳机</li><li>USB</li></ul><h2 id="68-RemoteView的应用"><a href="#68-RemoteView的应用" class="headerlink" title="68. RemoteView的应用"></a>68. RemoteView的应用</h2><ul><li>AppWidget</li><li>Notification</li></ul><h2 id="69-Android对HashMap做了优化后推出的新的容器类是什么？"><a href="#69-Android对HashMap做了优化后推出的新的容器类是什么？" class="headerlink" title="69. Android对HashMap做了优化后推出的新的容器类是什么？"></a>69. Android对HashMap做了优化后推出的新的容器类是什么？</h2><h3 id="69-1-SparseArray"><a href="#69-1-SparseArray" class="headerlink" title="69.1. SparseArray"></a>69.1. SparseArray</h3><p>SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间。</p><h3 id="69-2-ArrayMap"><a href="#69-2-ArrayMap" class="headerlink" title="69.2. ArrayMap"></a>69.2. ArrayMap</h3><p>ArrayMap是一个&lt;key,value&gt;映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作。</p><h2 id="70-Android安全沙盒"><a href="#70-Android安全沙盒" class="headerlink" title="70. Android安全沙盒"></a>70. Android安全沙盒</h2><ul><li>Android操作系统是一种多用户Linux系统，其中的每个应用都是一个不同的用户；</li><li>默认情况下，系统会为每个应用分配一个唯一的Linux用户ID（该ID仅由系统使用，应用并不知晓）。系统为应用中的所有文件设置权限，使得只有分配给该应用的用户ID才能访问这些文件；</li><li>每个进程都具有自己的虚拟机 (VM)，因此应用代码是在与其他应用隔离的环境中运行；</li><li>默认情况下，每个应用都在其自己的Linux进程内运行。Android会在需要执行任何应用组件时启动该进程，然后在不再需要该进程或系统必须为其他应用恢复内存时关闭该进程。</li></ul><h2 id="71-onStartCommand-有哪些返回值"><a href="#71-onStartCommand-有哪些返回值" class="headerlink" title="71. onStartCommand()有哪些返回值"></a>71. <code>onStartCommand()</code>有哪些返回值</h2><p><code>onStartCommand()</code>的返回值用于描述系统应该如何在服务终止的情况下继续运行服务。其值可以为</p><ul><li><code>START_NOT_STICKY</code>：如果系统在<code>onStartCommand()</code>返回后终止服务，则除非有挂起Intent要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。</li><li><code>START_STICKY</code>：如果系统在<code>onStartCommand()</code>返回后终止服务，则会重建服务并调用<code>onStartCommand()</code>，但不会重新传递最后一个Intent。相反，除非有挂起Intent要启动服务（在这种情况下，将传递这些Intent），否则系统会通过空Intent调用<code>onStartCommand()</code>。这适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。</li><li><code>START_REDELIVER_INTENT</code>：如果系统在<code>onStartCommand()</code>返回后终止服务，则会重建服务，并通过传递给服务的最后一个Intent调用<code>onStartCommand()</code>。任何挂起Intent均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</li></ul><h2 id="72-如何创建绑定服务"><a href="#72-如何创建绑定服务" class="headerlink" title="72. 如何创建绑定服务"></a>72. 如何创建绑定服务</h2><p>建提供绑定的服务时，您必须提供IBinder，用以提供客户端用来与服务进行交互的编程接口。</p><h3 id="72-1-扩展Binder类"><a href="#72-1-扩展Binder类" class="headerlink" title="72.1. 扩展Binder类"></a>72.1. 扩展Binder类</h3><p>如果服务是供您的自有应用专用，并且在与客户端相同的进程中运行（常见情况），则应通过扩展Binder类并从<code>onBind()</code>返回它的一个实例来创建接口。客户端收到Binder后，可利用它直接访问Binder实现中乃至Service中可用的公共方法。</p><ol><li>在您的服务中，创建一个可满足下列任一要求的Binder实例：</li></ol><ul><li>包含客户端可调用的公共方法</li><li>返回当前Service实例，其中包含客户端可调用的公共方法</li><li>或返回由服务承载的其他类的实例，其中包含客户端可调用的公共方法</li></ul><ol start="2"><li>从<code>onBind()</code>回调方法返回此Binder实例。</li><li>在客户端中，从<code>onServiceConnected()</code>回调方法接收Binder，并使用提供的方法调用绑定服务。</li></ol><h3 id="72-2-使用Messenger"><a href="#72-2-使用Messenger" class="headerlink" title="72.2. 使用Messenger"></a>72.2. 使用Messenger</h3><ol><li>服务实现一个Handler，由其接收来自客户端的每个调用的回调</li><li>Handler用于创建Messenger对象（对Handler的引用）</li><li>Messenger创建一个IBinder，服务通过<code>onBind()</code>使其返回客户端</li><li>客户端使用IBinder将Messenger（引用服务的Handler）实例化，然后使用后者将Message对象发送给服务</li><li>服务在其Handler中（具体地讲，是在<code>handleMessage()</code>方法中）接收每个 Message。</li></ol><p>这样，客户端并没有调用服务的“方法”。而客户端传递的“消息”（Message对象）是服务在其Handler中接收的。</p><h2 id="73-如何绑定到服务"><a href="#73-如何绑定到服务" class="headerlink" title="73. 如何绑定到服务"></a>73. 如何绑定到服务</h2><p>应用组件（客户端）可通过调用<code>bindService()</code>绑定到服务。Android系统随后调用服务的onBind()方法，该方法返回用于与服务交互的IBinder。</p><p>绑定是异步的。<code>bindService()</code>会立即返回，“不会”使IBinder返回客户端。要接收IBinder，客户端必须创建一个ServiceConnection实例，并将其传递给<code>bindService()</code>。ServiceConnection包括一个回调方法，系统通过调用它来传递IBinder。</p><ol><li><p>实现ServiceConnection。您的实现必须重写两个回调方法：<code>onServiceConnected()</code>：系统会调用该方法以传递服务的onBind()方法返回的IBinder。<code>onServiceDisconnected()</code>：Android 系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统“不会”调用该方法。</p></li><li><p>调用<code>bindService()</code>，传递ServiceConnection实现。</p></li><li><p>当系统调用您的<code>onServiceConnected()</code>回调方法时，您可以使用接口定义的方法开始调用服务。</p></li><li><p>要断开与服务的连接，请调用<code>unbindService()</code>。如果应用在客户端仍绑定到服务时销毁客户端，则销毁会导致客户端取消绑定。更好的做法是在客户端与服务交互完成后立即取消绑定客户端。</p></li></ol><h2 id="74-Android支持的屏幕密度"><a href="#74-Android支持的屏幕密度" class="headerlink" title="74. Android支持的屏幕密度"></a>74. Android支持的屏幕密度</h2><ul><li>ldpi（低）：120dpi</li><li>mdpi（中）：160dpi</li><li>hdpi（高）：240dpi</li><li>xhdpi（超高）：320dpi</li><li>xxhdpi（超超高）：480dpi</li><li>xxxhdpi（超超超高）：640dpi</li></ul><h2 id="75-如何支持多种屏幕"><a href="#75-如何支持多种屏幕" class="headerlink" title="75. 如何支持多种屏幕"></a>75. 如何支持多种屏幕</h2><ul><li>在清单中显式声明您的应用支持哪些屏幕尺寸；</li><li>为不同屏幕尺寸提供不同的布局；</li><li>为不同屏幕密度提供不同的位图可绘制对象。</li></ul><h2 id="76-什么是资源ID"><a href="#76-什么是资源ID" class="headerlink" title="76. 什么是资源ID"></a>76. 什么是资源ID</h2><p>所有资源ID都在您项目的R类中定义，后者由aapt工具自动生成。</p><p>编译应用时，aapt会生成R类，其中包含您的res/目录中所有资源的资源ID。每个资源类型都有对应的R子类（例如，R.drawable对应于所有可绘制对象资源），而该类型的每个资源都有对应的静态整型数（例如，R.drawable.icon）。这个整型数就是可用来检索资源的资源ID。</p><p>资源ID始终由以下部分组成：</p><ul><li>资源类型：每个资源都被分到一个“类型”组中，例如string、drawable和layout。</li><li>资源名称：它是不包括扩展名的文件名；或是XML android:name属性中的值，如果资源是简单值的话（例如字符串）。</li></ul><h2 id="77-如何处理运行时变更"><a href="#77-如何处理运行时变更" class="headerlink" title="77. 如何处理运行时变更"></a>77. 如何处理运行时变更</h2><p>有些设备配置可能会在运行时发生变化（例如屏幕方向、键盘可用性及语言）。发生这种变化时，Android会重启正在运行的Activity（先后调用<code>onDestroy()</code>和<code>onCreate()</code>）。</p><h3 id="77-1-在配置变更期间保留对象"><a href="#77-1-在配置变更期间保留对象" class="headerlink" title="77.1. 在配置变更期间保留对象"></a>77.1. 在配置变更期间保留对象</h3><p>如果Activity因配置变更而重启，则可通过保留Fragment来减轻重新初始化Activity的负担。此片段可能包含对您要保留的有状态对象的引用。</p><ol><li>扩展Fragment类并声明对有状态对象的引用。</li><li>在创建片段后调用<code>setRetainInstance(boolean)</code>。</li><li>将片段添加到Activity。</li><li>重启Activity后，使用FragmentManager检索片段。</li></ol><h3 id="77-2-自行处理配置变更"><a href="#77-2-自行处理配置变更" class="headerlink" title="77.2. 自行处理配置变更"></a>77.2. 自行处理配置变更</h3><p>要声明由Activity处理配置变更，请在清单文件中编辑相应的<code>&lt;activity&gt;</code>元素，以包含<code>android:configChanges</code>属性以及代表要处理的配置的值。<code>android:configChanges</code>属性的文档中列出了该属性的可能值（最常用的值包括”orientation”和”keyboardHidden”，分别用于避免因屏幕方向和可用键盘改变而导致重启）。</p><h2 id="78-AndroidManifest-xml包括哪些内容？"><a href="#78-AndroidManifest-xml包括哪些内容？" class="headerlink" title="78. AndroidManifest.xml包括哪些内容？"></a>78. AndroidManifest.xml包括哪些内容？</h2><ul><li>为应用的Java软件包命名。软件包名称充当应用的唯一标识符。</li><li>描述应用的各个组件，包括构成应用的Activity、服务、广播接收器和内容提供程序。它还为实现每个组件的类命名并发布其功能，例如它们可以处理的Intent消息。这些声明向Android系统告知有关组件以及可以启动这些组件的条件的信息。</li><li>确定托管应用组件的进程。</li><li>声明应用必须具备哪些权限才能访问API中受保护的部分并与其他应用交互。还声明其他应用与该应用组件交互所需具备的权限。</li><li>声明应用所需的最低Android API级别。</li><li>列出应用必须链接到的库。</li></ul><h2 id="79-用户界面如何构成？"><a href="#79-用户界面如何构成？" class="headerlink" title="79. 用户界面如何构成？"></a>79. 用户界面如何构成？</h2><p><img src="/2018/12/31/11/images/viewgroup.png" alt="View Group"></p><p>Android应用中的所有用户界面元素都是使用View和ViewGroup对象构建而成。View对象用于在屏幕上绘制可供用户交互的内容。ViewGroup对象用于储存其他View（和ViewGroup）对象，以便定义界面的布局。</p><p>每个应用组件的用户界面都是使用View和ViewGroup对象的层次结构定义的。每个视图组都是一个用于组织子视图的不可见容器，而子视图可以是输入控件或其他可绘制某一UI部分的小部件。 </p><h2 id="80-为什么要回收Bitmap的内存"><a href="#80-为什么要回收Bitmap的内存" class="headerlink" title="80. 为什么要回收Bitmap的内存"></a>80. 为什么要回收Bitmap的内存</h2><p>Bitmap的实例化只能通过BitmapFactory，而Bitmap对象的生成则是通过JNI调用，所以Bitmap包含Java和C两部分内存。Java部分内存可以通过虚拟机自动回收，但C部分则需要手动释放，所以需要显式调用<code>recycle()</code>方法来释放。</p><h2 id="81-如何优化Bitmap"><a href="#81-如何优化Bitmap" class="headerlink" title="81. 如何优化Bitmap"></a>81. 如何优化Bitmap</h2><ul><li>加载合适尺寸的图片；</li><li>及时回收Bitmap；</li><li>捕获OOM异常；</li><li>压缩图片；</li><li>使用合适的颜色模式。</li></ul><h2 id="82-如何在新进程中创建Activity／Service"><a href="#82-如何在新进程中创建Activity／Service" class="headerlink" title="82. 如何在新进程中创建Activity／Service"></a>82. 如何在新进程中创建Activity／Service</h2><p>在AndroidManifest中，组件元素条目（activity、service、receiver或provider）中设置<code>android:process</code>属性，此属性可以指定该组件应在哪个进程运行。</p><p>每新建一个进程，Application的<code>onCreate()</code>都将被调用一次。</p><h2 id="83-onActivityResult-什么时候会失效？"><a href="#83-onActivityResult-什么时候会失效？" class="headerlink" title="83. onActivityResult()什么时候会失效？"></a>83. <code>onActivityResult()</code>什么时候会失效？</h2><p>在<code>startActivity()</code>为SingleTask时会失效。</p><blockquote><p>For example, if the activity you are launching uses the singleTask launch mode, it will not run in your task and thus you will immediately receive a cancel result.</p></blockquote><p>如果你正加载的activity使用了singleTask的加载模式，它不会在你的栈中运行，而且这样你会马上收到一个取消的结果。即在<code>onActivityResult()</code>里马上得到一个RESULT_CANCEL。</p><h2 id="84-Android崩溃捕获"><a href="#84-Android崩溃捕获" class="headerlink" title="84. Android崩溃捕获"></a>84. Android崩溃捕获</h2><h3 id="84-1-Java崩溃捕获"><a href="#84-1-Java崩溃捕获" class="headerlink" title="84.1. Java崩溃捕获"></a>84.1. Java崩溃捕获</h3><p>Java提供有UncaughtExceptionHandler接口，该接口含有一个方法：<code>void uncaughtException(Thread t, Throwable e)</code>。</p><p>Uncaught异常发生时会终止线程，此时，系统便会通知UncaughtExceptionHandler，调用<code>uncaughtException()</code>函数。如果该handler没有被显式设置，则会调用对应线程组的默认handler。</p><p>如果要捕获该异常，必须实现UncaughtExceptionHandler，并通过<code>public static void setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler handler)</code>进行设置。</p><h3 id="84-2-Native崩溃捕获"><a href="#84-2-Native崩溃捕获" class="headerlink" title="84.2. Native崩溃捕获"></a>84.2. Native崩溃捕获</h3><p>对Native代码的崩溃，可以通过调用<code>int sigaction(int signum,const struct sigaction *act,struct sigaction *oldact))</code>注册信号处理函数来完成。</p><h2 id="85-Android-APP构建流程"><a href="#85-Android-APP构建流程" class="headerlink" title="85. Android APP构建流程"></a>85. Android APP构建流程</h2><p><img src="/2018/12/31/11/images/build_process.png" alt="Build Process"></p><p><img src="/2018/12/31/11/images/build_process_2.png" alt="Build Process"></p><p>典型的Android APP构建流程：</p><ol><li>Java编译器对工程本身的java代码进行编译，这些java代码有三个来源：app的源代码，由资源文件生成的R文件（aapt工具），以及有aidl文件生成的java接口文件（aidl工具）。产出为.class文件。</li><li>class文件和依赖的三方库文件通过dex工具生成Delvik虚拟机可执行的.dex文件，可能有一个或多个，包含了所有的class信息，包括项目自身的class和依赖的class。产出为.dex文件。</li><li>apkbuilder工具将.dex文件和编译后的资源文件生成未经签名对齐的apk文件。这里编译后的资源文件包括两部分，一是由aapt编译产生的编译后的资源文件，二是依赖的三方库里的资源文件。产出为未经签名的.apk文件。</li><li>分别由Jarsigner和zipalign对apk文件进行签名和对齐，生成最终的apk文件。</li></ol><h2 id="86-class文件与-dex文件的区别"><a href="#86-class文件与-dex文件的区别" class="headerlink" title="86. class文件与.dex文件的区别"></a>86. class文件与.dex文件的区别</h2><p><img src="/2018/12/31/11/images/class_vs_dex.png" alt="class vs dex"></p><h2 id="87-65535问题"><a href="#87-65535问题" class="headerlink" title="87. 65535问题"></a>87. 65535问题</h2><h3 id="87-1-原因"><a href="#87-1-原因" class="headerlink" title="87.1. 原因"></a>87.1. 原因</h3><p>单个dex文件中，method个数采用使用原生类型short来索引，即2个字节最多65536个method，field、class的个数也均有此限制。</p><h3 id="87-2-解决方法"><a href="#87-2-解决方法" class="headerlink" title="87.2. 解决方法"></a>87.2. 解决方法</h3><p>build.gradle中配置<code>multiDexEnabled true</code>，将dex分包。</p><h2 id="88-Dalvik与JVM的区别"><a href="#88-Dalvik与JVM的区别" class="headerlink" title="88. Dalvik与JVM的区别"></a>88. Dalvik与JVM的区别</h2><ul><li>JVM可以执行的文件是.class结尾的字节码文件，而Dalvik执行的是dex文件（不符合JVM规范）。</li><li>Dalvik基于寄存器，而JVM基于栈。</li><li>Dalvik负责进程隔离和线程管理，每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行。</li></ul><p>除此之外：</p><ul><li>有一个特殊的虚拟机进程Zygote，他是虚拟机实例的孵化器。它在系统启动的时候就会产生，它会完成虚拟机的初始化、库的加载、预制类库和初始化的操作。如果系统需要一个新的虚拟机实例，它会迅速复制自身，以最快的速度提供给系统。</li></ul><h2 id="89-ART相对Dalvik的优化"><a href="#89-ART相对Dalvik的优化" class="headerlink" title="89. ART相对Dalvik的优化"></a>89. ART相对Dalvik的优化</h2><ul><li>AOT替换JIT：使用AOT直接在安装时用dex2oat将其完全翻译成native代码。</li><li>GC性能提升：并行GC。</li><li>提升内存效率：专门开辟内存存放large object，因为large object移动成本太大；引入moving collector技术，将不连续的物理内存块对齐，解决内存碎片化问题。</li></ul><p>参考：<a href="https://source.android.com/devices/tech/dalvik/" target="_blank" rel="noopener">ART and Dalvik | Android Open Source Project</a></p><h2 id="90-Android中的ClassLoader"><a href="#90-Android中的ClassLoader" class="headerlink" title="90. Android中的ClassLoader"></a>90. Android中的ClassLoader</h2><p><img src="/2018/12/31/11/images/classloader.png" alt="ClassLoader"></p><ul><li>在Android中，App安装到手机后，apk里面的class.dex中的class均是通过PathClassLoader来加载的。</li><li>DexClassLoader可以用来加载SD卡上加载包含class.dex的.jar和.apk文件。</li><li>DexClassLoader和PathClassLoader的基类BaseDexClassLoader查找class是通过其内部的<code>DexPathList pathList</code>来查找的。</li><li>DexPathList内部有一个<code>Element[] dexElements</code>数组，其<code>findClass()</code>方法的实现就是遍历该数组，查找class，一旦找到需要的类，就直接返回，停止遍历。</li></ul><h2 id="91-ClassLoader方式实现热修复"><a href="#91-ClassLoader方式实现热修复" class="headerlink" title="91. ClassLoader方式实现热修复"></a>91. ClassLoader方式实现热修复</h2><p><img src="/2018/12/31/11/images/classloader_hotpatch.jpg" alt="ClassLoader Hot Patch"></p><p>主要步骤：</p><ol><li>假设MainActivity中有一个方法<code>showMsg()</code>需要修复。</li><li>修复<code>showMsg()</code>方法，制作补丁包patch.jar，该patch.jar文件中就包含已经修复了的dex文件。</li><li>在Application的<code>onCreate()</code>方法中检测是否已经下载好补丁包，如果存在补丁包，就通过DexClassLoader加载patch.jar，然后通过反射拿到DexClassLoader中的 DexPathList对象，进而拿到<code>Element[] dexElements</code>数组，这里标记该Element数组为<code>newDexElements</code>。</li><li>还是通过反射，拿到App默认的ClassLoader即PathClassLoader的DexPathList对象，进而拿到Element数组，这里标记下该数组为<code>baseDexElements</code>。</li><li>将<code>newDexElements</code>和<code>baseDexElements</code>合成一个新的数组<code>allDexElements</code>，且保证<code>newDexElements</code>中的值在<code>allDexElements</code>数组的最前面。</li><li>然后还是通过通过反射，将合成的Element数组设置给PathClassLoader的DexPathList对象。</li><li>在Application完成初始化之后，会开始加载MainActivity，加载过程就是通过DexPathList对象的<code>findClass()</code>方法来完成的，会从头开始遍历其Element数组，会优先查找到之前插入的补丁包中的dexFile，而原apk中的则不会查找到，因此就实现了热修复的目的。</li></ol><p>参考：<a href="http://jaeger.itscoder.com/android/2016/09/20/nuva-source-code-analysis.html" target="_blank" rel="noopener">热修复实现：ClassLoader 方式的实现</a></p><h2 id="92-AsyncTask需要在主线程中实例化吗？"><a href="#92-AsyncTask需要在主线程中实例化吗？" class="headerlink" title="92. AsyncTask需要在主线程中实例化吗？"></a>92. AsyncTask需要在主线程中实例化吗？</h2><h3 id="92-1-API-16之前"><a href="#92-1-API-16之前" class="headerlink" title="92.1. API 16之前"></a>92.1. API 16之前</h3><p>AsyncTask的静态Handler创建和初始化时默认采用的是当前现场的Looper。若子线程无Looper，则会出错；若有Looper则会导致处理消息时无法在主线程执行，出错。所以AsyncTask必须在主线程实例化。</p><h3 id="92-2-API-16及之后，API-22之前"><a href="#92-2-API-16及之后，API-22之前" class="headerlink" title="92.2. API 16及之后，API 22之前"></a>92.2. API 16及之后，API 22之前</h3><p>在ActivityThread的<code>main()</code>中直接调用了<code>AsyncTask.init()</code>，保证Handler在主线程实例化。所以AsyncTask不需要在主线程实例化。</p><h3 id="92-3-API-22及之后"><a href="#92-3-API-22及之后" class="headerlink" title="92.3. API 22及之后"></a>92.3. API 22及之后</h3><p>不再在ActivityThread的<code>main()</code>中调用。AsyncTask通过<code>getMainLooper()</code>获得主线程Looper。所以AsyncTask不需要在主线程实例化。</p><h2 id="93-Android消息处理机制"><a href="#93-Android消息处理机制" class="headerlink" title="93. Android消息处理机制"></a>93. Android消息处理机制</h2><p>Android消息处理机制主要涉及4个类：Looper、Handler、MessageQueue和Message。</p><h3 id="93-1-Looper"><a href="#93-1-Looper" class="headerlink" title="93.1. Looper"></a>93.1. Looper</h3><p>Looper的使用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LooperThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Handler mHandler<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Looper<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// process incoming messages here</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        Looper<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Looper概览：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Looper</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>Looper<span class="token operator">></span> sThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> MessageQueue mQueue<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueue</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Only one Looper may be created per thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Looper <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            Message msg <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// might block</span>            msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">dispatchMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            msg<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>prepare()</code>会检查此线程是否已经存在Looper，随后便会实例化一个Looper（创建一个MessageQueue），并将此Looper设置为此线程的ThreadLocal变量，这样完成Looper和线程的绑定。</p><p><code>loop()</code>即进从MessageQueue取消息并处理的死循环。</p><h3 id="93-2-Handler"><a href="#93-2-Handler" class="headerlink" title="93.2. Handler"></a>93.2. Handler</h3><p>Handler概览：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Looper mLooper<span class="token punctuation">;</span>    <span class="token keyword">final</span> MessageQueue mQueue<span class="token punctuation">;</span>    <span class="token keyword">final</span> Handler<span class="token punctuation">.</span>Callback mCallback<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mLooper <span class="token operator">=</span> Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mLooper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>                    <span class="token string">"Can't create handler inside thread that has not called Looper.prepare()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        mQueue <span class="token operator">=</span> mLooper<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispatchMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>callback <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">handleCallback</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> what<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Message <span class="token function">getPostMessage</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Message m <span class="token operator">=</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m<span class="token punctuation">.</span>callback <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">return</span> m<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">post</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MessageQueue queue <span class="token operator">=</span> mQueue<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>MessageQueue queue<span class="token punctuation">,</span> Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span>        msg<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> queue<span class="token punctuation">.</span><span class="token function">enqueueMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handleCallback</span><span class="token punctuation">(</span>Message message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        message<span class="token punctuation">.</span>callback<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>一般的用法是对<code>mHandler</code>调用<code>obtainMessage()</code>获得Message并设置参数后通过<code>sendMessage()</code>发送出去。在<code>obtainMessage()</code>和<code>sendMessage()</code>都会设置Message的Handler为本Handler（Message的<code>target</code>变量），若需向Message传递Runnable对象，则会在Message的<code>callback</code>变量中记录。</p><p><code>sendMessage()</code>最终会调用MessageQueue的<code>enqueueMessage()</code>方法，将此Message绑定到对应Looper对应的MessageQueue上。而Looper中收到Message后，会调用Message的<code>target</code>变量（即Handler）的<code>dispatchMessage()</code>方法。对于普通Message，<code>dispatchMessage()</code>又会去调用<code>handleMessage()</code>方法，而这个方法会被用户重载，所以会执行<code>mHandler</code>中指定的代码。</p><p>参考：<a href="http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html" target="_blank" rel="noopener">android的消息处理机制（图+源码分析）——Looper,Handler,Message - CodingMyWorld - 博客园</a></p><h2 id="94-startActivity-执行流程"><a href="#94-startActivity-执行流程" class="headerlink" title="94. startActivity()执行流程"></a>94. <code>startActivity()</code>执行流程</h2><p><img src="/2018/12/31/11/images/start_activity_process.jpg" alt="Start Activity Process"></p><ul><li>当Activity的目标进程不存在时，会首先创建进程。</li><li>Activity Manager Service（AMS）向目标进程的主线程发送<code>LAUNCH_ACTIVITY</code>，目标进程通过反射创建目标Activity，然后进入<code>onCreate()</code>生命周期。</li></ul><p>参考：<a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析 - Gityuan博客 | 袁辉辉博客</a></p>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringBoot基础</title>
      <link href="/2018/11/25/springboot-ji-chu/"/>
      <url>/2018/11/25/springboot-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="学习目标："><a href="#学习目标：" class="headerlink" title="学习目标："></a>学习目标：</h2><ol><li>能够理解Spring的优缺点</li><li>能够理解SpringBoot的特点</li><li>能够理解SpringBoot的核心功能</li><li>能够搭建SpringBoot的环境</li><li>能够完成application.properties配置文件的配置</li><li>能够完成application.yml配置文件的配置</li><li>能够使用SpringBoot集成Mybatis</li><li>能够使用SpringBoot集成Junit</li><li>能够使用SpringBoot集成SpringData JPA</li></ol><h1 id="一、SpringBoot简介"><a href="#一、SpringBoot简介" class="headerlink" title="一、SpringBoot简介"></a>一、SpringBoot简介</h1><h2 id="1-1-原有Spring优缺点分析"><a href="#1-1-原有Spring优缺点分析" class="headerlink" title="1.1  原有Spring优缺点分析"></a>1.1  原有Spring优缺点分析</h2><h3 id="1-1-1-Spring的优点分析"><a href="#1-1-1-Spring的优点分析" class="headerlink" title="1.1.1 Spring的优点分析"></a>1.1.1 Spring的优点分析</h3><p>Spring是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的Enterprise JavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。</p><h3 id="1-1-2-Spring的缺点分析"><a href="#1-1-2-Spring的缺点分析" class="headerlink" title="1.1.2 Spring的缺点分析"></a>1.1.2 Spring的缺点分析</h3><p>虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。</p><p>所有这些配置都代表了开发时的损耗。因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。</p><p>除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。</p><h2 id="1-2-SpringBoot的概述"><a href="#1-2-SpringBoot的概述" class="headerlink" title="1.2 SpringBoot的概述"></a>1.2 SpringBoot的概述</h2><h3 id="1-2-1-SpringBoot解决上述Spring的缺点"><a href="#1-2-1-SpringBoot解决上述Spring的缺点" class="headerlink" title="1.2.1 SpringBoot解决上述Spring的缺点"></a>1.2.1 SpringBoot解决上述Spring的缺点</h3><p>SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。</p><h3 id="1-2-2-SpringBoot的特点"><a href="#1-2-2-SpringBoot的特点" class="headerlink" title="1.2.2 SpringBoot的特点"></a>1.2.2 SpringBoot的特点</h3><ul><li>为基于Spring的开发提供更快的入门体验</li><li>开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求</li><li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等</li><li>SpringBoot不是对Spring功能上的增强，而是提供了一种快速使用Spring的方式</li></ul><h3 id="1-2-3-SpringBoot的核心功能"><a href="#1-2-3-SpringBoot的核心功能" class="headerlink" title="1.2.3 SpringBoot的核心功能"></a>1.2.3 SpringBoot的核心功能</h3><ul><li><p>起步依赖</p><p>起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。</p><p>简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</p></li><li><p>自动配置</p><p>Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</p></li></ul><p>​    注意：起步依赖和自动配置的原理剖析会在第三章《SpringBoot原理分析》进行详细讲解</p><h1 id="二、SpringBoot快速入门"><a href="#二、SpringBoot快速入门" class="headerlink" title="二、SpringBoot快速入门"></a>二、SpringBoot快速入门</h1><h2 id="2-1-代码实现"><a href="#2-1-代码实现" class="headerlink" title="2.1 代码实现"></a>2.1 代码实现</h2><h3 id="2-1-1-创建Maven工程"><a href="#2-1-1-创建Maven工程" class="headerlink" title="2.1.1 创建Maven工程"></a>2.1.1 创建Maven工程</h3><p>使用idea工具创建一个maven工程，该工程为普通的java工程即可</p><p><img src="/2018/11/25/springboot-ji-chu/img/1.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/2.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/3.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/4.png" alt=""></p><h3 id="2-1-2-添加SpringBoot的起步依赖"><a href="#2-1-2-添加SpringBoot的起步依赖" class="headerlink" title="2.1.2 添加SpringBoot的起步依赖"></a>2.1.2 添加SpringBoot的起步依赖</h3><p>SpringBoot要求，项目要继承SpringBoot的起步依赖spring-boot-starter-parent</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span></code></pre><p>SpringBoot要集成SpringMVC进行Controller的开发，所以项目要导入web的启动依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><h3 id="2-1-3-编写SpringBoot引导类"><a href="#2-1-3-编写SpringBoot引导类" class="headerlink" title="2.1.3 编写SpringBoot引导类"></a>2.1.3 编写SpringBoot引导类</h3><p>要通过SpringBoot提供的引导类起步SpringBoot才可以进行访问</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>itheima<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>SpringApplication<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>SpringBootApplication<span class="token punctuation">;</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MySpringBootApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>MySpringBootApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-1-4-编写Controller"><a href="#2-1-4-编写Controller" class="headerlink" title="2.1.4 编写Controller"></a>2.1.4 编写Controller</h3><p>在引导类MySpringBootApplication同级包或者子级包中创建QuickStartController</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>controller<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Controller<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RequestMapping<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ResponseBody<span class="token punctuation">;</span><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickStartController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/quick"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">quick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"springboot 访问成功!"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-1-5-测试"><a href="#2-1-5-测试" class="headerlink" title="2.1.5 测试"></a>2.1.5 测试</h3><p>执行SpringBoot起步类的主方法，控制台打印日志如下：</p><pre><code>.   ____          _            __ _ _ /\\ / ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | &#39;_ | &#39;_| | &#39;_ \/ _` | \ \ \ \ \\/  ___)| |_)| | | | | || (_| |  ) ) ) )  &#39;  |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::        (v2.0.1.RELEASE)2018-05-08 14:29:59.714  INFO 5672 --- [           main] com.itheima.MySpringBootApplication      : Starting MySpringBootApplication on DESKTOP-RRUNFUH with PID 5672 (C:\Users\muzimoo\IdeaProjects\IdeaTest\springboot_quick\target\classes started by muzimoo in C:\Users\muzimoo\IdeaProjects\IdeaTest)... ... ...o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2018-05-08 14:30:03.126  INFO 5672 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup2018-05-08 14:30:03.196  INFO 5672 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#39;&#39;2018-05-08 14:30:03.206  INFO 5672 --- [           main] com.itheima.MySpringBootApplication      : Started MySpringBootApplication in 4.252 seconds (JVM running for 5.583)</code></pre><p>通过日志发现，Tomcat started on port(s): 8080 (http) with context path ‘’</p><p>tomcat已经起步，端口监听8080，web应用的虚拟工程名称为空</p><p>打开浏览器访问url地址为：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a></p><p><img src="/2018/11/25/springboot-ji-chu/img/5.png" alt=""></p><h2 id="2-2-快速入门解析"><a href="#2-2-快速入门解析" class="headerlink" title="2.2 快速入门解析"></a>2.2 快速入门解析</h2><h3 id="2-2-2-SpringBoot代码解析"><a href="#2-2-2-SpringBoot代码解析" class="headerlink" title="2.2.2 SpringBoot代码解析"></a>2.2.2 SpringBoot代码解析</h3><ul><li>@SpringBootApplication：标注SpringBoot的启动类，该注解具备多种功能（后面详细剖析）</li><li>SpringApplication.run(MySpringBootApplication.class) 代表运行SpringBoot的启动类，参数为SpringBoot启动类的字节码对象</li></ul><h3 id="2-2-3-SpringBoot工程热部署"><a href="#2-2-3-SpringBoot工程热部署" class="headerlink" title="2.2.3 SpringBoot工程热部署"></a>2.2.3 SpringBoot工程热部署</h3><p>我们在开发中反复修改类、页面等资源，每次修改后都是需要重新启动才生效，这样每次启动都很麻烦，浪费了大量的时间，我们可以在修改代码后不重启就能生效，在 pom.xml 中添加如下配置就可以实现这样的功能，我们称之为热部署。</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--热部署配置--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>注意：IDEA进行SpringBoot热部署失败原因</p><p>出现这种情况，并不是热部署配置问题，其根本原因是因为Intellij IEDA默认情况下不会自动编译，需要对IDEA进行自动编译的设置，如下：</p><p><img src="/2018/11/25/springboot-ji-chu/img/19.png" alt=""></p><p>然后 Shift+Ctrl+Alt+/，选择Registry</p><p><img src="/2018/11/25/springboot-ji-chu/img/20.png" alt=""></p><h3 id="2-2-4-使用idea快速创建SpringBoot项目"><a href="#2-2-4-使用idea快速创建SpringBoot项目" class="headerlink" title="2.2.4 使用idea快速创建SpringBoot项目"></a>2.2.4 使用idea快速创建SpringBoot项目</h3><p><img src="/2018/11/25/springboot-ji-chu/img/6.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/7.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/8.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/9.png" alt=""></p><p><img src="/2018/11/25/springboot-ji-chu/img/10.png" alt=""></p><p>通过idea快速创建的SpringBoot项目的pom.xml中已经导入了我们选择的web的起步依赖的坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.itheima<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>springboot_quick2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.0.1-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">></span></span>jar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>springboot_quick2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Demo project for Spring Boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment" spellcheck="true">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.build.sourceEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>UTF-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project.reporting.outputEncoding</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>java.version</span><span class="token punctuation">></span></span>9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>java.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>可以使用快速入门的方式创建Controller进行访问，此处不再赘述</p><h1 id="三、SpringBoot原理分析"><a href="#三、SpringBoot原理分析" class="headerlink" title="三、SpringBoot原理分析"></a>三、SpringBoot原理分析</h1><h2 id="3-1-起步依赖原理分析"><a href="#3-1-起步依赖原理分析" class="headerlink" title="3.1 起步依赖原理分析"></a>3.1 起步依赖原理分析</h2><h3 id="3-1-1-分析spring-boot-starter-parent"><a href="#3-1-1-分析spring-boot-starter-parent" class="headerlink" title="3.1.1 分析spring-boot-starter-parent"></a>3.1.1 分析spring-boot-starter-parent</h3><p>按住Ctrl点击pom.xml中的spring-boot-starter-parent，跳转到了spring-boot-starter-parent的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">></span></span>../../spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relativePath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span></code></pre><p>按住Ctrl点击pom.xml中的spring-boot-starter-dependencies，跳转到了spring-boot-starter-dependencies的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activemq.version</span><span class="token punctuation">></span></span>5.15.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activemq.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>antlr2.version</span><span class="token punctuation">></span></span>2.7.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>antlr2.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appengine-sdk.version</span><span class="token punctuation">></span></span>1.9.63<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appengine-sdk.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artemis.version</span><span class="token punctuation">></span></span>2.4.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artemis.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aspectj.version</span><span class="token punctuation">></span></span>1.8.13<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aspectj.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assertj.version</span><span class="token punctuation">></span></span>3.9.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assertj.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>atomikos.version</span><span class="token punctuation">></span></span>4.0.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>atomikos.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bitronix.version</span><span class="token punctuation">></span></span>2.1.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bitronix.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build-helper-maven-plugin.version</span><span class="token punctuation">></span></span>3.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build-helper-maven-plugin.version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>byte-buddy.version</span><span class="token punctuation">></span></span>1.7.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>byte-buddy.version</span><span class="token punctuation">></span></span>      ... ... ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>          ... ... ...    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pluginManagement</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.jetbrains.kotlin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>kotlin-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${kotlin.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.jooq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jooq-codegen-maven<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${jooq.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>              ... ... ...        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pluginManagement</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span></code></pre><p>从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分坐标的版本、依赖管理、插件管理已经定义好，所以我们的SpringBoot工程继承spring-boot-starter-parent后已经具备版本锁定等配置了。所以起步依赖的作用就是进行依赖的传递。</p><h3 id="3-1-2-分析spring-boot-starter-web"><a href="#3-1-2-分析spring-boot-starter-web" class="headerlink" title="3.1.2 分析spring-boot-starter-web"></a>3.1.2 分析spring-boot-starter-web</h3><p>按住Ctrl点击pom.xml中的spring-boot-starter-web，跳转到了spring-boot-starter-web的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">></span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starters<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>Spring Boot Web Starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-json<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.0.1.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.hibernate.validator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hibernate-validator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>6.0.9.Final<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-webmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>5.0.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">></span></span></code></pre><p>从上面的spring-boot-starter-web的pom.xml中我们可以发现，spring-boot-starter-web就是将web开发要使用的spring-web、spring-webmvc等坐标进行了“打包”，这样我们的工程只要引入spring-boot-starter-web起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的作用。</p><h2 id="3-2-自动配置原理解析"><a href="#3-2-自动配置原理解析" class="headerlink" title="3.2 自动配置原理解析"></a>3.2 自动配置原理解析</h2><p>按住Ctrl点击查看启动类MySpringBootApplication上的注解@SpringBootApplication</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MySpringBootApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>MySpringBootApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注解@SpringBootApplication的源码</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> TypeExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> AutoConfigurationExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Exclude specific auto-configuration classes such that they will never be applied.     * @return the classes to exclude     */</span>    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> EnableAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>其中，</p><p>@SpringBootConfiguration：等同与@Configuration，既标注该类是Spring的一个配置类</p><p>@EnableAutoConfiguration：SpringBoot自动配置功能开启</p><p>按住Ctrl点击查看注解@EnableAutoConfiguration</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@AutoConfigurationPackage</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>AutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>其中，@Import(AutoConfigurationImportSelector.class) 导入了AutoConfigurationImportSelector类</p><p>按住Ctrl点击查看AutoConfigurationImportSelector源码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span>AnnotationMetadata annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> configurations <span class="token operator">=</span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span>                                                                   attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>        configurations <span class="token operator">=</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> exclusions <span class="token operator">=</span> <span class="token function">getExclusions</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">checkExcludedClasses</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        configurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        configurations <span class="token operator">=</span> <span class="token function">filter</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> autoConfigurationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fireAutoConfigurationImportEvents</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> StringUtils<span class="token punctuation">.</span><span class="token function">toStringArray</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>AnnotationMetadata metadata<span class="token punctuation">,</span>            AnnotationAttributes attributes<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> configurations <span class="token operator">=</span> SpringFactoriesLoader<span class="token punctuation">.</span><span class="token function">loadFactoryNames</span><span class="token punctuation">(</span>                <span class="token function">getSpringFactoriesLoaderFactoryClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> configurations<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中，SpringFactoriesLoader.loadFactoryNames 方法的作用就是从META-INF/spring.factories文件中读取指定类对应的类名称列表 </p><p><img src="/2018/11/25/springboot-ji-chu/img/11.png" alt=""></p><p>spring.factories 文件中有关自动配置的配置信息如下：</p><pre><code>... ... ...org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\... ... ...</code></pre><p>上面配置文件存在大量的以Configuration为结尾的类名称，这些类就是存有自动配置信息的类，而SpringApplication在获取这些类名后再加载</p><p>我们以ServletWebServerFactoryAutoConfiguration为例来分析源码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@AutoConfigureOrder</span><span class="token punctuation">(</span>Ordered<span class="token punctuation">.</span>HIGHEST_PRECEDENCE<span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span>ServletRequest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span><span class="token punctuation">(</span>type <span class="token operator">=</span> Type<span class="token punctuation">.</span>SERVLET<span class="token punctuation">)</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span>ServerProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ServletWebServerFactoryAutoConfiguration<span class="token punctuation">.</span>BeanPostProcessorsRegistrar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        ServletWebServerFactoryConfiguration<span class="token punctuation">.</span>EmbeddedTomcat<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        ServletWebServerFactoryConfiguration<span class="token punctuation">.</span>EmbeddedJetty<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        ServletWebServerFactoryConfiguration<span class="token punctuation">.</span>EmbeddedUndertow<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServletWebServerFactoryAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>其中，</p><p>@EnableConfigurationProperties(ServerProperties.class) 代表加载ServerProperties服务器配置属性类</p><p>进入ServerProperties.class源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"server"</span><span class="token punctuation">,</span> ignoreUnknownFields <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerProperties</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Server HTTP port.     */</span>    <span class="token keyword">private</span> Integer port<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Network address to which the server should bind.     */</span>    <span class="token keyword">private</span> InetAddress address<span class="token punctuation">;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>其中，</p><p>prefix = “server” 表示SpringBoot配置文件中的前缀，SpringBoot会将配置文件中以server开始的属性映射到该类的字段中。映射关系如下：</p><p><img src="/2018/11/25/springboot-ji-chu/img/12.png" alt=""></p><h1 id="四、SpringBoot的配置文件"><a href="#四、SpringBoot的配置文件" class="headerlink" title="四、SpringBoot的配置文件"></a>四、SpringBoot的配置文件</h1><h2 id="4-1-SpringBoot配置文件类型"><a href="#4-1-SpringBoot配置文件类型" class="headerlink" title="4.1 SpringBoot配置文件类型"></a>4.1 SpringBoot配置文件类型</h2><h3 id="4-1-1-SpringBoot配置文件类型和作用"><a href="#4-1-1-SpringBoot配置文件类型和作用" class="headerlink" title="4.1.1 SpringBoot配置文件类型和作用"></a>4.1.1 SpringBoot配置文件类型和作用</h3><p>SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。</p><p>SpringBoot默认会从Resources目录下加载application.properties或application.yml（application.yaml）文件</p><p>其中，application.properties文件是键值对类型的文件，之前一直在使用，所以此处不在对properties文件的格式进行阐述。除了properties文件外，SpringBoot还可以使用yml文件进行配置，下面对yml文件进行讲解。</p><h3 id="4-1-2-application-yml配置文件"><a href="#4-1-2-application-yml配置文件" class="headerlink" title="4.1.2 application.yml配置文件"></a>4.1.2 application.yml配置文件</h3><h4 id="4-1-2-1-yml配置文件简介"><a href="#4-1-2-1-yml配置文件简介" class="headerlink" title="4.1.2.1 yml配置文件简介"></a>4.1.2.1 yml配置文件简介</h4><p>YML文件格式是YAML (YAML Aint Markup Language)编写的文件格式，YAML是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。</p><p>YML文件的扩展名可以使用.yml或者.yaml。</p><h4 id="4-1-2-2-yml配置文件的语法"><a href="#4-1-2-2-yml配置文件的语法" class="headerlink" title="4.1.2.2 yml配置文件的语法"></a>4.1.2.2 yml配置文件的语法</h4><h5 id="4-1-2-2-1-配置普通数据"><a href="#4-1-2-2-1-配置普通数据" class="headerlink" title="4.1.2.2.1 配置普通数据"></a>4.1.2.2.1 配置普通数据</h5><ul><li><p>语法： key: value</p></li><li><p>示例代码：</p></li><li><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">name</span><span class="token punctuation">:</span> haohao</code></pre></li><li><p>注意：value之前有一个空格</p></li></ul><h5 id="4-1-2-2-2-配置对象数据"><a href="#4-1-2-2-2-配置对象数据" class="headerlink" title="4.1.2.2.2 配置对象数据"></a>4.1.2.2.2 配置对象数据</h5><ul><li><p>语法： </p><p>​    key: </p><p>​        key1: value1</p><p>​        key2: value2</p><p>​    或者：</p><p>​    key: {key1: value1,key2: value2}</p></li><li><p>示例代码：</p></li><li><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">person</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> haohao  <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">31</span>  <span class="token key atrule">addr</span><span class="token punctuation">:</span> beijing<span class="token comment" spellcheck="true">#或者</span><span class="token key atrule">person</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token key atrule">name</span><span class="token punctuation">:</span> haohao<span class="token punctuation">,</span><span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">31</span><span class="token punctuation">,</span><span class="token key atrule">addr</span><span class="token punctuation">:</span> beijing<span class="token punctuation">}</span></code></pre></li><li><p>注意：key1前面的空格个数不限定，在yml语法中，相同缩进代表同一个级别</p></li></ul><h5 id="4-1-2-2-2-配置Map数据"><a href="#4-1-2-2-2-配置Map数据" class="headerlink" title="4.1.2.2.2 配置Map数据"></a>4.1.2.2.2 配置Map数据</h5><p>同上面的对象写法</p><h5 id="4-1-2-2-3-配置数组（List、Set）数据"><a href="#4-1-2-2-3-配置数组（List、Set）数据" class="headerlink" title="4.1.2.2.3 配置数组（List、Set）数据"></a>4.1.2.2.3 配置数组（List、Set）数据</h5><ul><li><p>语法： </p><p>​    key: </p><p>​        - value1</p><p>​        - value2</p><p>或者：</p><p>​    key: [value1,value2]</p></li><li><p>示例代码：</p></li><li><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">city</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> beijing  <span class="token punctuation">-</span> tianjin  <span class="token punctuation">-</span> shanghai  <span class="token punctuation">-</span> chongqing<span class="token comment" spellcheck="true">#或者</span><span class="token key atrule">city</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>beijing<span class="token punctuation">,</span>tianjin<span class="token punctuation">,</span>shanghai<span class="token punctuation">,</span>chongqing<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#集合中的元素是对象形式</span><span class="token key atrule">student</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> zhangsan    <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span>    <span class="token key atrule">score</span><span class="token punctuation">:</span> <span class="token number">100</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> lisi    <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">28</span>    <span class="token key atrule">score</span><span class="token punctuation">:</span> <span class="token number">88</span>  <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> wangwu    <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">38</span>    <span class="token key atrule">score</span><span class="token punctuation">:</span> <span class="token number">90</span></code></pre></li><li><p>注意：value1与之间的 - 之间存在一个空格</p></li></ul><h3 id="4-1-3-SpringBoot配置信息的查询"><a href="#4-1-3-SpringBoot配置信息的查询" class="headerlink" title="4.1.3 SpringBoot配置信息的查询"></a>4.1.3 SpringBoot配置信息的查询</h3><p>上面提及过，SpringBoot的配置文件，主要的目的就是对配置信息进行修改的，但在配置时的key从哪里去查询呢？我们可以查阅SpringBoot的官方文档</p><p>文档URL：<a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties</a></p><p>常用的配置摘抄如下：</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># QUARTZ SCHEDULER (QuartzProperties)</span><span class="token attr-name">spring.quartz.jdbc.initialize-schema</span><span class="token punctuation">=</span><span class="token attr-value">embedded # Database schema initialization mode.</span><span class="token attr-name">spring.quartz.jdbc.schema</span><span class="token punctuation">=</span><span class="token attr-value">classpath:org/quartz/impl/jdbcjobstore/tables_@@platform@@.sql # Path to the SQL file to use to initialize the database schema.</span><span class="token attr-name">spring.quartz.job-store-type</span><span class="token punctuation">=</span><span class="token attr-value">memory # Quartz job store type.</span><span class="token attr-name">spring.quartz.properties.*</span><span class="token punctuation">=</span> <span class="token attr-value"># Additional Quartz Scheduler properties.</span><span class="token comment" spellcheck="true"># ----------------------------------------</span><span class="token comment" spellcheck="true"># WEB PROPERTIES</span><span class="token comment" spellcheck="true"># ----------------------------------------</span><span class="token comment" spellcheck="true"># EMBEDDED SERVER CONFIGURATION (ServerProperties)</span><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8080 # Server HTTP port.</span><span class="token attr-name">server.servlet.context-path</span><span class="token punctuation">=</span> <span class="token attr-value"># Context path of the application.</span><span class="token attr-name">server.servlet.path</span><span class="token punctuation">=</span><span class="token attr-value">/ # Path of the main dispatcher servlet.</span><span class="token comment" spellcheck="true"># HTTP encoding (HttpEncodingProperties)</span><span class="token attr-name">spring.http.encoding.charset</span><span class="token punctuation">=</span><span class="token attr-value">UTF-8 # Charset of HTTP requests and responses. Added to the "Content-Type" header if not set explicitly.</span><span class="token comment" spellcheck="true"># JACKSON (JacksonProperties)</span><span class="token attr-name">spring.jackson.date-format</span><span class="token punctuation">=</span> <span class="token attr-value"># Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.</span><span class="token comment" spellcheck="true"># SPRING MVC (WebMvcProperties)</span><span class="token attr-name">spring.mvc.servlet.load-on-startup</span><span class="token punctuation">=</span><span class="token attr-value">-1 # Load on startup priority of the dispatcher servlet.</span><span class="token attr-name">spring.mvc.static-path-pattern</span><span class="token punctuation">=</span><span class="token attr-value">/** # Path pattern used for static resources.</span><span class="token attr-name">spring.mvc.view.prefix</span><span class="token punctuation">=</span> <span class="token attr-value"># Spring MVC view prefix.</span><span class="token attr-name">spring.mvc.view.suffix</span><span class="token punctuation">=</span> <span class="token attr-value"># Spring MVC view suffix.</span><span class="token comment" spellcheck="true"># DATASOURCE (DataSourceAutoConfiguration &amp; DataSourceProperties)</span><span class="token attr-name">spring.datasource.driver-class-name</span><span class="token punctuation">=</span> <span class="token attr-value"># Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span> <span class="token attr-value"># Login password of the database.</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span> <span class="token attr-value"># JDBC URL of the database.</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span> <span class="token attr-value"># Login username of the database.</span><span class="token comment" spellcheck="true"># JEST (Elasticsearch HTTP client) (JestProperties)</span><span class="token attr-name">spring.elasticsearch.jest.password</span><span class="token punctuation">=</span> <span class="token attr-value"># Login password.</span><span class="token attr-name">spring.elasticsearch.jest.proxy.host</span><span class="token punctuation">=</span> <span class="token attr-value"># Proxy host the HTTP client should use.</span><span class="token attr-name">spring.elasticsearch.jest.proxy.port</span><span class="token punctuation">=</span> <span class="token attr-value"># Proxy port the HTTP client should use.</span><span class="token attr-name">spring.elasticsearch.jest.read-timeout</span><span class="token punctuation">=</span><span class="token attr-value">3s # Read timeout.</span><span class="token attr-name">spring.elasticsearch.jest.username</span><span class="token punctuation">=</span> <span class="token attr-value"># Login username.</span></code></pre><p>我们可以通过配置application.poperties 或者 application.yml 来修改SpringBoot的默认配置</p><p>例如：</p><p>application.properties文件</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">8888</span><span class="token attr-name">server.servlet.context-path</span><span class="token punctuation">=</span><span class="token attr-value">demo</span></code></pre><p>application.yml文件</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8888</span>  <span class="token key atrule">servlet</span><span class="token punctuation">:</span>    <span class="token key atrule">context-path</span><span class="token punctuation">:</span> /demo</code></pre><h2 id="4-2-配置文件与配置类的属性映射方式"><a href="#4-2-配置文件与配置类的属性映射方式" class="headerlink" title="4.2 配置文件与配置类的属性映射方式"></a>4.2 配置文件与配置类的属性映射方式</h2><h3 id="4-2-1-使用注解-Value映射"><a href="#4-2-1-使用注解-Value映射" class="headerlink" title="4.2.1 使用注解@Value映射"></a>4.2.1 使用注解@Value映射</h3><p>我们可以通过@Value注解将配置文件中的值映射到一个Spring管理的Bean的字段上</p><p>例如：</p><p>application.properties配置如下：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">person</span><span class="token punctuation">:</span><span class="token attr-name">  name</span><span class="token punctuation">:</span> <span class="token attr-value">zhangsan</span><span class="token attr-name">  age</span><span class="token punctuation">:</span> <span class="token attr-value">18</span></code></pre><p>或者，application.yml配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">person</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zhangsan  <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span></code></pre><p>实体Bean代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickStartController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${person.name}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${person.age}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/quick"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">quick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"springboot 访问成功! name="</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">",age="</span><span class="token operator">+</span>age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>浏览器访问地址：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a> 结果如下：</p><p><img src="/2018/11/25/springboot-ji-chu/img/13.png" alt=""></p><h3 id="4-2-2-使用注解-ConfigurationProperties映射"><a href="#4-2-2-使用注解-ConfigurationProperties映射" class="headerlink" title="4.2.2 使用注解@ConfigurationProperties映射"></a>4.2.2 使用注解@ConfigurationProperties映射</h3><p>通过注解@ConfigurationProperties(prefix=”配置文件中的key的前缀”)可以将配置文件中的配置自动与实体进行映射</p><p>application.properties配置如下：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">person</span><span class="token punctuation">:</span><span class="token attr-name">  name</span><span class="token punctuation">:</span> <span class="token attr-value">zhangsan</span><span class="token attr-name">  age</span><span class="token punctuation">:</span> <span class="token attr-value">18</span></code></pre><p>或者，application.yml配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">person</span><span class="token punctuation">:</span>  <span class="token key atrule">name</span><span class="token punctuation">:</span> zhangsan  <span class="token key atrule">age</span><span class="token punctuation">:</span> <span class="token number">18</span></code></pre><p>实体Bean代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickStartController</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/quick"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> String <span class="token function">quick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"springboot 访问成功! name="</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">",age="</span><span class="token operator">+</span>age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span>Integer age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>浏览器访问地址：<a href="http://localhost:8080/quick" target="_blank" rel="noopener">http://localhost:8080/quick</a> 结果如下：</p><p><img src="/2018/11/25/springboot-ji-chu/img/13.png" alt=""></p><p>注意：使用@ConfigurationProperties方式可以进行配置文件与实体字段的自动映射，但需要字段必须提供set方法才可以，而使用@Value注解修饰的字段不需要提供set方法</p><h1 id="五、SpringBoot与整合其他技术"><a href="#五、SpringBoot与整合其他技术" class="headerlink" title="五、SpringBoot与整合其他技术"></a>五、SpringBoot与整合其他技术</h1><h2 id="5-1-SpringBoot整合Mybatis"><a href="#5-1-SpringBoot整合Mybatis" class="headerlink" title="5.1 SpringBoot整合Mybatis"></a>5.1 SpringBoot整合Mybatis</h2><h3 id="5-1-1-添加Mybatis的起步依赖"><a href="#5-1-1-添加Mybatis的起步依赖" class="headerlink" title="5.1.1 添加Mybatis的起步依赖"></a>5.1.1 添加Mybatis的起步依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--mybatis起步依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-1-2-添加数据库驱动坐标"><a href="#5-1-2-添加数据库驱动坐标" class="headerlink" title="5.1.2 添加数据库驱动坐标"></a>5.1.2 添加数据库驱动坐标</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- MySQL连接驱动 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-1-3-添加数据库连接信息"><a href="#5-1-3-添加数据库连接信息" class="headerlink" title="5.1.3 添加数据库连接信息"></a>5.1.3 添加数据库连接信息</h3><p>在application.properties中添加数据量的连接信息</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#DB Configuration:</span><span class="token attr-name">spring.datasource.driverClassName</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">root</span></code></pre><h3 id="5-1-4-创建user表"><a href="#5-1-4-创建user表" class="headerlink" title="5.1.4 创建user表"></a>5.1.4 创建user表</h3><p>在test数据库中创建user表</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- ----------------------------</span><span class="token comment" spellcheck="true">-- Table structure for `user`</span><span class="token comment" spellcheck="true">-- ----------------------------</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span><span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token punctuation">(</span>  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>username<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>password<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">10</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- ----------------------------</span><span class="token comment" spellcheck="true">-- Records of user</span><span class="token comment" spellcheck="true">-- ----------------------------</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'zhangsan'</span><span class="token punctuation">,</span> <span class="token string">'123'</span><span class="token punctuation">,</span> <span class="token string">'张三'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'lisi'</span><span class="token punctuation">,</span> <span class="token string">'123'</span><span class="token punctuation">,</span> <span class="token string">'李四'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="5-1-5-创建实体Bean"><a href="#5-1-5-创建实体Bean" class="headerlink" title="5.1.5 创建实体Bean"></a>5.1.5 创建实体Bean</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 主键</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用户名</span>    <span class="token keyword">private</span> String username<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 密码</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 姓名</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//此处省略getter和setter方法 .. ..</span><span class="token punctuation">}</span></code></pre><h3 id="5-1-6-编写Mapper"><a href="#5-1-6-编写Mapper" class="headerlink" title="5.1.6 编写Mapper"></a>5.1.6 编写Mapper</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">queryUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>注意：@Mapper标记该类是一个mybatis的mapper接口，可以被spring boot自动扫描到spring上下文中</p><h3 id="5-1-7-配置Mapper映射文件"><a href="#5-1-7-配置Mapper映射文件" class="headerlink" title="5.1.7 配置Mapper映射文件"></a>5.1.7 配置Mapper映射文件</h3><p>在src\main\resources\mapper路径下加入UserMapper.xml配置文件”</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8" ?></span><span class="token doctype">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" ></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.itheima.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>queryUserList<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>user<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        select * from user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">></span></span></code></pre><h3 id="5-1-8-在application-properties中添加mybatis的信息"><a href="#5-1-8-在application-properties中添加mybatis的信息" class="headerlink" title="5.1.8 在application.properties中添加mybatis的信息"></a>5.1.8 在application.properties中添加mybatis的信息</h3><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#spring集成Mybatis环境</span><span class="token comment" spellcheck="true">#pojo别名扫描包</span><span class="token attr-name">mybatis.type-aliases-package</span><span class="token punctuation">=</span><span class="token attr-value">com.itheima.domain</span><span class="token comment" spellcheck="true">#加载Mybatis映射文件</span><span class="token attr-name">mybatis.mapper-locations</span><span class="token punctuation">=</span><span class="token attr-value">classpath:mapper/*Mapper.xml</span></code></pre><h3 id="5-1-9-编写测试Controller"><a href="#5-1-9-编写测试Controller" class="headerlink" title="5.1.9 编写测试Controller"></a>5.1.9 编写测试Controller</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserMapper userMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/queryUser"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">queryUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">queryUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> users<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-1-10-测试"><a href="#5-1-10-测试" class="headerlink" title="5.1.10 测试"></a>5.1.10 测试</h3><p><img src="/2018/11/25/springboot-ji-chu/img/14.png" alt=""></p><h2 id="5-2-SpringBoot整合Junit"><a href="#5-2-SpringBoot整合Junit" class="headerlink" title="5.2 SpringBoot整合Junit"></a>5.2 SpringBoot整合Junit</h2><h3 id="5-2-1-添加Junit的起步依赖"><a href="#5-2-1-添加Junit的起步依赖" class="headerlink" title="5.2.1 添加Junit的起步依赖"></a>5.2.1 添加Junit的起步依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--测试的起步依赖--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-2-2-编写测试类"><a href="#5-2-2-编写测试类" class="headerlink" title="5.2.2 编写测试类"></a>5.2.2 编写测试类</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>MySpringBootApplication<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>User<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span>UserMapper<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>Test<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>runner<span class="token punctuation">.</span>RunWith<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>SpringBootTest<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit4<span class="token punctuation">.</span>SpringRunner<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>classes <span class="token operator">=</span> MySpringBootApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MapperTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserMapper userMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">queryUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中，</p><p>SpringRunner继承自SpringJUnit4ClassRunner，使用哪一个Spring提供的测试测试引擎都可以</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SpringRunner</span> <span class="token keyword">extends</span> <span class="token class-name">SpringJUnit4ClassRunner</span> </code></pre><p>@SpringBootTest的属性指定的是引导类的字节码对象</p><h3 id="5-2-3-控制台打印信息"><a href="#5-2-3-控制台打印信息" class="headerlink" title="5.2.3 控制台打印信息"></a>5.2.3 控制台打印信息</h3><p><img src="/2018/11/25/springboot-ji-chu/img/15.png" alt=""></p><h2 id="5-3-SpringBoot整合Spring-Data-JPA"><a href="#5-3-SpringBoot整合Spring-Data-JPA" class="headerlink" title="5.3 SpringBoot整合Spring Data JPA"></a>5.3 SpringBoot整合Spring Data JPA</h2><h3 id="5-3-1-添加Spring-Data-JPA的起步依赖"><a href="#5-3-1-添加Spring-Data-JPA的起步依赖" class="headerlink" title="5.3.1 添加Spring Data JPA的起步依赖"></a>5.3.1 添加Spring Data JPA的起步依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- springBoot JPA的起步依赖 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-jpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-3-2-添加数据库驱动依赖"><a href="#5-3-2-添加数据库驱动依赖" class="headerlink" title="5.3.2 添加数据库驱动依赖"></a>5.3.2 添加数据库驱动依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- MySQL连接驱动 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-3-3-在application-properties中配置数据库和jpa的相关属性"><a href="#5-3-3-在application-properties中配置数据库和jpa的相关属性" class="headerlink" title="5.3.3 在application.properties中配置数据库和jpa的相关属性"></a>5.3.3 在application.properties中配置数据库和jpa的相关属性</h3><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#DB Configuration:</span><span class="token attr-name">spring.datasource.driverClassName</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token comment" spellcheck="true">#JPA Configuration:</span><span class="token attr-name">spring.jpa.database</span><span class="token punctuation">=</span><span class="token attr-value">MySQL</span><span class="token attr-name">spring.jpa.show-sql</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.jpa.generate-ddl</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.jpa.hibernate.ddl-auto</span><span class="token punctuation">=</span><span class="token attr-value">update</span><span class="token attr-name">spring.jpa.hibernate.naming_strategy</span><span class="token punctuation">=</span><span class="token attr-value">org.hibernate.cfg.ImprovedNamingStrategy</span></code></pre><h3 id="5-3-4-创建实体配置实体"><a href="#5-3-4-创建实体配置实体" class="headerlink" title="5.3.4 创建实体配置实体"></a>5.3.4 创建实体配置实体</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 主键</span>    <span class="token annotation punctuation">@Id</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> GenerationType<span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 用户名</span>    <span class="token keyword">private</span> String username<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 密码</span>    <span class="token keyword">private</span> String password<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 姓名</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//此处省略setter和getter方法... ...</span><span class="token punctuation">}</span></code></pre><h3 id="5-3-5-编写UserRepository"><a href="#5-3-5-编写UserRepository" class="headerlink" title="5.3.5 编写UserRepository"></a>5.3.5 编写UserRepository</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserRepository</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token operator">&lt;</span>User<span class="token punctuation">,</span>Long<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="5-3-6-编写测试类"><a href="#5-3-6-编写测试类" class="headerlink" title="5.3.6 编写测试类"></a>5.3.6 编写测试类</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>classes<span class="token operator">=</span>MySpringBootApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JpaTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserRepository userRepository<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> userRepository<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-3-7-控制台打印信息"><a href="#5-3-7-控制台打印信息" class="headerlink" title="5.3.7 控制台打印信息"></a>5.3.7 控制台打印信息</h3><p><img src="/2018/11/25/springboot-ji-chu/img/16.png" alt=""></p><p>注意：如果是jdk9，执行报错如下：</p><p><img src="/2018/11/25/springboot-ji-chu/img/17.png" alt=""></p><p>原因：jdk缺少相应的jar</p><p>解决方案：手动导入对应的maven坐标，如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--jdk9需要导入如下坐标--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>javax.xml.bind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jaxb-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h2 id="5-4-SpringBoot整合Redis"><a href="#5-4-SpringBoot整合Redis" class="headerlink" title="5.4 SpringBoot整合Redis"></a>5.4 SpringBoot整合Redis</h2><h3 id="5-4-1-添加redis的起步依赖"><a href="#5-4-1-添加redis的起步依赖" class="headerlink" title="5.4.1 添加redis的起步依赖"></a>5.4.1 添加redis的起步依赖</h3><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 配置使用redis启动器 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-4-2-配置redis的连接信息"><a href="#5-4-2-配置redis的连接信息" class="headerlink" title="5.4.2 配置redis的连接信息"></a>5.4.2 配置redis的连接信息</h3><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#Redis</span><span class="token attr-name">spring.redis.host</span><span class="token punctuation">=</span><span class="token attr-value">127.0.0.1</span><span class="token attr-name">spring.redis.port</span><span class="token punctuation">=</span><span class="token attr-value">6379</span></code></pre><h3 id="5-4-3-注入RedisTemplate测试redis操作"><a href="#5-4-3-注入RedisTemplate测试redis操作" class="headerlink" title="5.4.3 注入RedisTemplate测试redis操作"></a>5.4.3 注入RedisTemplate测试redis操作</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RunWith</span><span class="token punctuation">(</span>SpringRunner<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>classes <span class="token operator">=</span> SpringbootJpaApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserRepository userRepository<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> JsonProcessingException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//从redis缓存中获得指定的数据</span>        String userListData <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"user.findAll"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果redis中没有数据的话</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>null<span class="token operator">==</span>userListData<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//查询数据库获得数据</span>            List<span class="token operator">&lt;</span>User<span class="token operator">></span> all <span class="token operator">=</span> userRepository<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//转换成json格式字符串</span>            ObjectMapper om <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            userListData <span class="token operator">=</span> om<span class="token punctuation">.</span><span class="token function">writeValueAsString</span><span class="token punctuation">(</span>all<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//将数据存储到redis中，下次在查询直接从redis中获得数据，不用在查询数据库</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">boundValueOps</span><span class="token punctuation">(</span><span class="token string">"user.findAll"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>userListData<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===============从数据库获得数据==============="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"===============从redis缓存中获得数据==============="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>userListData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Docker环境下的前后端分离部署与运维》课程脚本</title>
      <link href="/2018/08/14/docker-qian-hou-duan-fen-chi/"/>
      <url>/2018/08/14/docker-qian-hou-duan-fen-chi/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker虚拟机常用命令"><a href="#Docker虚拟机常用命令" class="headerlink" title="Docker虚拟机常用命令"></a>Docker虚拟机常用命令</h2><ol><li><p>先更新软件包</p><pre class=" language-shell"><code class="language-shell">yum -y update</code></pre></li><li><p>安装Docker虚拟机</p><pre class=" language-shell"><code class="language-shell">yum install -y docker</code></pre></li><li><p>运行、重启、关闭Docker虚拟机</p><pre class=" language-shell"><code class="language-shell">service docker startservice docker startservice docker stop</code></pre></li><li><p>搜索镜像</p><pre class=" language-shell"><code class="language-shell">docker search 镜像名称</code></pre></li><li><p>下载镜像</p><pre class=" language-shell"><code class="language-shell">docker pull 镜像名称</code></pre></li><li><p>查看镜像</p><pre class=" language-shell"><code class="language-shell">docker images</code></pre></li><li><p>删除镜像</p><pre class=" language-shell"><code class="language-shell">docker rmi 镜像名称</code></pre></li><li><p>运行容器</p><pre class=" language-shell"><code class="language-shell">docker run 启动参数  镜像名称</code></pre></li><li><p>查看容器列表</p><pre class=" language-shell"><code class="language-shell">docker ps -a</code></pre></li><li><p>停止、挂起、恢复容器</p><pre class=" language-shell"><code class="language-shell">docker stop 容器IDdocker pause 容器IDdocker unpase 容器ID</code></pre></li><li><p>查看容器信息</p><pre class=" language-shell"><code class="language-shell">docker inspect 容器ID</code></pre></li><li><p>删除容器</p><pre class=" language-shell"><code class="language-shell">docker rm 容器ID</code></pre></li><li><p>数据卷管理</p><pre class=" language-shell"><code class="language-shell">docker volume create 数据卷名称  #创建数据卷docker volume rm 数据卷名称  #删除数据卷docker volume inspect 数据卷名称  #查看数据卷</code></pre></li><li><p>网络管理</p><pre class=" language-shell"><code class="language-shell">docker network ls 查看网络信息docker network create --subnet=网段 网络名称docker network rm 网络名称</code></pre></li><li><p>避免VM虚拟机挂起恢复之后，Docker虚拟机断网</p><pre class=" language-shell"><code class="language-shell">vi /etc/sysctl.conf</code></pre></li></ol><pre><code>文件中添加`net.ipv4.ip_forward=1`这个配置​```shell#重启网络服务systemctl  restart network​```</code></pre><h2 id="安装PXC集群，负载均衡，双机热备"><a href="#安装PXC集群，负载均衡，双机热备" class="headerlink" title="安装PXC集群，负载均衡，双机热备"></a>安装PXC集群，负载均衡，双机热备</h2><ol><li><p>安装PXC镜像</p><pre class=" language-shell"><code class="language-shell">docker pull percona/percona-xtradb-cluster</code></pre></li><li><p>为PXC镜像改名</p><pre class=" language-shell"><code class="language-shell">docker tag percona/percona-xtradb-cluster pxc</code></pre></li><li><p>创建net1网段</p><pre class=" language-shell"><code class="language-shell">docker network create --subnet=172.18.0.0/16 net1</code></pre></li><li><p>创建5个数据卷</p><pre class=" language-shell"><code class="language-shell">docker volume create --name v1docker volume create --name v2docker volume create --name v3docker volume create --name v4docker volume create --name v5</code></pre></li><li><p>创建备份数据卷（用于热备份数据）</p><pre class=" language-shell"><code class="language-shell">docker volume create --name backup</code></pre></li><li><p>创建5节点的PXC集群</p><p>注意，每个MySQL容器创建之后，因为要执行PXC的初始化和加入集群等工作，耐心等待1分钟左右再用客户端连接MySQL。另外，必须第1个MySQL节点启动成功，用MySQL客户端能连接上之后，再去创建其他MySQL节点。</p><pre class=" language-shell"><code class="language-shell">#创建第1个MySQL节点docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxc#创建第2个MySQL节点docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root -e CLUSTER_JOIN=node1 -v v2:/var/lib/mysql -v backup:/data --privileged --name=node2 --net=net1 --ip 172.18.0.3 pxc#创建第3个MySQL节点docker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root -e CLUSTER_JOIN=node1 -v v3:/var/lib/mysql --privileged --name=node3 --net=net1 --ip 172.18.0.4 pxc#创建第4个MySQL节点docker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root -e CLUSTER_JOIN=node1 -v v4:/var/lib/mysql --privileged --name=node4 --net=net1 --ip 172.18.0.5 pxc#创建第5个MySQL节点docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=root -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=root -e CLUSTER_JOIN=node1 -v v5:/var/lib/mysql -v backup:/data --privileged --name=node5 --net=net1 --ip 172.18.0.6 pxc</code></pre></li><li><p>安装Haproxy镜像</p><pre class=" language-shell"><code class="language-shell">docker pull haproxy</code></pre></li><li><p>宿主机上编写Haproxy配置文件</p><pre class=" language-shell"><code class="language-shell">vi /home/soft/haproxy.cfg</code></pre><p>配置文件如下：</p><pre class=" language-properties"><code class="language-properties">global<span class="token comment" spellcheck="true">    #工作目录</span><span class="token attr-name">    chroot</span> <span class="token attr-value">/usr/local/etc/haproxy</span><span class="token comment" spellcheck="true">    #日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info</span><span class="token attr-name">    log</span> <span class="token attr-value">127.0.0.1 local5 info</span><span class="token comment" spellcheck="true">    #守护进程运行</span>    daemondefaults<span class="token attr-name">    log</span> <span class="token attr-value">   global</span><span class="token attr-name">    mode</span> <span class="token attr-value">   http</span><span class="token comment" spellcheck="true">    #日志格式</span><span class="token attr-name">    option</span> <span class="token attr-value">   httplog</span><span class="token comment" spellcheck="true">    #日志中不记录负载均衡的心跳检测记录</span><span class="token attr-name">    option</span> <span class="token attr-value">   dontlognull</span><span class="token comment" spellcheck="true">    #连接超时（毫秒）</span><span class="token attr-name">    timeout</span> <span class="token attr-value">connect 5000</span><span class="token comment" spellcheck="true">    #客户端超时（毫秒）</span><span class="token attr-name">    timeout</span> <span class="token attr-value">client  50000</span><span class="token comment" spellcheck="true">    #服务器超时（毫秒）</span><span class="token attr-name">    timeout</span> <span class="token attr-value">server  50000</span><span class="token comment" spellcheck="true">#监控界面    </span><span class="token attr-name">listen</span> <span class="token attr-value"> admin_stats</span><span class="token comment" spellcheck="true">    #监控界面的访问的IP和端口</span><span class="token attr-name">    bind</span> <span class="token attr-value"> 0.0.0.0:8888</span><span class="token comment" spellcheck="true">    #访问协议</span><span class="token attr-name">    mode</span> <span class="token attr-value">       http</span><span class="token comment" spellcheck="true">    #URI相对地址</span><span class="token attr-name">    stats</span> <span class="token attr-value">uri   /dbs</span><span class="token comment" spellcheck="true">    #统计报告格式</span><span class="token attr-name">    stats</span> <span class="token attr-value">realm     Global\ statistics</span><span class="token comment" spellcheck="true">    #登陆帐户信息</span><span class="token attr-name">    stats</span> <span class="token attr-value">auth  admin:abc123456</span><span class="token comment" spellcheck="true">#数据库负载均衡</span><span class="token attr-name">listen</span> <span class="token attr-value"> proxy-mysql</span><span class="token comment" spellcheck="true">    #访问的IP和端口</span><span class="token attr-name">    bind</span> <span class="token attr-value"> 0.0.0.0:3306  </span><span class="token comment" spellcheck="true">    #网络协议</span><span class="token attr-name">    mode</span> <span class="token attr-value"> tcp</span><span class="token comment" spellcheck="true">    #负载均衡算法（轮询算法）</span><span class="token comment" spellcheck="true">    #轮询算法：roundrobin</span><span class="token comment" spellcheck="true">    #权重算法：static-rr</span><span class="token comment" spellcheck="true">    #最少连接算法：leastconn</span><span class="token comment" spellcheck="true">    #请求源IP算法：source </span><span class="token attr-name">    balance</span> <span class="token attr-value"> roundrobin</span><span class="token comment" spellcheck="true">    #日志格式</span><span class="token attr-name">    option</span> <span class="token attr-value"> tcplog</span><span class="token comment" spellcheck="true">    #在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测</span><span class="token attr-name">    option</span> <span class="token attr-value"> mysql-check user haproxy</span><span class="token attr-name">    server</span> <span class="token attr-value"> MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000  </span><span class="token attr-name">    server</span> <span class="token attr-value"> MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000  </span><span class="token attr-name">    server</span> <span class="token attr-value"> MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000 </span><span class="token attr-name">    server</span> <span class="token attr-value"> MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000</span><span class="token attr-name">    server</span> <span class="token attr-value"> MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000</span><span class="token comment" spellcheck="true">    #使用keepalive检测死链</span><span class="token attr-name">    option</span> <span class="token attr-value"> tcpka  </span></code></pre></li><li><p>创建两个Haproxy容器</p><pre class=" language-shell"><code class="language-shell">#创建第1个Haproxy负载均衡服务器docker run -it -d -p 4001:8888 -p 4002:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h1 --privileged --net=net1 --ip 172.18.0.7 haproxy#进入h1容器，启动Haproxydocker exec -it h1 bashhaproxy -f /usr/local/etc/haproxy/haproxy.cfg#创建第2个Haproxy负载均衡服务器docker run -it -d -p 4003:8888 -p 4004:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h2 --privileged --net=net1 --ip 172.18.0.8 haproxy#进入h2容器，启动Haproxydocker exec -it h2 bashhaproxy -f /usr/local/etc/haproxy/haproxy.cfg</code></pre></li><li><p>Haproxy容器内安装Keepalived，设置虚拟IP</p><pre class=" language-shell"><code class="language-shell">#进入h1容器docker exec -it h1 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件（参考下方配置文件）vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start#宿主机执行ping命令ping 172.18.0.201</code></pre><p>配置文件内容如下：</p><pre><code>vrrp_instance  VI_1 {    state  MASTER    interface  eth0    virtual_router_id  51    priority  100    advert_int  1    authentication {        auth_type  PASS        auth_pass  123456    }    virtual_ipaddress {        172.18.0.201    }}</code></pre><pre class=" language-shell"><code class="language-shell">#进入h2容器docker exec -it h2 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start#宿主机执行ping命令ping 172.18.0.201</code></pre><p>配置文件内容如下：</p><pre class=" language-shell"><code class="language-shell">vrrp_instance  VI_1 {    state  MASTER    interface  eth0    virtual_router_id  51    priority  100    advert_int  1    authentication {        auth_type  PASS        auth_pass  123456    }    virtual_ipaddress {        172.18.0.201    }}</code></pre></li><li><p>宿主机安装Keepalived，实现双击热备</p><pre class=" language-shell"><code class="language-shell">#宿主机执行安装Keepalivedyum -y install keepalived#修改Keepalived配置文件vi /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><p>Keepalived配置文件如下：</p><pre class=" language-shell"><code class="language-shell">vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 51    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 1111    }    virtual_ipaddress {           192.168.99.150    }}virtual_server 192.168.99.150 8888 {    delay_loop 3    lb_algo rr     lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 172.18.0.201 8888 {        weight 1    }}virtual_server 192.168.99.150 3306 {    delay_loop 3    lb_algo rr     lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 172.18.0.201 3306 {        weight 1    }}</code></pre></li><li><p>热备份数据</p><pre class=" language-shell"><code class="language-shell">#进入node1容器docker exec -it node1 bash#更新软件包apt-get update#安装热备工具apt-get install percona-xtrabackup-24#全量热备innobackupex --user=root --password=abc123456 /data/backup/full</code></pre></li><li><p>冷还原数据<br>停止其余4个节点，并删除节点</p><pre class=" language-shell"><code class="language-shell">docker stop node2docker stop node3docker stop node4docker stop node5docker rm node2docker rm node3docker rm node4docker rm node5</code></pre><p>node1容器中删除MySQL的数据</p><pre class=" language-shell"><code class="language-shell">#删除数据rm -rf /var/lib/mysql/*#清空事务innobackupex --user=root --password=abc123456 --apply-back /data/backup/full/2018-04-15_05-09-07/#还原数据innobackupex --user=root --password=abc123456 --copy-back  /data/backup/full/2018-04-15_05-09-07/</code></pre><p>重新创建其余4个节点，组件PXC集群</p></li></ol><h2 id="安装Redis，配置RedisCluster集群"><a href="#安装Redis，配置RedisCluster集群" class="headerlink" title="安装Redis，配置RedisCluster集群"></a>安装Redis，配置RedisCluster集群</h2><ol><li><p>安装Redis镜像</p><pre class=" language-shell"><code class="language-shell">docker pull yyyyttttwwww/redis</code></pre></li><li><p>创建net2网段</p><pre class=" language-shell"><code class="language-shell">docker network create --subnet=172.19.0.0/16 net2</code></pre></li><li><p>创建6节点Redis容器</p><pre class=" language-shell"><code class="language-shell">docker run -it -d --name r1 -p 5001:6379 --net=net2 --ip 172.19.0.2 redis bashdocker run -it -d --name r2 -p 5002:6379 --net=net2 --ip 172.19.0.3 redis bashdocker run -it -d --name r3 -p 5003:6379 --net=net2 --ip 172.19.0.4 redis bashdocker run -it -d --name r4 -p 5004:6379 --net=net2 --ip 172.19.0.5 redis bashdocker run -it -d --name r5 -p 5005:6379 --net=net2 --ip 172.19.0.6 redis bash</code></pre></li><li><p>启动6节点Redis服务器</p><pre class=" language-shell"><code class="language-shell">#进入r1节点docker exec -it r1 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r2节点docker exec -it r2 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r3节点docker exec -it r3 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r4节点docker exec -it r4 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r5节点docker exec -it r5 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf#进入r6节点docker exec -it r6 bashcp /home/redis/redis.conf /usr/redis/redis.confcd /usr/redis/src./redis-server ../redis.conf</code></pre></li><li><p>创建Cluster集群</p><pre class=" language-shell"><code class="language-shell">#在r1节点上执行下面的指令cd /usr/redis/srcmkdir -p ../clustercp redis-trib.rb ../cluster/cd ../cluster#创建Cluster集群./redis-trib.rb create --replicas 1 172.19.0.2:6379 172.19.0.3:6379 172.19.0.4:6379 172.19.0.5:6379 172.19.0.6:6379 172.19.0.7:6379</code></pre></li></ol><h2 id="打包部署后端项目"><a href="#打包部署后端项目" class="headerlink" title="打包部署后端项目"></a>打包部署后端项目</h2><ol><li><p>进入人人开源后端项目，执行打包（修改配置文件，更改端口，打包三次生成三个JAR文件）</p><pre class=" language-shell"><code class="language-shell">mvn clean install -Dmaven.test.skip=true</code></pre></li><li><p>安装Java镜像</p><pre class=" language-shell"><code class="language-shell">docker pull java</code></pre></li><li><p>创建3节点Java容器</p><pre class=" language-shell"><code class="language-shell">#创建数据卷，上传JAR文件docker volume create j1#启动容器docker run -it -d --name j1 -v j1:/home/soft --net=host java#进入j1容器docker exec -it j1 bash#启动Java项目nohup java -jar /home/soft/renren-fast.jar#创建数据卷，上传JAR文件docker volume create j2#启动容器docker run -it -d --name j2 -v j2:/home/soft --net=host java#进入j1容器docker exec -it j2 bash#启动Java项目nohup java -jar /home/soft/renren-fast.jar#创建数据卷，上传JAR文件docker volume create j3#启动容器docker run -it -d --name j3 -v j3:/home/soft --net=host java#进入j1容器docker exec -it j3 bash#启动Java项目nohup java -jar /home/soft/renren-fast.jar</code></pre></li><li><p>安装Nginx镜像</p><pre class=" language-shell"><code class="language-shell">docker pull nginx</code></pre></li><li><p>创建Nginx容器，配置负载均衡</p><p>宿主机上/home/n1/nginx.conf配置文件内容如下：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">user</span> <span class="token attr-value"> nginx;</span><span class="token attr-name">worker_processes</span> <span class="token attr-value"> 1;</span><span class="token attr-name">error_log</span> <span class="token attr-value"> /var/log/nginx/error.log warn;</span><span class="token attr-name">pid</span> <span class="token attr-value">       /var/run/nginx.pid;</span><span class="token attr-name">events</span> <span class="token attr-value">{</span><span class="token attr-name">    worker_connections</span> <span class="token attr-value"> 1024;</span>}<span class="token attr-name">http</span> <span class="token attr-value">{</span><span class="token attr-name">    include</span> <span class="token attr-value">      /etc/nginx/mime.types;</span><span class="token attr-name">    default_type</span> <span class="token attr-value"> application/octet-stream;</span><span class="token attr-name">    log_format</span> <span class="token attr-value"> main  '$remote_addr - $remote_user [$time_local] "$request" '</span><span class="token attr-name">                      '$status</span> <span class="token attr-value">$body_bytes_sent "$http_referer" '</span><span class="token attr-name">                      '"$http_user_agent"</span> <span class="token attr-value">"$http_x_forwarded_for"';</span><span class="token attr-name">    access_log</span> <span class="token attr-value"> /var/log/nginx/access.log  main;</span><span class="token attr-name">    sendfile</span> <span class="token attr-value">       on;</span><span class="token comment" spellcheck="true">    #tcp_nopush     on;</span><span class="token attr-name">    keepalive_timeout</span> <span class="token attr-value"> 65;</span><span class="token comment" spellcheck="true">    #gzip  on;</span><span class="token attr-name">    proxy_redirect</span> <span class="token attr-value">         off;</span><span class="token attr-name">    proxy_set_header</span> <span class="token attr-value">       Host $host;</span><span class="token attr-name">    proxy_set_header</span> <span class="token attr-value">       X-Real-IP $remote_addr;</span><span class="token attr-name">    proxy_set_header</span> <span class="token attr-value">       X-Forwarded-For $proxy_add_x_forwarded_for;</span><span class="token attr-name">    client_max_body_size</span> <span class="token attr-value">   10m;</span><span class="token attr-name">    client_body_buffer_size</span> <span class="token attr-value">  128k;</span><span class="token attr-name">    proxy_connect_timeout</span> <span class="token attr-value">  5s;</span><span class="token attr-name">    proxy_send_timeout</span> <span class="token attr-value">     5s;</span><span class="token attr-name">    proxy_read_timeout</span> <span class="token attr-value">     5s;</span><span class="token attr-name">    proxy_buffer_size</span> <span class="token attr-value">       4k;</span><span class="token attr-name">    proxy_buffers</span> <span class="token attr-value">          4 32k;</span><span class="token attr-name">    proxy_busy_buffers_size</span> <span class="token attr-value"> 64k;</span><span class="token attr-name">    proxy_temp_file_write_size</span> <span class="token attr-value">64k;</span><span class="token attr-name">    upstream</span> <span class="token attr-value">tomcat {</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.99.104:6001;</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.99.104:6002;</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.99.104:6003;</span>    }<span class="token attr-name">    server</span> <span class="token attr-value">{</span><span class="token attr-name">        listen</span> <span class="token attr-value">      6101;</span><span class="token attr-name">        server_name</span> <span class="token attr-value"> 192.168.99.104; </span><span class="token attr-name">        location</span> <span class="token attr-value">/ {  </span><span class="token attr-name">            proxy_pass</span> <span class="token attr-value">  http://tomcat;</span><span class="token attr-name">            index</span> <span class="token attr-value"> index.html index.htm;  </span><span class="token attr-name">        }</span> <span class="token attr-value"> </span>    }}</code></pre><p>创建第1个Nginx节点</p><pre class=" language-shell"><code class="language-shell">docker run -it -d --name n1 -v /home/n1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre><p>宿主机上/home/n2/nginx.conf配置文件内容如下：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">user</span> <span class="token attr-value"> nginx;</span><span class="token attr-name">worker_processes</span> <span class="token attr-value"> 1;</span><span class="token attr-name">error_log</span> <span class="token attr-value"> /var/log/nginx/error.log warn;</span><span class="token attr-name">pid</span> <span class="token attr-value">       /var/run/nginx.pid;</span><span class="token attr-name">events</span> <span class="token attr-value">{</span><span class="token attr-name">    worker_connections</span> <span class="token attr-value"> 1024;</span>}<span class="token attr-name">http</span> <span class="token attr-value">{</span><span class="token attr-name">    include</span> <span class="token attr-value">      /etc/nginx/mime.types;</span><span class="token attr-name">    default_type</span> <span class="token attr-value"> application/octet-stream;</span><span class="token attr-name">    log_format</span> <span class="token attr-value"> main  '$remote_addr - $remote_user [$time_local] "$request" '</span><span class="token attr-name">                      '$status</span> <span class="token attr-value">$body_bytes_sent "$http_referer" '</span><span class="token attr-name">                      '"$http_user_agent"</span> <span class="token attr-value">"$http_x_forwarded_for"';</span><span class="token attr-name">    access_log</span> <span class="token attr-value"> /var/log/nginx/access.log  main;</span><span class="token attr-name">    sendfile</span> <span class="token attr-value">       on;</span><span class="token comment" spellcheck="true">    #tcp_nopush     on;</span><span class="token attr-name">    keepalive_timeout</span> <span class="token attr-value"> 65;</span><span class="token comment" spellcheck="true">    #gzip  on;</span><span class="token attr-name">    proxy_redirect</span> <span class="token attr-value">         off;</span><span class="token attr-name">    proxy_set_header</span> <span class="token attr-value">       Host $host;</span><span class="token attr-name">    proxy_set_header</span> <span class="token attr-value">       X-Real-IP $remote_addr;</span><span class="token attr-name">    proxy_set_header</span> <span class="token attr-value">       X-Forwarded-For $proxy_add_x_forwarded_for;</span><span class="token attr-name">    client_max_body_size</span> <span class="token attr-value">   10m;</span><span class="token attr-name">    client_body_buffer_size</span> <span class="token attr-value">  128k;</span><span class="token attr-name">    proxy_connect_timeout</span> <span class="token attr-value">  5s;</span><span class="token attr-name">    proxy_send_timeout</span> <span class="token attr-value">     5s;</span><span class="token attr-name">    proxy_read_timeout</span> <span class="token attr-value">     5s;</span><span class="token attr-name">    proxy_buffer_size</span> <span class="token attr-value">       4k;</span><span class="token attr-name">    proxy_buffers</span> <span class="token attr-value">          4 32k;</span><span class="token attr-name">    proxy_busy_buffers_size</span> <span class="token attr-value"> 64k;</span><span class="token attr-name">    proxy_temp_file_write_size</span> <span class="token attr-value">64k;</span><span class="token attr-name">    upstream</span> <span class="token attr-value">tomcat {</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.99.104:6001;</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.99.104:6002;</span><span class="token attr-name">        server</span> <span class="token attr-value">192.168.99.104:6003;</span>    }<span class="token attr-name">    server</span> <span class="token attr-value">{</span><span class="token attr-name">        listen</span> <span class="token attr-value">      6102;</span><span class="token attr-name">        server_name</span> <span class="token attr-value"> 192.168.99.104; </span><span class="token attr-name">        location</span> <span class="token attr-value">/ {  </span><span class="token attr-name">            proxy_pass</span> <span class="token attr-value">  http://tomcat;</span><span class="token attr-name">            index</span> <span class="token attr-value"> index.html index.htm;  </span><span class="token attr-name">        }</span> <span class="token attr-value"> </span>    }}</code></pre><p>创建第2个Nginx节点</p><pre class=" language-shell"><code class="language-shell">docker run -it -d --name n2 -v /home/n2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre></li><li><p>在Nginx容器安装Keepalived</p><pre class=" language-shell"><code class="language-shell">#进入n1节点docker exec -it n1 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre><code>vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 51    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    virtual_ipaddress {        192.168.99.151    }}virtual_server 192.168.99.151 6201 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6101 {        weight 1    }}</code></pre><pre class=" language-shell"><code class="language-shell">#进入n1节点docker exec -it n2 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre class=" language-shell"><code class="language-shell">vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 51    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    virtual_ipaddress {        192.168.99.151    }}virtual_server 192.168.99.151 6201 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6102 {        weight 1    }}</code></pre></li></ol><h2 id="打包部署后端项目-1"><a href="#打包部署后端项目-1" class="headerlink" title="打包部署后端项目"></a>打包部署后端项目</h2><ol><li><p>在前端项目路径下执行打包指令</p><pre class=" language-shell"><code class="language-shell">npm run build</code></pre></li><li><p>build目录的文件拷贝到宿主机的/home/fn1/renren-vue、/home/fn2/renren-vue、/home/fn3/renren-vue的目录下面</p></li><li><p>创建3节点的Nginx，部署前端项目</p><p>宿主机/home/fn1/nginx.conf的配置文件</p><pre><code>user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    server {        listen 6501;        server_name  192.168.99.104;        location  /  {            root  /home/fn1/renren-vue;            index  index.html;        }    }}</code></pre><pre class=" language-shell"><code class="language-shell">#启动第fn1节点docker run -it -d --name fn1 -v /home/fn1/nginx.conf:/etc/nginx/nginx.conf -v /home/fn1/renren-vue:/home/fn1/renren-vue --privileged --net=host nginx</code></pre><p>宿主机/home/fn2/nginx.conf的配置文件</p><pre class=" language-shell"><code class="language-shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    server {        listen 6502;        server_name  192.168.99.104;        location  /  {            root  /home/fn2/renren-vue;            index  index.html;        }    }}</code></pre><pre class=" language-shell"><code class="language-shell">#启动第fn2节点docker run -it -d --name fn2 -v /home/fn2/nginx.conf:/etc/nginx/nginx.conf -v /home/fn2/renren-vue:/home/fn2/renren-vue --privileged --net=host nginx</code></pre><p>宿主机/home/fn3/nginx.conf的配置文件</p><pre class=" language-shell"><code class="language-shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    server {        listen 6503;        server_name  192.168.99.104;        location  /  {            root  /home/fn3/renren-vue;            index  index.html;        }    }}</code></pre><p>启动fn3节点</p><pre class=" language-shell"><code class="language-shell">#启动第fn3节点docker run -it -d --name fn3 -v /home/fn3/nginx.conf:/etc/nginx/nginx.conf -v /home/fn3/renren-vue:/home/fn3/renren-vue --privileged --net=host nginx</code></pre></li><li><p>配置负载均衡</p><p>宿主机/home/ff1/nginx.conf配置文件</p><pre class=" language-shell"><code class="language-shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    upstream fn {        server 192.168.99.104:6501;        server 192.168.99.104:6502;        server 192.168.99.104:6503;    }    server {        listen       6601;        server_name  192.168.99.104;         location / {              proxy_pass   http://fn;            index  index.html index.htm;          }      }}</code></pre><pre class=" language-shell"><code class="language-shell">#启动ff1节点docker run -it -d --name ff1 -v /home/ff1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre><p>宿主机/home/ff2/nginx.conf配置文件</p><pre class=" language-shell"><code class="language-shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    proxy_redirect          off;    proxy_set_header        Host $host;    proxy_set_header        X-Real-IP $remote_addr;    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;    client_max_body_size    10m;    client_body_buffer_size   128k;    proxy_connect_timeout   5s;    proxy_send_timeout      5s;    proxy_read_timeout      5s;    proxy_buffer_size        4k;    proxy_buffers           4 32k;    proxy_busy_buffers_size  64k;    proxy_temp_file_write_size 64k;    upstream fn {        server 192.168.99.104:6501;        server 192.168.99.104:6502;        server 192.168.99.104:6503;    }    server {        listen       6602;        server_name  192.168.99.104;         location / {              proxy_pass   http://fn;            index  index.html index.htm;          }      }}</code></pre><pre class=" language-shell"><code class="language-shell">#启动ff2节点docker run -it -d --name ff2 -v /home/ff2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre></li><li><p>配置双机热备</p><pre class=" language-shell"><code class="language-shell">#进入ff1节点docker exec -it ff1 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre class=" language-shell"><code class="language-shell">vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 52    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    virtual_ipaddress {        192.168.99.152    }}virtual_server 192.168.99.151 6701 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6601 {        weight 1    }}</code></pre><pre class=" language-shell"><code class="language-shell">#进入ff1节点docker exec -it ff2 bash#更新软件包apt-get update#安装VIMapt-get install vim#安装Keepalivedapt-get install keepalived#编辑Keepalived配置文件(如下)vim /etc/keepalived/keepalived.conf#启动Keepalivedservice keepalived start</code></pre><pre class=" language-shell"><code class="language-shell">vrrp_instance VI_1 {    state MASTER    interface ens33    virtual_router_id 52    priority 100    advert_int 1    authentication {        auth_type PASS        auth_pass 123456    }    virtual_ipaddress {        192.168.99.152    }}virtual_server 192.168.99.151 6701 {    delay_loop 3    lb_algo rr    lb_kind NAT    persistence_timeout 50    protocol TCP    real_server 192.168.99.104 6602 {        weight 1    }}</code></pre><p>​</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 前后端分离 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
